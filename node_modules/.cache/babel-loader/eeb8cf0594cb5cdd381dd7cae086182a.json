{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) {\n      if (b.hasOwnProperty(p)) d[p] = b[p];\n    }\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar K = require(\"../backend/tfjs_backend\");\n\nvar constraints_1 = require(\"../constraints\");\n\nvar topology_1 = require(\"../engine/topology\");\n\nvar errors_1 = require(\"../errors\");\n\nvar initializers_1 = require(\"../initializers\");\n\nvar regularizers_1 = require(\"../regularizers\");\n\nvar generic_utils = require(\"../utils/generic_utils\");\n\nvar generic_utils_1 = require(\"../utils/generic_utils\");\n\nvar Embedding = function (_super) {\n  __extends(Embedding, _super);\n\n  function Embedding(config) {\n    var _this = _super.call(this, config) || this;\n\n    _this.embeddings = null;\n    _this.DEFAULT_EMBEDDINGS_INITIALIZER = 'randomUniform';\n\n    if (config.batchInputShape == null && config.inputShape == null) {\n      var batchSize = null;\n\n      if (config.batchSize != null) {\n        batchSize = config.batchSize;\n      }\n\n      if (config.inputLength == null) {\n        _this.batchInputShape = [batchSize, null];\n      } else {\n        _this.batchInputShape = [batchSize].concat(generic_utils.toList(config.inputLength));\n      }\n    }\n\n    _this.inputDim = config.inputDim;\n    _this.outputDim = config.outputDim;\n    _this.embeddingsInitializer = initializers_1.getInitializer(config.embeddingsInitializer || _this.DEFAULT_EMBEDDINGS_INITIALIZER);\n    _this.embeddingsRegularizer = regularizers_1.getRegularizer(config.embeddingsRegularizer);\n    _this.activityRegularizer = regularizers_1.getRegularizer(config.activityRegularizer);\n    _this.embeddingsConstraint = constraints_1.getConstraint(config.embeddingsConstraint);\n    _this.maskZero = config.maskZero;\n    _this.inputLength = config.inputLength;\n    return _this;\n  }\n\n  Embedding.prototype.build = function (inputShape) {\n    this.embeddings = this.addWeight('embeddings', [this.inputDim, this.outputDim], this.dtype, this.embeddingsInitializer, this.embeddingsRegularizer, true, this.embeddingsConstraint);\n    this.built = true;\n  };\n\n  Embedding.prototype.computeMask = function (inputs, mask) {\n    throw new errors_1.NotImplementedError('computeMask has not been implemented for Embedding yet');\n  };\n\n  Embedding.prototype.computeOutputShape = function (inputShape) {\n    inputShape = generic_utils.getExactlyOneShape(inputShape);\n\n    if (this.inputLength == null) {\n      return inputShape.concat([this.outputDim]);\n    }\n\n    var inLens = generic_utils.toList(this.inputLength);\n\n    if (inLens.length !== inputShape.length - 1) {\n      throw new errors_1.ValueError(\"\\\"inputLength\\\" is \" + this.inputLength + \", but received \" + (\"input shape has shape \" + inputShape));\n    } else {\n      var i = 0;\n\n      for (var k = 0; k < inLens.length; ++k) {\n        var s1 = inLens[k];\n        var s2 = inputShape[k + 1];\n\n        if (s1 != null && s2 != null && s1 !== s2) {\n          throw new errors_1.ValueError(\"\\\"inputLength\\\" is \" + this.inputLength + \", but received \" + (\"input shape has shape \" + inputShape));\n        } else if (s1 == null) {\n          inLens[i] = s2;\n        }\n\n        i++;\n      }\n    }\n\n    return [inputShape[0]].concat(inLens, [this.outputDim]);\n  };\n\n  Embedding.prototype.call = function (inputs, kwargs) {\n    this.invokeCallHook(inputs, kwargs);\n    var input = generic_utils.getExactlyOneTensor(inputs);\n\n    if (K.dtype(input) !== 'int32') {\n      input = K.cast(input, 'int32');\n    }\n\n    var output = K.gather(this.embeddings.read(), input.as1D());\n    return K.reshape(output, generic_utils_1.getExactlyOneShape(this.computeOutputShape(input.shape)));\n  };\n\n  Embedding.prototype.getClassName = function () {\n    return 'Embedding';\n  };\n\n  Embedding.prototype.getConfig = function () {\n    var config = {\n      inputDim: this.inputDim,\n      outputDim: this.outputDim,\n      embeddingsInitializer: initializers_1.serializeInitializer(this.embeddingsInitializer),\n      embeddingsRegularizer: regularizers_1.serializeRegularizer(this.embeddingsRegularizer),\n      activityRegularizer: regularizers_1.serializeRegularizer(this.activityRegularizer),\n      embeddingsConstraint: constraints_1.serializeConstraint(this.embeddingsConstraint),\n      maskZero: this.maskZero,\n      inputLength: this.inputLength\n    };\n\n    var baseConfig = _super.prototype.getConfig.call(this);\n\n    Object.assign(config, baseConfig);\n    return config;\n  };\n\n  return Embedding;\n}(topology_1.Layer);\n\nexports.Embedding = Embedding;\ngeneric_utils.ClassNameMap.register('Embedding', Embedding);","map":null,"metadata":{},"sourceType":"script"}