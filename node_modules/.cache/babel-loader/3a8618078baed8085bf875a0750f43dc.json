{"ast":null,"code":"\"use strict\";\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {\n    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  }\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar doc_1 = require(\"../doc\");\n\nvar environment_1 = require(\"../environment\");\n\nvar types_1 = require(\"../types\");\n\nvar util = require(\"../util\");\n\nvar broadcast_util = require(\"./broadcast_util\");\n\nvar operation_1 = require(\"./operation\");\n\nvar ops_1 = require(\"./ops\");\n\nvar BinaryOps = function () {\n  function BinaryOps() {}\n\n  BinaryOps.add = function (a, b) {\n    util.assertArgumentsAreTensors({\n      a: a,\n      b: b\n    }, 'add');\n    util.assertTypesMatch(a, b);\n    var outShape = broadcast_util.assertAndGetBroadcastShape(a.shape, b.shape);\n\n    var der = function der(dy) {\n      var derA = function derA() {\n        var res = dy;\n        var reduceAxes = broadcast_util.getReductionAxes(a.shape, outShape);\n\n        if (reduceAxes.length > 0) {\n          res = res.sum(reduceAxes);\n        }\n\n        return res.reshape(a.shape);\n      };\n\n      var derB = function derB() {\n        var res = dy;\n        var reduceAxes = broadcast_util.getReductionAxes(b.shape, outShape);\n\n        if (reduceAxes.length > 0) {\n          res = res.sum(reduceAxes);\n        }\n\n        return res.reshape(b.shape);\n      };\n\n      return {\n        a: derA,\n        b: derB\n      };\n    };\n\n    return environment_1.ENV.engine.runKernel(function (backend) {\n      return backend.add(a, b);\n    }, {\n      a: a,\n      b: b\n    }, der);\n  };\n\n  BinaryOps.addStrict = function (a, b) {\n    util.assertShapesMatch(a.shape, b.shape, 'Error in addStrict: ');\n    return a.add(b);\n  };\n\n  BinaryOps.sub = function (a, b) {\n    util.assertArgumentsAreTensors({\n      a: a,\n      b: b\n    }, 'sub');\n    util.assertTypesMatch(a, b);\n    var outShape = broadcast_util.assertAndGetBroadcastShape(a.shape, b.shape);\n\n    var der = function der(dy) {\n      var derA = function derA() {\n        var res = dy;\n        var reduceAxes = broadcast_util.getReductionAxes(a.shape, outShape);\n\n        if (reduceAxes.length > 0) {\n          res = res.sum(reduceAxes);\n        }\n\n        return res.reshape(a.shape);\n      };\n\n      var derB = function derB() {\n        var res = dy;\n        var reduceAxes = broadcast_util.getReductionAxes(b.shape, outShape);\n\n        if (reduceAxes.length > 0) {\n          res = res.sum(reduceAxes);\n        }\n\n        return res.neg().reshape(b.shape);\n      };\n\n      return {\n        a: derA,\n        b: derB\n      };\n    };\n\n    return environment_1.ENV.engine.runKernel(function (backend) {\n      return backend.subtract(a, b);\n    }, {\n      a: a,\n      b: b\n    }, der);\n  };\n\n  BinaryOps.subStrict = function (a, b) {\n    util.assertShapesMatch(a.shape, b.shape, 'Error in subStrict: ');\n    return a.sub(b);\n  };\n\n  BinaryOps.pow = function (base, exp) {\n    util.assertArgumentsAreTensors({\n      base: base,\n      exp: exp\n    }, 'pow');\n    var outShape = broadcast_util.assertAndGetBroadcastShape(base.shape, exp.shape);\n    base = base.cast(types_1.upcastType(base.dtype, exp.dtype));\n    exp = exp.cast(types_1.upcastType(base.dtype, exp.dtype));\n\n    var grad = function grad(dy, saved) {\n      var y = saved[0];\n\n      var derBase = function derBase() {\n        var res = dy.mul(exp.toFloat().mul(y.div(base)));\n        var reduceAxes = broadcast_util.getReductionAxes(base.shape, outShape);\n\n        if (reduceAxes.length > 0) {\n          res = res.sum(reduceAxes);\n        }\n\n        return res.reshape(base.shape);\n      };\n\n      var derExp = function derExp() {\n        var res = dy.mul(y.mul(base.log()).toFloat());\n        var reduceAxes = broadcast_util.getReductionAxes(exp.shape, outShape);\n\n        if (reduceAxes.length > 0) {\n          res = res.sum(reduceAxes);\n        }\n\n        return res.reshape(exp.shape);\n      };\n\n      return {\n        base: derBase,\n        exp: derExp\n      };\n    };\n\n    return environment_1.ENV.engine.runKernel(function (backend, save) {\n      return save(backend.pow(base, exp));\n    }, {\n      base: base,\n      exp: exp\n    }, grad);\n  };\n\n  BinaryOps.powStrict = function (base, exp) {\n    util.assertShapesMatch(base.shape, exp.shape, 'Error in powStrict: ');\n    return base.pow(exp);\n  };\n\n  BinaryOps.mul = function (a, b) {\n    util.assertArgumentsAreTensors({\n      a: a,\n      b: b\n    }, 'mul');\n    util.assertTypesMatch(a, b);\n    var outShape = broadcast_util.assertAndGetBroadcastShape(a.shape, b.shape);\n\n    var der = function der(dy) {\n      var derA = function derA() {\n        var res = dy.mul(b.toFloat());\n        var reduceAxes = broadcast_util.getReductionAxes(a.shape, outShape);\n\n        if (reduceAxes.length > 0) {\n          return res.sum(reduceAxes).reshape(a.shape);\n        }\n\n        return res;\n      };\n\n      var derB = function derB() {\n        var res = dy.mul(a.toFloat());\n        var reduceAxes = broadcast_util.getReductionAxes(b.shape, outShape);\n\n        if (reduceAxes.length > 0) {\n          return res.sum(reduceAxes).reshape(b.shape);\n        }\n\n        return res;\n      };\n\n      return {\n        a: derA,\n        b: derB\n      };\n    };\n\n    return environment_1.ENV.engine.runKernel(function (backend) {\n      return backend.multiply(a, b);\n    }, {\n      a: a,\n      b: b\n    }, der);\n  };\n\n  BinaryOps.mulStrict = function (a, b) {\n    util.assertShapesMatch(a.shape, b.shape, 'Error in multiplyStrict: ');\n    return a.mul(b);\n  };\n\n  BinaryOps.div = function (a, b) {\n    util.assertArgumentsAreTensors({\n      a: a,\n      b: b\n    }, 'div');\n    util.assertTypesMatch(a, b);\n    var outShape = broadcast_util.assertAndGetBroadcastShape(a.shape, b.shape);\n\n    var der = function der(dy) {\n      var derA = function derA() {\n        var res = dy.div(b.toFloat());\n        var reduceAxes = broadcast_util.getReductionAxes(a.shape, outShape);\n\n        if (reduceAxes.length > 0) {\n          return res.sum(reduceAxes).reshape(a.shape);\n        }\n\n        return res;\n      };\n\n      var derB = function derB() {\n        var res = dy.mul(a.toFloat());\n        var reduceAxes = broadcast_util.getReductionAxes(b.shape, outShape);\n\n        if (reduceAxes.length > 0) {\n          res = res.sum(reduceAxes).reshape(b.shape);\n        }\n\n        var tmp = b.square();\n        return res.div(tmp.toFloat()).neg();\n      };\n\n      return {\n        a: derA,\n        b: derB\n      };\n    };\n\n    return environment_1.ENV.engine.runKernel(function (backend) {\n      return backend.divide(a, b);\n    }, {\n      a: a,\n      b: b\n    }, der);\n  };\n\n  BinaryOps.divStrict = function (a, b) {\n    util.assertShapesMatch(a.shape, b.shape, 'Error in divideStrict: ');\n    return a.div(b);\n  };\n\n  BinaryOps.mod = function (a, b) {\n    util.assertArgumentsAreTensors({\n      a: a,\n      b: b\n    }, 'mod');\n    util.assertTypesMatch(a, b);\n    var outShape = broadcast_util.assertAndGetBroadcastShape(a.shape, b.shape);\n\n    var der = function der(dy) {\n      var derA = function derA() {\n        var reduceAxes = broadcast_util.getReductionAxes(a.shape, outShape);\n\n        if (reduceAxes.length > 0) {\n          return dy.sum(reduceAxes).reshape(a.shape);\n        }\n\n        return dy;\n      };\n\n      var derB = function derB() {\n        var res = dy.mul(a.div(b).floor().neg());\n        var reduceAxes = broadcast_util.getReductionAxes(b.shape, outShape);\n\n        if (reduceAxes.length > 0) {\n          return res.sum(reduceAxes).reshape(b.shape);\n        }\n\n        return res;\n      };\n\n      return {\n        a: derA,\n        b: derB\n      };\n    };\n\n    return environment_1.ENV.engine.runKernel(function (backend) {\n      return backend.mod(a, b);\n    }, {\n      a: a,\n      b: b\n    }, der);\n  };\n\n  BinaryOps.modStrict = function (a, b) {\n    util.assertShapesMatch(a.shape, b.shape, 'Error in modStrict: ');\n    return a.mod(b);\n  };\n\n  BinaryOps.minimum = function (a, b) {\n    util.assertArgumentsAreTensors({\n      a: a,\n      b: b\n    }, 'minimum');\n    util.assertTypesMatch(a, b);\n\n    if (a.dtype === 'bool') {\n      a = a.toInt();\n    }\n\n    if (b.dtype === 'bool') {\n      b = b.toInt();\n    }\n\n    broadcast_util.assertAndGetBroadcastShape(a.shape, b.shape);\n\n    var der = function der(dy) {\n      var derA = function derA() {\n        return dy.mul(a.lessEqual(b).toFloat());\n      };\n\n      var derB = function derB() {\n        return dy.mul(a.greater(b).toFloat());\n      };\n\n      return {\n        a: derA,\n        b: derB\n      };\n    };\n\n    return environment_1.ENV.engine.runKernel(function (backend) {\n      return backend.minimum(a, b);\n    }, {\n      a: a,\n      b: b\n    }, der);\n  };\n\n  BinaryOps.minimumStrict = function (a, b) {\n    util.assertShapesMatch(a.shape, b.shape, 'Error in minimumStrict: ');\n    return a.minimum(b);\n  };\n\n  BinaryOps.maximum = function (a, b) {\n    util.assertArgumentsAreTensors({\n      a: a,\n      b: b\n    }, 'maximum');\n    util.assertTypesMatch(a, b);\n\n    if (a.dtype === 'bool') {\n      a = a.toInt();\n    }\n\n    if (b.dtype === 'bool') {\n      b = b.toInt();\n    }\n\n    broadcast_util.assertAndGetBroadcastShape(a.shape, b.shape);\n\n    var der = function der(dy) {\n      var derA = function derA() {\n        return dy.mul(a.greaterEqual(b).toFloat());\n      };\n\n      var derB = function derB() {\n        return dy.mul(a.less(b).toFloat());\n      };\n\n      return {\n        a: derA,\n        b: derB\n      };\n    };\n\n    return environment_1.ENV.engine.runKernel(function (backend) {\n      return backend.maximum(a, b);\n    }, {\n      a: a,\n      b: b\n    }, der);\n  };\n\n  BinaryOps.maximumStrict = function (a, b) {\n    util.assertShapesMatch(a.shape, b.shape, 'Error in minimumStrict: ');\n    return a.maximum(b);\n  };\n\n  BinaryOps.squaredDifference = function (a, b) {\n    util.assertArgumentsAreTensors({\n      a: a,\n      b: b\n    }, 'squaredDifference');\n    util.assertTypesMatch(a, b);\n    broadcast_util.assertAndGetBroadcastShape(a.shape, b.shape);\n\n    var der = function der(dy) {\n      var two = ops_1.scalar(2);\n\n      var derA = function derA() {\n        return dy.mul(a.sub(b).mul(two));\n      };\n\n      var derB = function derB() {\n        return dy.mul(b.sub(a).mul(two));\n      };\n\n      return {\n        a: derA,\n        b: derB\n      };\n    };\n\n    return environment_1.ENV.engine.runKernel(function (backend) {\n      return backend.squaredDifference(a, b);\n    }, {\n      a: a,\n      b: b\n    }, der);\n  };\n\n  BinaryOps.squaredDifferenceStrict = function (a, b) {\n    util.assertShapesMatch(a.shape, b.shape, 'Error in squaredDifferenceStrict: ');\n    return a.squaredDifference(b);\n  };\n\n  BinaryOps.atan2 = function (a, b) {\n    util.assertArgumentsAreTensors({\n      a: a,\n      b: b\n    }, 'atan2');\n    util.assertTypesMatch(a, b);\n    var outShape = broadcast_util.assertAndGetBroadcastShape(a.shape, b.shape);\n\n    var der = function der(dy) {\n      var derA = function derA() {\n        var d = BinaryOps.add(ops_1.square(a), ops_1.square(b));\n        var res = dy.mul(b.div(d));\n        var reduceAxes = broadcast_util.getReductionAxes(a.shape, outShape);\n\n        if (reduceAxes.length > 0) {\n          res = res.sum(reduceAxes);\n        }\n\n        return res.reshape(a.shape);\n      };\n\n      var derB = function derB() {\n        var d = BinaryOps.add(ops_1.square(a), ops_1.square(b));\n        var res = ops_1.neg(dy.mul(a.div(d)));\n        var reduceAxes = broadcast_util.getReductionAxes(b.shape, outShape);\n\n        if (reduceAxes.length > 0) {\n          res = res.sum(reduceAxes);\n        }\n\n        return res.reshape(b.shape);\n      };\n\n      return {\n        a: derA,\n        b: derB\n      };\n    };\n\n    return environment_1.ENV.engine.runKernel(function (backend) {\n      return backend.atan2(a, b);\n    }, {\n      a: a,\n      b: b\n    }, der);\n  };\n\n  __decorate([doc_1.doc({\n    heading: 'Operations',\n    subheading: 'Arithmetic'\n  }), operation_1.operation], BinaryOps, \"add\", null);\n\n  __decorate([operation_1.operation], BinaryOps, \"addStrict\", null);\n\n  __decorate([doc_1.doc({\n    heading: 'Operations',\n    subheading: 'Arithmetic'\n  }), operation_1.operation], BinaryOps, \"sub\", null);\n\n  __decorate([operation_1.operation], BinaryOps, \"subStrict\", null);\n\n  __decorate([doc_1.doc({\n    heading: 'Operations',\n    subheading: 'Arithmetic'\n  }), operation_1.operation], BinaryOps, \"pow\", null);\n\n  __decorate([operation_1.operation], BinaryOps, \"powStrict\", null);\n\n  __decorate([doc_1.doc({\n    heading: 'Operations',\n    subheading: 'Arithmetic'\n  }), operation_1.operation], BinaryOps, \"mul\", null);\n\n  __decorate([operation_1.operation], BinaryOps, \"mulStrict\", null);\n\n  __decorate([doc_1.doc({\n    heading: 'Operations',\n    subheading: 'Arithmetic'\n  }), operation_1.operation], BinaryOps, \"div\", null);\n\n  __decorate([operation_1.operation], BinaryOps, \"divStrict\", null);\n\n  __decorate([doc_1.doc({\n    heading: 'Operations',\n    subheading: 'Arithmetic'\n  }), operation_1.operation], BinaryOps, \"mod\", null);\n\n  __decorate([operation_1.operation], BinaryOps, \"modStrict\", null);\n\n  __decorate([doc_1.doc({\n    heading: 'Operations',\n    subheading: 'Arithmetic'\n  }), operation_1.operation], BinaryOps, \"minimum\", null);\n\n  __decorate([operation_1.operation], BinaryOps, \"minimumStrict\", null);\n\n  __decorate([doc_1.doc({\n    heading: 'Operations',\n    subheading: 'Arithmetic'\n  }), operation_1.operation], BinaryOps, \"maximum\", null);\n\n  __decorate([operation_1.operation], BinaryOps, \"maximumStrict\", null);\n\n  __decorate([doc_1.doc({\n    heading: 'Operations',\n    subheading: 'Arithmetic'\n  }), operation_1.operation], BinaryOps, \"squaredDifference\", null);\n\n  __decorate([operation_1.operation], BinaryOps, \"squaredDifferenceStrict\", null);\n\n  __decorate([operation_1.operation], BinaryOps, \"atan2\", null);\n\n  return BinaryOps;\n}();\n\nexports.BinaryOps = BinaryOps;","map":null,"metadata":{},"sourceType":"script"}