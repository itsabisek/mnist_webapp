{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) {\n      if (b.hasOwnProperty(p)) d[p] = b[p];\n    }\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar environment_1 = require(\"../environment\");\n\nvar globals_1 = require(\"../globals\");\n\nvar ops_1 = require(\"../ops/ops\");\n\nvar optimizer_1 = require(\"./optimizer\");\n\nvar AdamOptimizer = function (_super) {\n  __extends(AdamOptimizer, _super);\n\n  function AdamOptimizer(learningRate, beta1, beta2, epsilon) {\n    if (epsilon === void 0) {\n      epsilon = 1e-8;\n    }\n\n    var _this = _super.call(this) || this;\n\n    _this.learningRate = learningRate;\n    _this.accumulatedFirstMoment = {};\n    _this.accumulatedSecondMoment = {};\n    _this.c = globals_1.keep(ops_1.scalar(-learningRate));\n    _this.eps = globals_1.keep(ops_1.scalar(epsilon));\n    _this.beta1 = globals_1.keep(ops_1.scalar(beta1));\n    _this.beta2 = globals_1.keep(ops_1.scalar(beta2));\n    globals_1.tidy(function () {\n      _this.accBeta1 = ops_1.scalar(beta1).variable();\n      _this.accBeta2 = ops_1.scalar(beta2).variable();\n    });\n    _this.oneMinusBeta1 = globals_1.keep(ops_1.scalar(1 - beta1));\n    _this.oneMinusBeta2 = globals_1.keep(ops_1.scalar(1 - beta2));\n    _this.one = globals_1.keep(ops_1.scalar(1));\n    return _this;\n  }\n\n  AdamOptimizer.prototype.applyGradients = function (variableGradients) {\n    var _this = this;\n\n    globals_1.tidy(function () {\n      var oneMinusAccBeta1 = _this.one.sub(_this.accBeta1);\n\n      var oneMinusAccBeta2 = _this.one.sub(_this.accBeta2);\n\n      for (var variableName in variableGradients) {\n        var value = environment_1.ENV.engine.registeredVariables[variableName];\n\n        if (_this.accumulatedFirstMoment[variableName] == null) {\n          var trainable = false;\n          _this.accumulatedFirstMoment[variableName] = ops_1.zerosLike(value).variable(trainable);\n        }\n\n        if (_this.accumulatedSecondMoment[variableName] == null) {\n          var trainable = false;\n          _this.accumulatedSecondMoment[variableName] = ops_1.zerosLike(value).variable(trainable);\n        }\n\n        var gradient = variableGradients[variableName];\n        var firstMoment = _this.accumulatedFirstMoment[variableName];\n        var secondMoment = _this.accumulatedSecondMoment[variableName];\n\n        var newFirstMoment = _this.beta1.mul(firstMoment).add(_this.oneMinusBeta1.mul(gradient));\n\n        var newSecondMoment = _this.beta2.mul(secondMoment).add(_this.oneMinusBeta2.mul(gradient.square()));\n\n        var biasCorrectedFirstMoment = newFirstMoment.div(oneMinusAccBeta1);\n        var biasCorrectedSecondMoment = newSecondMoment.div(oneMinusAccBeta2);\n\n        _this.accumulatedFirstMoment[variableName].assign(newFirstMoment);\n\n        _this.accumulatedSecondMoment[variableName].assign(newSecondMoment);\n\n        var newValue = _this.c.mul(biasCorrectedFirstMoment.div(_this.eps.add(biasCorrectedSecondMoment.sqrt()))).add(value);\n\n        value.assign(newValue);\n      }\n\n      _this.accBeta1.assign(_this.accBeta1.mul(_this.beta1));\n\n      _this.accBeta2.assign(_this.accBeta2.mul(_this.beta2));\n    });\n  };\n\n  AdamOptimizer.prototype.dispose = function () {\n    var _this = this;\n\n    this.c.dispose();\n    this.eps.dispose();\n    this.beta1.dispose();\n    this.beta2.dispose();\n    this.accBeta1.dispose();\n    this.accBeta2.dispose();\n    this.oneMinusBeta1.dispose();\n    this.oneMinusBeta2.dispose();\n    this.one.dispose();\n\n    if (this.accumulatedFirstMoment != null) {\n      Object.keys(this.accumulatedFirstMoment).forEach(function (name) {\n        return _this.accumulatedFirstMoment[name].dispose();\n      });\n    }\n\n    if (this.accumulatedSecondMoment != null) {\n      Object.keys(this.accumulatedSecondMoment).forEach(function (name) {\n        return _this.accumulatedSecondMoment[name].dispose();\n      });\n    }\n  };\n\n  return AdamOptimizer;\n}(optimizer_1.Optimizer);\n\nexports.AdamOptimizer = AdamOptimizer;","map":null,"metadata":{},"sourceType":"script"}