{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) {\n      if (b.hasOwnProperty(p)) d[p] = b[p];\n    }\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {\n    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  }\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar tfjs_core_1 = require(\"@tensorflow/tfjs-core\");\n\nvar K = require(\"./backend/tfjs_backend\");\n\nvar types_1 = require(\"./types\");\n\nvar generic_utils_1 = require(\"./utils/generic_utils\");\n\nfunction calcL2Norms(w, axis) {\n  return K.sqrt(K.sum(K.square(w), axis, true));\n}\n\nvar Constraint = function (_super) {\n  __extends(Constraint, _super);\n\n  function Constraint() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  Constraint.prototype.getConfig = function () {\n    return {};\n  };\n\n  Constraint = __decorate([tfjs_core_1.doc({\n    heading: 'Constraints',\n    subheading: 'Classes',\n    namespace: 'constraints'\n  })], Constraint);\n  return Constraint;\n}(types_1.Serializable);\n\nexports.Constraint = Constraint;\n\nvar MaxNorm = function (_super) {\n  __extends(MaxNorm, _super);\n\n  function MaxNorm(config) {\n    var _this = _super.call(this) || this;\n\n    _this.defaultMaxValue = 2;\n    _this.defaultAxis = 0;\n    _this.maxValue = config.maxValue != null ? config.maxValue : _this.defaultMaxValue;\n    _this.axis = config.axis != null ? config.axis : _this.defaultAxis;\n    return _this;\n  }\n\n  MaxNorm.prototype.apply = function (w) {\n    var norms = calcL2Norms(w, this.axis);\n    var desired = K.clip(norms, 0, this.maxValue);\n    return K.multiply(w, K.divide(desired, K.scalarPlusArray(K.getScalar(K.epsilon()), norms)));\n  };\n\n  MaxNorm.prototype.getClassName = function () {\n    return 'MaxNorm';\n  };\n\n  MaxNorm.prototype.getConfig = function () {\n    return {\n      maxValue: this.maxValue,\n      axis: this.axis\n    };\n  };\n\n  return MaxNorm;\n}(Constraint);\n\nexports.MaxNorm = MaxNorm;\ngeneric_utils_1.ClassNameMap.register('MaxNorm', MaxNorm);\n\nvar UnitNorm = function (_super) {\n  __extends(UnitNorm, _super);\n\n  function UnitNorm(config) {\n    var _this = _super.call(this) || this;\n\n    _this.defaultAxis = 0;\n    _this.axis = config.axis != null ? config.axis : _this.defaultAxis;\n    return _this;\n  }\n\n  UnitNorm.prototype.apply = function (w) {\n    return K.divide(w, K.scalarPlusArray(K.getScalar(K.epsilon()), calcL2Norms(w, this.axis)));\n  };\n\n  UnitNorm.prototype.getClassName = function () {\n    return 'UnitNorm';\n  };\n\n  UnitNorm.prototype.getConfig = function () {\n    return {\n      axis: this.axis\n    };\n  };\n\n  return UnitNorm;\n}(Constraint);\n\nexports.UnitNorm = UnitNorm;\ngeneric_utils_1.ClassNameMap.register('UnitNorm', UnitNorm);\n\nvar NonNeg = function (_super) {\n  __extends(NonNeg, _super);\n\n  function NonNeg() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  NonNeg.prototype.apply = function (w) {\n    return K.relu(w);\n  };\n\n  NonNeg.prototype.getClassName = function () {\n    return 'NonNeg';\n  };\n\n  return NonNeg;\n}(Constraint);\n\nexports.NonNeg = NonNeg;\ngeneric_utils_1.ClassNameMap.register('NonNeg', NonNeg);\n\nvar MinMaxNorm = function (_super) {\n  __extends(MinMaxNorm, _super);\n\n  function MinMaxNorm(config) {\n    var _this = _super.call(this) || this;\n\n    _this.defaultMinValue = 0.0;\n    _this.defaultMaxValue = 1.0;\n    _this.defaultRate = 1.0;\n    _this.defaultAxis = 0;\n    _this.minValue = config.minValue != null ? config.minValue : _this.defaultMinValue;\n    _this.maxValue = config.maxValue != null ? config.maxValue : _this.defaultMaxValue;\n    _this.rate = config.rate != null ? config.rate : _this.defaultRate;\n    _this.axis = config.axis != null ? config.axis : _this.defaultAxis;\n    return _this;\n  }\n\n  MinMaxNorm.prototype.apply = function (w) {\n    var norms = calcL2Norms(w, this.axis);\n    var desired = K.add(K.scalarTimesArray(K.getScalar(this.rate), K.clip(norms, this.minValue, this.maxValue)), K.scalarTimesArray(K.getScalar(1.0 - this.rate), norms));\n    return K.multiply(w, K.divide(desired, K.scalarPlusArray(K.getScalar(K.epsilon()), norms)));\n  };\n\n  MinMaxNorm.prototype.getClassName = function () {\n    return 'MinMaxNorm';\n  };\n\n  MinMaxNorm.prototype.getConfig = function () {\n    return {\n      minValue: this.minValue,\n      maxValue: this.maxValue,\n      rate: this.rate,\n      axis: this.axis\n    };\n  };\n\n  return MinMaxNorm;\n}(Constraint);\n\nexports.MinMaxNorm = MinMaxNorm;\ngeneric_utils_1.ClassNameMap.register('MinMaxNorm', MinMaxNorm);\nexports.CONSTRAINT_IDENTIFIER_REGISTRY_SYMBOL_MAP = {\n  'maxNorm': 'MaxNorm',\n  'minMaxNorm': 'MinMaxNorm',\n  'nonNeg': 'NonNeg',\n  'unitNorm': 'UnitNorm'\n};\n\nfunction serializeConstraint(constraint) {\n  return generic_utils_1.serializeKerasObject(constraint);\n}\n\nexports.serializeConstraint = serializeConstraint;\n\nfunction deserializeConstraint(config, customObjects) {\n  if (customObjects === void 0) {\n    customObjects = {};\n  }\n\n  return generic_utils_1.deserializeKerasObject(config, generic_utils_1.ClassNameMap.getMap().pythonClassNameMap, customObjects, 'constraint');\n}\n\nexports.deserializeConstraint = deserializeConstraint;\n\nfunction getConstraint(identifier) {\n  if (identifier == null) {\n    return null;\n  }\n\n  if (typeof identifier === 'string') {\n    var className = identifier in exports.CONSTRAINT_IDENTIFIER_REGISTRY_SYMBOL_MAP ? exports.CONSTRAINT_IDENTIFIER_REGISTRY_SYMBOL_MAP[identifier] : identifier;\n    var config = {\n      className: className,\n      config: {}\n    };\n    return deserializeConstraint(config);\n  } else if (identifier instanceof Constraint) {\n    return identifier;\n  } else {\n    return deserializeConstraint(identifier);\n  }\n}\n\nexports.getConstraint = getConstraint;","map":null,"metadata":{},"sourceType":"script"}