{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar util = require(\"../util\");\n\nfunction computePool2DInfo(inShape, filterSize, strides, pad, roundingMode, dataFormat) {\n  if (dataFormat === void 0) {\n    dataFormat = 'channelsLast';\n  }\n\n  var _a = parseTupleParam(filterSize),\n      filterHeight = _a[0],\n      filterWidth = _a[1];\n\n  var filterShape;\n\n  if (dataFormat === 'channelsLast') {\n    filterShape = [filterHeight, filterWidth, inShape[3], inShape[3]];\n  } else if (dataFormat === 'channelsFirst') {\n    filterShape = [filterHeight, filterWidth, inShape[1], inShape[1]];\n  } else {\n    throw new Error(\"Unknown dataFormat \" + dataFormat);\n  }\n\n  var dilations = 1;\n  return computeConv2DInfo(inShape, filterShape, strides, dilations, pad, roundingMode, false, dataFormat);\n}\n\nexports.computePool2DInfo = computePool2DInfo;\n\nfunction computeConv2DInfo(inShape, filterShape, strides, dilations, pad, roundingMode, depthwise, dataFormat) {\n  if (depthwise === void 0) {\n    depthwise = false;\n  }\n\n  if (dataFormat === void 0) {\n    dataFormat = 'channelsLast';\n  }\n\n  var _a = [-1, -1, -1, -1],\n      batchSize = _a[0],\n      inHeight = _a[1],\n      inWidth = _a[2],\n      inChannels = _a[3];\n\n  if (dataFormat === 'channelsLast') {\n    batchSize = inShape[0], inHeight = inShape[1], inWidth = inShape[2], inChannels = inShape[3];\n  } else if (dataFormat === 'channelsFirst') {\n    batchSize = inShape[0], inChannels = inShape[1], inHeight = inShape[2], inWidth = inShape[3];\n  } else {\n    throw new Error(\"Unknown dataFormat \" + dataFormat);\n  }\n\n  var filterHeight = filterShape[0],\n      filterWidth = filterShape[1],\n      filterChannels = filterShape[3];\n\n  var _b = parseTupleParam(strides),\n      strideHeight = _b[0],\n      strideWidth = _b[1];\n\n  var _c = parseTupleParam(dilations),\n      dilationHeight = _c[0],\n      dilationWidth = _c[1];\n\n  var effectiveFilterHeight = getEffectiveFilterSize(filterHeight, dilationHeight);\n  var effectiveFilterWidth = getEffectiveFilterSize(filterWidth, dilationWidth);\n\n  var _d = getPadAndOutInfo(pad, inHeight, inWidth, strideHeight, strideWidth, effectiveFilterHeight, effectiveFilterWidth, roundingMode),\n      padInfo = _d.padInfo,\n      outHeight = _d.outHeight,\n      outWidth = _d.outWidth;\n\n  var outChannels = depthwise ? filterChannels * inChannels : filterChannels;\n  var outShape;\n\n  if (dataFormat === 'channelsFirst') {\n    outShape = [batchSize, outChannels, outHeight, outWidth];\n  } else if (dataFormat === 'channelsLast') {\n    outShape = [batchSize, outHeight, outWidth, outChannels];\n  }\n\n  return {\n    batchSize: batchSize,\n    dataFormat: dataFormat,\n    inHeight: inHeight,\n    inWidth: inWidth,\n    inChannels: inChannels,\n    outHeight: outHeight,\n    outWidth: outWidth,\n    outChannels: outChannels,\n    padInfo: padInfo,\n    strideHeight: strideHeight,\n    strideWidth: strideWidth,\n    filterHeight: filterHeight,\n    filterWidth: filterWidth,\n    dilationHeight: dilationHeight,\n    dilationWidth: dilationWidth,\n    inShape: inShape,\n    outShape: outShape,\n    filterShape: filterShape\n  };\n}\n\nexports.computeConv2DInfo = computeConv2DInfo;\n\nfunction computeOutputShape3D(inShape, fieldSize, outDepth, stride, zeroPad, roundingMode) {\n  if (zeroPad == null) {\n    zeroPad = computeDefaultPad(inShape, fieldSize, stride);\n  }\n\n  var inputRows = inShape[0];\n  var inputCols = inShape[1];\n  var outputRows = conditionalRound((inputRows - fieldSize + 2 * zeroPad) / stride + 1, roundingMode);\n  util.assert(util.isInt(outputRows), \"The output # of rows (\" + outputRows + \") must be an integer. Change the \" + \"stride and/or zero pad parameters\");\n  var outputCols = conditionalRound((inputCols - fieldSize + 2 * zeroPad) / stride + 1, roundingMode);\n  util.assert(util.isInt(outputCols), \"The output # of columns (\" + outputCols + \") must be an integer. Change \" + \"the stride and/or zero pad parameters\");\n  return [outputRows, outputCols, outDepth];\n}\n\nfunction computeDefaultPad(inputShape, fieldSize, stride, dilation) {\n  if (dilation === void 0) {\n    dilation = 1;\n  }\n\n  var effectiveFieldSize = getEffectiveFilterSize(fieldSize, dilation);\n  return Math.floor((inputShape[0] * (stride - 1) - stride + effectiveFieldSize) / 2);\n}\n\nexports.computeDefaultPad = computeDefaultPad;\n\nfunction parseTupleParam(param) {\n  return typeof param === 'number' ? [param, param] : param;\n}\n\nfunction getEffectiveFilterSize(filterSize, dilation) {\n  if (dilation <= 1) {\n    return filterSize;\n  }\n\n  return filterSize + (filterSize - 1) * (dilation - 1);\n}\n\nfunction getPadAndOutInfo(pad, inHeight, inWidth, strideHeight, strideWidth, filterHeight, filterWidth, roundingMode) {\n  var padInfo;\n  var outHeight;\n  var outWidth;\n\n  if (typeof pad === 'number') {\n    var padType = pad === 0 ? 'VALID' : 'NUMBER';\n    padInfo = {\n      top: pad,\n      bottom: pad,\n      left: pad,\n      right: pad,\n      type: padType\n    };\n    var outShape = computeOutputShape3D([inHeight, inWidth, 1], filterHeight, 1, strideHeight, pad, roundingMode);\n    outHeight = outShape[0];\n    outWidth = outShape[1];\n  } else if (pad === 'same') {\n    outHeight = Math.ceil(inHeight / strideHeight);\n    outWidth = Math.ceil(inWidth / strideWidth);\n    var padAlongHeight = (outHeight - 1) * strideHeight + filterHeight - inHeight;\n    var padAlongWidth = (outWidth - 1) * strideWidth + filterWidth - inWidth;\n    var top_1 = Math.floor(padAlongHeight / 2);\n    var bottom = padAlongHeight - top_1;\n    var left = Math.floor(padAlongWidth / 2);\n    var right = padAlongWidth - left;\n    padInfo = {\n      top: top_1,\n      bottom: bottom,\n      left: left,\n      right: right,\n      type: 'SAME'\n    };\n  } else if (pad === 'valid') {\n    padInfo = {\n      top: 0,\n      bottom: 0,\n      left: 0,\n      right: 0,\n      type: 'VALID'\n    };\n    outHeight = Math.ceil((inHeight - filterHeight + 1) / strideHeight);\n    outWidth = Math.ceil((inWidth - filterWidth + 1) / strideWidth);\n  } else {\n    throw Error(\"Unknown padding parameter: \" + pad);\n  }\n\n  return {\n    padInfo: padInfo,\n    outHeight: outHeight,\n    outWidth: outWidth\n  };\n}\n\nfunction conditionalRound(value, roundingMode) {\n  if (!roundingMode) {\n    return value;\n  }\n\n  switch (roundingMode) {\n    case 'round':\n      return Math.round(value);\n\n    case 'ceil':\n      return Math.ceil(value);\n\n    case 'floor':\n      return Math.floor(value);\n\n    default:\n      throw new Error(\"Unknown roundingMode \" + roundingMode);\n  }\n}","map":null,"metadata":{},"sourceType":"script"}