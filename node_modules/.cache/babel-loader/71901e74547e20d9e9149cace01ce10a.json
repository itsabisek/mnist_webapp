{"ast":null,"code":"\"use strict\";\n\nvar __assign = this && this.__assign || Object.assign || function (t) {\n  for (var s, i = 1, n = arguments.length; i < n; i++) {\n    s = arguments[i];\n\n    for (var p in s) {\n      if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n  }\n\n  return t;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar errors_1 = require(\"../errors\");\n\nvar types_1 = require(\"../types\");\n\nfunction pyListRepeat(value, numValues) {\n  if (Array.isArray(value)) {\n    var newArray = [];\n\n    for (var i = 0; i < numValues; i++) {\n      newArray = newArray.concat(value);\n    }\n\n    return newArray;\n  } else {\n    var newArray = new Array(numValues);\n    newArray.fill(value);\n    return newArray;\n  }\n}\n\nexports.pyListRepeat = pyListRepeat;\n\nfunction pyGetAttr(obj, attrName, defaultValue) {\n  if (attrName in obj) {\n    return obj[attrName];\n  }\n\n  if (defaultValue === undefined) {\n    throw new errors_1.AttributeError('pyGetAttr: Attempting to get attribute ' + attrName + 'with no default value defined');\n  }\n\n  return defaultValue;\n}\n\nexports.pyGetAttr = pyGetAttr;\n\nfunction pyNormalizeArrayIndex(x, index) {\n  if (x == null || index == null) {\n    throw new errors_1.ValueError(\"Must provide a valid array and index for \" + (\"pyNormalizeArrayIndex(). Got array \" + x + \" and index \" + index + \".\"));\n  }\n\n  var errMsg = \"Index \" + index + \" out of range for array of length \" + x.length;\n\n  if (index < 0) {\n    if (index < -x.length) {\n      throw new errors_1.IndexError(errMsg);\n    }\n\n    return x.length + index;\n  }\n\n  if (index >= x.length) {\n    throw new errors_1.IndexError(errMsg);\n  }\n\n  return index;\n}\n\nexports.pyNormalizeArrayIndex = pyNormalizeArrayIndex;\n\nfunction assert(val, message) {\n  if (!val) {\n    throw new errors_1.AssertionError(message);\n  }\n}\n\nexports.assert = assert;\n\nfunction count(array, refernce) {\n  var counter = 0;\n\n  for (var _i = 0, array_1 = array; _i < array_1.length; _i++) {\n    var item = array_1[_i];\n\n    if (item === refernce) {\n      counter++;\n    }\n  }\n\n  return counter;\n}\n\nexports.count = count;\n\nvar ClassNameMap = function () {\n  function ClassNameMap() {\n    this.pythonClassNameMap = {};\n  }\n\n  ClassNameMap.getMap = function () {\n    if (ClassNameMap.instance == null) {\n      ClassNameMap.instance = new ClassNameMap();\n    }\n\n    return ClassNameMap.instance;\n  };\n\n  ClassNameMap.register = function (className, cls) {\n    this.getMap().pythonClassNameMap[className] = [cls, cls.fromConfig];\n  };\n\n  return ClassNameMap;\n}();\n\nexports.ClassNameMap = ClassNameMap;\n\nvar SerializableEnumRegistry = function () {\n  function SerializableEnumRegistry() {\n    this.enumRegistry = {};\n  }\n\n  SerializableEnumRegistry.getMap = function () {\n    if (SerializableEnumRegistry.instance == null) {\n      SerializableEnumRegistry.instance = new SerializableEnumRegistry();\n    }\n\n    return SerializableEnumRegistry.instance;\n  };\n\n  SerializableEnumRegistry.register = function (fieldName, enumCls) {\n    if (SerializableEnumRegistry.contains(fieldName)) {\n      throw new errors_1.ValueError(\"Attempting to register a repeated enum: \" + fieldName);\n    }\n\n    this.getMap().enumRegistry[fieldName] = enumCls;\n  };\n\n  SerializableEnumRegistry.contains = function (fieldName) {\n    return fieldName in this.getMap().enumRegistry;\n  };\n\n  SerializableEnumRegistry.lookup = function (fieldName, value) {\n    return this.getMap().enumRegistry[fieldName][value];\n  };\n\n  SerializableEnumRegistry.reverseLookup = function (fieldName, value) {\n    var enumMap = this.getMap().enumRegistry[fieldName];\n\n    for (var candidateString in enumMap) {\n      if (enumMap[candidateString] === value) {\n        return candidateString;\n      }\n    }\n\n    throw new errors_1.ValueError(\"Could not find serialization string for \" + value);\n  };\n\n  return SerializableEnumRegistry;\n}();\n\nexports.SerializableEnumRegistry = SerializableEnumRegistry;\n\nfunction singletonOrArray(xs) {\n  if (xs.length === 1) {\n    return xs[0];\n  }\n\n  return xs;\n}\n\nexports.singletonOrArray = singletonOrArray;\n\nfunction toList(x) {\n  if (Array.isArray(x)) {\n    return x;\n  }\n\n  return [x];\n}\n\nexports.toList = toList;\n\nfunction objectListUid(objs) {\n  var objectList = toList(objs);\n  var retVal = '';\n\n  for (var _i = 0, objectList_1 = objectList; _i < objectList_1.length; _i++) {\n    var obj = objectList_1[_i];\n\n    if (obj.id == null) {\n      throw new errors_1.ValueError(\"Object \" + obj + \" passed to objectListUid without an id\");\n    }\n\n    if (retVal !== '') {\n      retVal = retVal + ', ';\n    }\n\n    retVal = retVal + Math.abs(obj.id);\n  }\n\n  return retVal;\n}\n\nexports.objectListUid = objectListUid;\n\nfunction isArrayOfShapes(x) {\n  return Array.isArray(x) && Array.isArray(x[0]);\n}\n\nexports.isArrayOfShapes = isArrayOfShapes;\n\nfunction normalizeShapeList(x) {\n  if (x.length === 0) {\n    return [];\n  }\n\n  if (!Array.isArray(x[0])) {\n    return [x];\n  }\n\n  return x;\n}\n\nexports.normalizeShapeList = normalizeShapeList;\n\nfunction toSnakeCase(name) {\n  var intermediate = name.replace(/(.)([A-Z][a-z0-9]+)/g, '$1_$2');\n  var insecure = intermediate.replace(/([a-z])([A-Z])/g, '$1_$2').toLowerCase();\n\n  if (insecure[0] !== '_') {\n    return insecure;\n  }\n\n  return 'private' + insecure;\n}\n\nexports.toSnakeCase = toSnakeCase;\n\nfunction toCamelCase(identifier) {\n  if (identifier.length <= 1) {\n    return identifier;\n  }\n\n  if (identifier.indexOf('_') === -1) {\n    return identifier;\n  }\n\n  return identifier.replace(/[_]+(\\w|$)/g, function (m, p1) {\n    return p1.toUpperCase();\n  });\n}\n\nexports.toCamelCase = toCamelCase;\nvar _GLOBAL_CUSTOM_OBJECTS = {};\n\nfunction serializeKerasObject(instance) {\n  if (instance === null || instance === undefined) {\n    return null;\n  }\n\n  return {\n    className: instance.getClassName(),\n    config: instance.getConfig()\n  };\n}\n\nexports.serializeKerasObject = serializeKerasObject;\n\nfunction deserializeKerasObject(identifier, moduleObjects, customObjects, printableModuleName) {\n  if (moduleObjects === void 0) {\n    moduleObjects = {};\n  }\n\n  if (customObjects === void 0) {\n    customObjects = {};\n  }\n\n  if (printableModuleName === void 0) {\n    printableModuleName = 'object';\n  }\n\n  if (typeof identifier === 'string') {\n    var functionName = identifier;\n    var fn = void 0;\n\n    if (functionName in customObjects) {\n      fn = customObjects[functionName];\n    } else if (functionName in _GLOBAL_CUSTOM_OBJECTS) {\n      fn = _GLOBAL_CUSTOM_OBJECTS[functionName];\n    } else {\n      fn = moduleObjects[functionName];\n\n      if (fn == null) {\n        throw new errors_1.ValueError(\"Unknown \" + printableModuleName + \": \" + identifier);\n      }\n    }\n\n    return fn;\n  } else {\n    var config = identifier;\n\n    if (config.className == null || config.config == null) {\n      throw new errors_1.ValueError(printableModuleName + \": Improper config format: \" + (JSON.stringify(config) + \".\\n\") + \"'className' and 'config' must set.\");\n    }\n\n    var className = config.className;\n    var cls = void 0,\n        fromConfig = void 0;\n\n    if (className in customObjects) {\n      _a = customObjects.get(className), cls = _a[0], fromConfig = _a[1];\n    } else if (className in _GLOBAL_CUSTOM_OBJECTS) {\n      _b = _GLOBAL_CUSTOM_OBJECTS.className, cls = _b[0], fromConfig = _b[1];\n    } else if (className in moduleObjects) {\n      _c = moduleObjects[className], cls = _c[0], fromConfig = _c[1];\n    }\n\n    if (cls == null) {\n      throw new errors_1.ValueError(\"Unknown \" + printableModuleName + \": \" + className);\n    }\n\n    if (fromConfig != null) {\n      var customObjectsCombined = {};\n\n      for (var _i = 0, _d = Object.keys(_GLOBAL_CUSTOM_OBJECTS); _i < _d.length; _i++) {\n        var key = _d[_i];\n        customObjectsCombined[key] = _GLOBAL_CUSTOM_OBJECTS[key];\n      }\n\n      for (var _e = 0, _f = Object.keys(customObjects); _e < _f.length; _e++) {\n        var key = _f[_e];\n        customObjectsCombined[key] = customObjects[key];\n      }\n\n      var nestedConfig = config.config;\n      nestedConfig.customObjects = customObjectsCombined;\n\n      var backupCustomObjects = __assign({}, _GLOBAL_CUSTOM_OBJECTS);\n\n      for (var _g = 0, _h = Object.keys(customObjects); _g < _h.length; _g++) {\n        var key = _h[_g];\n        _GLOBAL_CUSTOM_OBJECTS[key] = customObjects[key];\n      }\n\n      var returnObj = fromConfig(cls, config.config);\n      _GLOBAL_CUSTOM_OBJECTS = __assign({}, backupCustomObjects);\n      return returnObj;\n    } else {\n      var backupCustomObjects = __assign({}, _GLOBAL_CUSTOM_OBJECTS);\n\n      for (var _j = 0, _k = Object.keys(customObjects); _j < _k.length; _j++) {\n        var key = _k[_j];\n        _GLOBAL_CUSTOM_OBJECTS[key] = customObjects[key];\n      }\n\n      var returnObj = new cls(config.config);\n      _GLOBAL_CUSTOM_OBJECTS = __assign({}, backupCustomObjects);\n      return returnObj;\n    }\n  }\n\n  var _a, _b, _c;\n}\n\nexports.deserializeKerasObject = deserializeKerasObject;\n\nfunction getExactlyOneTensor(xs) {\n  var x;\n\n  if (Array.isArray(xs)) {\n    if (xs.length !== 1) {\n      throw new errors_1.ValueError(\"Expected Tensor length to be 1; got \" + xs.length);\n    }\n\n    x = xs[0];\n  } else {\n    x = xs;\n  }\n\n  return x;\n}\n\nexports.getExactlyOneTensor = getExactlyOneTensor;\n\nfunction getExactlyOneShape(shapes) {\n  if (Array.isArray(shapes) && Array.isArray(shapes[0])) {\n    if (shapes.length === 1) {\n      shapes = shapes;\n      return shapes[0];\n    } else {\n      throw new errors_1.ValueError(\"Expected exactly 1 Shape; got \" + shapes.length);\n    }\n  } else {\n    return shapes;\n  }\n}\n\nexports.getExactlyOneShape = getExactlyOneShape;\n\nfunction numberCompare(a, b) {\n  return a < b ? -1 : a > b ? 1 : 0;\n}\n\nexports.numberCompare = numberCompare;\n\nfunction reverseNumberCompare(a, b) {\n  return -1 * numberCompare(a, b);\n}\n\nexports.reverseNumberCompare = reverseNumberCompare;\n\nfunction stringToDType(dtype) {\n  switch (dtype) {\n    case 'float32':\n      return types_1.DType.float32;\n\n    default:\n      throw new errors_1.ValueError(\"Invalid dtype: \" + dtype);\n  }\n}\n\nexports.stringToDType = stringToDType;\n\nfunction stringsEqual(xs, ys) {\n  if (xs == null || ys == null) {\n    return xs === ys;\n  }\n\n  if (xs.length !== ys.length) {\n    return false;\n  }\n\n  for (var i = 0; i < xs.length; ++i) {\n    if (xs[i] !== ys[i]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nexports.stringsEqual = stringsEqual;\n\nfunction unique(xs) {\n  if (xs == null) {\n    return xs;\n  }\n\n  var out = [];\n\n  for (var _i = 0, xs_1 = xs; _i < xs_1.length; _i++) {\n    var x = xs_1[_i];\n\n    if (out.indexOf(x) === -1) {\n      out.push(x);\n    }\n  }\n\n  return out;\n}\n\nexports.unique = unique;\n\nfunction isObjectEmpty(obj) {\n  if (obj == null) {\n    throw new errors_1.ValueError(\"Invalid value in obj: \" + JSON.stringify(obj));\n  }\n\n  for (var key in obj) {\n    if (obj.hasOwnProperty(key)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nexports.isObjectEmpty = isObjectEmpty;","map":null,"metadata":{},"sourceType":"script"}