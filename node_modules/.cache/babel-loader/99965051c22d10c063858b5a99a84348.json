{"ast":null,"code":"\"use strict\";\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {\n    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  }\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar doc_1 = require(\"../doc\");\n\nvar environment_1 = require(\"../environment\");\n\nvar util = require(\"../util\");\n\nvar operation_1 = require(\"./operation\");\n\nvar ops = require(\"./ops\");\n\nvar ops_1 = require(\"./ops\");\n\nvar selu_util = require(\"./selu_util\");\n\nvar UnaryOps = function () {\n  function UnaryOps() {}\n\n  UnaryOps.neg = function (x) {\n    util.assertArgumentsAreTensors({\n      x: x\n    }, 'neg');\n\n    var grad = function grad(dy) {\n      return {\n        x: function x() {\n          return dy.neg();\n        }\n      };\n    };\n\n    return environment_1.ENV.engine.runKernel(function (backend) {\n      return backend.neg(x);\n    }, {\n      x: x\n    }, grad);\n  };\n\n  UnaryOps.ceil = function (x) {\n    util.assertArgumentsAreTensors({\n      x: x\n    }, 'ceil');\n\n    var grad = function grad(dy) {\n      return {\n        x: function x() {\n          return ops.zerosLike(dy);\n        }\n      };\n    };\n\n    return environment_1.ENV.engine.runKernel(function (backend) {\n      return backend.ceil(x);\n    }, {\n      x: x\n    }, grad);\n  };\n\n  UnaryOps.floor = function (x) {\n    util.assertArgumentsAreTensors({\n      x: x\n    }, 'floor');\n\n    var grad = function grad(dy) {\n      return {\n        x: function x() {\n          return ops.zerosLike(dy);\n        }\n      };\n    };\n\n    return environment_1.ENV.engine.runKernel(function (backend) {\n      return backend.floor(x);\n    }, {\n      x: x\n    }, grad);\n  };\n\n  UnaryOps.sign = function (x) {\n    util.assertArgumentsAreTensors({\n      x: x\n    }, 'sign');\n\n    var grad = function grad(dy) {\n      return {\n        x: function x() {\n          return ops.zerosLike(dy);\n        }\n      };\n    };\n\n    return environment_1.ENV.engine.runKernel(function (backend) {\n      return backend.sign(x);\n    }, {\n      x: x\n    }, grad);\n  };\n\n  UnaryOps.round = function (x) {\n    util.assertArgumentsAreTensors({\n      x: x\n    }, 'round');\n\n    var grad = function grad(dy) {\n      return {\n        x: function x() {\n          return ops.zerosLike(dy);\n        }\n      };\n    };\n\n    return environment_1.ENV.engine.runKernel(function (backend) {\n      return backend.round(x);\n    }, {\n      x: x\n    }, grad);\n  };\n\n  UnaryOps.exp = function (x) {\n    util.assertArgumentsAreTensors({\n      x: x\n    }, 'exp');\n\n    var bck = function bck(dy, saved) {\n      var y = saved[0];\n      return {\n        x: function x() {\n          return dy.mulStrict(y);\n        }\n      };\n    };\n\n    return environment_1.ENV.engine.runKernel(function (backend, save) {\n      return save(backend.exp(x));\n    }, {\n      x: x\n    }, bck);\n  };\n\n  UnaryOps.expm1 = function (_x) {\n    util.assertArgumentsAreTensors({\n      x: _x\n    }, 'expm1');\n\n    var grad = function grad(dy) {\n      return {\n        x: function x() {\n          return dy.mulStrict(_x.exp());\n        }\n      };\n    };\n\n    return environment_1.ENV.engine.runKernel(function (backend) {\n      return backend.expm1(_x);\n    }, {\n      x: _x\n    }, grad);\n  };\n\n  UnaryOps.log = function (_x2) {\n    util.assertArgumentsAreTensors({\n      x: _x2\n    }, 'log');\n\n    var grad = function grad(dy) {\n      return {\n        x: function x() {\n          return dy.divStrict(_x2.toFloat());\n        }\n      };\n    };\n\n    return environment_1.ENV.engine.runKernel(function (backend) {\n      return backend.log(_x2);\n    }, {\n      x: _x2\n    }, grad);\n  };\n\n  UnaryOps.log1p = function (_x3) {\n    util.assertArgumentsAreTensors({\n      x: _x3\n    }, 'log1p');\n\n    var grad = function grad(dy) {\n      return {\n        x: function x() {\n          return dy.divStrict(_x3.add(ops.scalar(1)));\n        }\n      };\n    };\n\n    return environment_1.ENV.engine.runKernel(function (backend) {\n      return backend.log1p(_x3);\n    }, {\n      x: _x3\n    }, grad);\n  };\n\n  UnaryOps.sqrt = function (_x4) {\n    util.assertArgumentsAreTensors({\n      x: _x4\n    }, 'sqrt');\n\n    var grad = function grad(dy) {\n      return {\n        x: function x() {\n          return dy.divStrict(_x4.toFloat().sqrt().mul(ops.scalar(2)));\n        }\n      };\n    };\n\n    return environment_1.ENV.engine.runKernel(function (backend) {\n      return backend.sqrt(_x4);\n    }, {\n      x: _x4\n    }, grad);\n  };\n\n  UnaryOps.rsqrt = function (_x5) {\n    util.assertArgumentsAreTensors({\n      x: _x5\n    }, 'rsqrt');\n\n    var grad = function grad(dy) {\n      return {\n        x: function x() {\n          return dy.divStrict(_x5.pow(ops.scalar(1.5)).mul(ops.scalar(2))).neg();\n        }\n      };\n    };\n\n    return environment_1.ENV.engine.runKernel(function (backend) {\n      return backend.rsqrt(_x5);\n    }, {\n      x: _x5\n    }, grad);\n  };\n\n  UnaryOps.square = function (_x6) {\n    util.assertArgumentsAreTensors({\n      x: _x6\n    }, 'square');\n\n    var grad = function grad(dy) {\n      return {\n        x: function x() {\n          return dy.mulStrict(_x6.toFloat().mul(ops.scalar(2)));\n        }\n      };\n    };\n\n    return environment_1.ENV.engine.runKernel(function (backend) {\n      return backend.square(_x6);\n    }, {\n      x: _x6\n    }, grad);\n  };\n\n  UnaryOps.reciprocal = function (_x7) {\n    util.assertArgumentsAreTensors({\n      x: _x7\n    }, 'reciprocal');\n\n    var grad = function grad(dy) {\n      return {\n        x: function x() {\n          return dy.divStrict(_x7.square().neg());\n        }\n      };\n    };\n\n    return environment_1.ENV.engine.runKernel(function (backend) {\n      return backend.reciprocal(_x7);\n    }, {\n      x: _x7\n    }, grad);\n  };\n\n  UnaryOps.abs = function (_x8) {\n    util.assertArgumentsAreTensors({\n      x: _x8\n    }, 'abs');\n\n    var grad = function grad(dy) {\n      return {\n        x: function x() {\n          return dy.mulStrict(_x8.toFloat().step(-1));\n        }\n      };\n    };\n\n    return environment_1.ENV.engine.runKernel(function (backend) {\n      return backend.abs(_x8);\n    }, {\n      x: _x8\n    }, grad);\n  };\n\n  UnaryOps.clipByValue = function (_x9, clipValueMin, clipValueMax) {\n    util.assertArgumentsAreTensors({\n      x: _x9\n    }, 'clipByValue');\n    util.assert(clipValueMin <= clipValueMax, \"Error in clip: min (\" + clipValueMin + \") must be \" + (\"less than or equal to max (\" + clipValueMax + \").\"));\n\n    var grad = function grad(dy) {\n      return {\n        x: function x() {\n          return dy.where(_x9.greater(ops.scalar(clipValueMin)).logicalAnd(_x9.less(ops.scalar(clipValueMax))), ops_1.zerosLike(dy));\n        }\n      };\n    };\n\n    return environment_1.ENV.engine.runKernel(function (backend) {\n      return backend.clip(_x9, clipValueMin, clipValueMax);\n    }, {\n      x: _x9\n    }, grad);\n  };\n\n  UnaryOps.relu = function (x) {\n    util.assertArgumentsAreTensors({\n      x: x\n    }, 'relu');\n\n    if (x.dtype === 'bool') {\n      return x.toInt();\n    }\n\n    var grad = function grad(dy) {\n      var stepRes = x.step();\n      return {\n        x: function x() {\n          return dy.mulStrict(stepRes.toFloat());\n        }\n      };\n    };\n\n    return environment_1.ENV.engine.runKernel(function (backend) {\n      return backend.relu(x);\n    }, {\n      x: x\n    }, grad);\n  };\n\n  UnaryOps.elu = function (x) {\n    util.assertArgumentsAreTensors({\n      x: x\n    }, 'elu');\n\n    var grad = function grad(dy, saved) {\n      var y = saved[0];\n      return {\n        x: function x() {\n          return environment_1.ENV.engine.runKernel(function (backend) {\n            return backend.eluDer(dy, y);\n          }, {\n            dy: dy,\n            y: y\n          });\n        }\n      };\n    };\n\n    return environment_1.ENV.engine.runKernel(function (backend, save) {\n      return save(backend.elu(x));\n    }, {\n      x: x\n    }, grad);\n  };\n\n  UnaryOps.selu = function (_x10) {\n    util.assertArgumentsAreTensors({\n      x: _x10\n    }, 'selu');\n\n    var grad = function grad(dy) {\n      return {\n        x: function x() {\n          var mask = _x10.greater(ops.scalar(0));\n\n          var scaleAlpha = ops.scalar(selu_util.SELU_SCALEALPHA);\n          var scale = ops.scalar(selu_util.SELU_SCALE);\n          var greaterThanZeroDer = dy.mul(scale);\n          var lessEqualZeroDer = dy.mul(scaleAlpha).mul(_x10.toFloat().exp());\n          return ops.where(mask, greaterThanZeroDer, lessEqualZeroDer);\n        }\n      };\n    };\n\n    return environment_1.ENV.engine.runKernel(function (backend) {\n      return backend.selu(_x10);\n    }, {\n      x: _x10\n    }, grad);\n  };\n\n  UnaryOps.leakyRelu = function (x, alpha) {\n    if (alpha === void 0) {\n      alpha = 0.2;\n    }\n\n    util.assertArgumentsAreTensors({\n      x: x\n    }, 'leakyRelu');\n    return ops.maximum(ops.scalar(alpha).mul(x), x);\n  };\n\n  UnaryOps.prelu = function (x, alpha) {\n    util.assertArgumentsAreTensors({\n      x: x,\n      alpha: alpha\n    }, 'prelu');\n    var zero = ops.scalar(0);\n    return ops.maximum(zero, x).add(alpha.mul(ops.minimum(zero, x)));\n  };\n\n  UnaryOps.sigmoid = function (x) {\n    util.assertArgumentsAreTensors({\n      x: x\n    }, 'sigmoid');\n\n    var grad = function grad(dy, saved) {\n      var y = saved[0];\n      return {\n        x: function x() {\n          return dy.mulStrict(y.mul(ops.scalar(1).sub(y)));\n        }\n      };\n    };\n\n    return environment_1.ENV.engine.runKernel(function (backend, save) {\n      return save(backend.sigmoid(x));\n    }, {\n      x: x\n    }, grad);\n  };\n\n  UnaryOps.logSigmoid = function (_x11) {\n    util.assertArgumentsAreTensors({\n      x: _x11\n    }, 'logSigmoid');\n\n    var grad = function grad(dy) {\n      return {\n        x: function x() {\n          return dy.mulStrict(_x11.neg().sigmoid());\n        }\n      };\n    };\n\n    return environment_1.ENV.engine.runKernel(function (backend) {\n      return backend.softplus(_x11.neg()).neg();\n    }, {\n      x: _x11\n    }, grad);\n  };\n\n  UnaryOps.softplus = function (_x12) {\n    util.assertArgumentsAreTensors({\n      x: _x12\n    }, 'softplus');\n\n    var grad = function grad(dy) {\n      return {\n        x: function x() {\n          return dy.mulStrict(_x12.sigmoid());\n        }\n      };\n    };\n\n    return environment_1.ENV.engine.runKernel(function (backend) {\n      return backend.softplus(_x12);\n    }, {\n      x: _x12\n    }, grad);\n  };\n\n  UnaryOps.sin = function (_x13) {\n    util.assertArgumentsAreTensors({\n      x: _x13\n    }, 'sin');\n\n    var grad = function grad(dy) {\n      return {\n        x: function x() {\n          return _x13.toFloat().cos().mulStrict(dy);\n        }\n      };\n    };\n\n    return environment_1.ENV.engine.runKernel(function (backend) {\n      return backend.sin(_x13);\n    }, {\n      x: _x13\n    }, grad);\n  };\n\n  UnaryOps.cos = function (_x14) {\n    util.assertArgumentsAreTensors({\n      x: _x14\n    }, 'cos');\n\n    var grad = function grad(dy) {\n      return {\n        x: function x() {\n          return _x14.toFloat().sin().neg().mulStrict(dy);\n        }\n      };\n    };\n\n    return environment_1.ENV.engine.runKernel(function (backend) {\n      return backend.cos(_x14);\n    }, {\n      x: _x14\n    }, grad);\n  };\n\n  UnaryOps.tan = function (_x15) {\n    util.assertArgumentsAreTensors({\n      x: _x15\n    }, 'tan');\n\n    var grad = function grad(dy) {\n      return {\n        x: function x() {\n          return dy.divStrict(_x15.cos().square());\n        }\n      };\n    };\n\n    return environment_1.ENV.engine.runKernel(function (backend) {\n      return backend.tan(_x15);\n    }, {\n      x: _x15\n    }, grad);\n  };\n\n  UnaryOps.asin = function (_x16) {\n    util.assertArgumentsAreTensors({\n      x: _x16\n    }, 'asin');\n\n    var grad = function grad(dy) {\n      return {\n        x: function x() {\n          return dy.divStrict(UnaryOps.sqrt(ops.scalar(1).sub(_x16.toFloat().square())));\n        }\n      };\n    };\n\n    return environment_1.ENV.engine.runKernel(function (backend) {\n      return backend.asin(_x16);\n    }, {\n      x: _x16\n    }, grad);\n  };\n\n  UnaryOps.acos = function (_x17) {\n    util.assertArgumentsAreTensors({\n      x: _x17\n    }, 'acos');\n\n    var grad = function grad(dy) {\n      return {\n        x: function x() {\n          return dy.divStrict(UnaryOps.sqrt(ops.scalar(1).sub(_x17.toFloat().square()))).neg();\n        }\n      };\n    };\n\n    return environment_1.ENV.engine.runKernel(function (backend) {\n      return backend.acos(_x17);\n    }, {\n      x: _x17\n    }, grad);\n  };\n\n  UnaryOps.atan = function (_x18) {\n    util.assertArgumentsAreTensors({\n      x: _x18\n    }, 'atan');\n\n    var grad = function grad(dy) {\n      return {\n        x: function x() {\n          return dy.divStrict(ops.scalar(1).add(_x18.toFloat().square()));\n        }\n      };\n    };\n\n    return environment_1.ENV.engine.runKernel(function (backend) {\n      return backend.atan(_x18);\n    }, {\n      x: _x18\n    }, grad);\n  };\n\n  UnaryOps.sinh = function (_x19) {\n    util.assertArgumentsAreTensors({\n      x: _x19\n    }, 'sinh');\n\n    var grad = function grad(dy) {\n      return {\n        x: function x() {\n          return _x19.toFloat().cosh().mulStrict(dy);\n        }\n      };\n    };\n\n    return environment_1.ENV.engine.runKernel(function (backend) {\n      return backend.sinh(_x19);\n    }, {\n      x: _x19\n    }, grad);\n  };\n\n  UnaryOps.cosh = function (_x20) {\n    util.assertArgumentsAreTensors({\n      x: _x20\n    }, 'cosh');\n\n    var grad = function grad(dy) {\n      return {\n        x: function x() {\n          return _x20.toFloat().sinh().mulStrict(dy);\n        }\n      };\n    };\n\n    return environment_1.ENV.engine.runKernel(function (backend) {\n      return backend.cosh(_x20);\n    }, {\n      x: _x20\n    }, grad);\n  };\n\n  UnaryOps.tanh = function (x) {\n    util.assertArgumentsAreTensors({\n      x: x\n    }, 'tanh');\n\n    var grad = function grad(dy, saved) {\n      var y = saved[0];\n      return {\n        x: function x() {\n          return ops.scalar(1).sub(y.square()).mulStrict(dy);\n        }\n      };\n    };\n\n    return environment_1.ENV.engine.runKernel(function (backend, save) {\n      return save(backend.tanh(x));\n    }, {\n      x: x\n    }, grad);\n  };\n\n  UnaryOps.asinh = function (_x21) {\n    util.assertArgumentsAreTensors({\n      x: _x21\n    }, 'asinh');\n\n    var grad = function grad(dy) {\n      return {\n        x: function x() {\n          return dy.divStrict(UnaryOps.sqrt(ops.scalar(1).add(_x21.toFloat().square())));\n        }\n      };\n    };\n\n    return environment_1.ENV.engine.runKernel(function (backend) {\n      return backend.asinh(_x21);\n    }, {\n      x: _x21\n    }, grad);\n  };\n\n  UnaryOps.acosh = function (_x22) {\n    util.assertArgumentsAreTensors({\n      x: _x22\n    }, 'acosh');\n\n    var grad = function grad(dy) {\n      return {\n        x: function x() {\n          return dy.divStrict(UnaryOps.sqrt(_x22.toFloat().square().sub(ops.scalar(1))));\n        }\n      };\n    };\n\n    return environment_1.ENV.engine.runKernel(function (backend) {\n      return backend.acosh(_x22);\n    }, {\n      x: _x22\n    }, grad);\n  };\n\n  UnaryOps.atanh = function (_x23) {\n    util.assertArgumentsAreTensors({\n      x: _x23\n    }, 'atanh');\n\n    var grad = function grad(dy) {\n      return {\n        x: function x() {\n          return dy.divStrict(ops.scalar(1).sub(_x23.toFloat().square()));\n        }\n      };\n    };\n\n    return environment_1.ENV.engine.runKernel(function (backend) {\n      return backend.atanh(_x23);\n    }, {\n      x: _x23\n    }, grad);\n  };\n\n  UnaryOps.erf = function (_x24) {\n    util.assert(_x24.dtype === 'int32' || _x24.dtype === 'float32', 'Input dtype must be `int32` or `float32`.');\n\n    if (_x24.dtype === 'int32') {\n      _x24 = _x24.toFloat();\n    }\n\n    var grad = function grad(dy) {\n      return {\n        x: function x() {\n          return dy.mulStrict(ops.scalar(2 / Math.sqrt(Math.PI)).mul(_x24.square().neg().exp()));\n        }\n      };\n    };\n\n    return environment_1.ENV.engine.runKernel(function (backend) {\n      return backend.erf(_x24);\n    }, {\n      x: _x24\n    }, grad);\n  };\n\n  UnaryOps.step = function (x, alpha) {\n    if (alpha === void 0) {\n      alpha = 0.0;\n    }\n\n    util.assertArgumentsAreTensors({\n      x: x\n    }, 'step');\n\n    var grad = function grad(dy) {\n      return {\n        x: function x() {\n          return ops.zerosLike(dy);\n        }\n      };\n    };\n\n    return environment_1.ENV.engine.runKernel(function (backend) {\n      return backend.step(x, alpha);\n    }, {\n      x: x\n    }, grad);\n  };\n\n  __decorate([doc_1.doc({\n    heading: 'Operations',\n    subheading: 'Basic math'\n  }), operation_1.operation], UnaryOps, \"neg\", null);\n\n  __decorate([doc_1.doc({\n    heading: 'Operations',\n    subheading: 'Basic math'\n  }), operation_1.operation], UnaryOps, \"ceil\", null);\n\n  __decorate([doc_1.doc({\n    heading: 'Operations',\n    subheading: 'Basic math'\n  }), operation_1.operation], UnaryOps, \"floor\", null);\n\n  __decorate([doc_1.doc({\n    heading: 'Operations',\n    subheading: 'Basic math'\n  }), operation_1.operation], UnaryOps, \"sign\", null);\n\n  __decorate([doc_1.doc({\n    heading: 'Operations',\n    subheading: 'Basic math'\n  }), operation_1.operation], UnaryOps, \"round\", null);\n\n  __decorate([doc_1.doc({\n    heading: 'Operations',\n    subheading: 'Basic math'\n  }), operation_1.operation], UnaryOps, \"exp\", null);\n\n  __decorate([doc_1.doc({\n    heading: 'Operations',\n    subheading: 'Basic math'\n  }), operation_1.operation], UnaryOps, \"expm1\", null);\n\n  __decorate([doc_1.doc({\n    heading: 'Operations',\n    subheading: 'Basic math'\n  }), operation_1.operation], UnaryOps, \"log\", null);\n\n  __decorate([doc_1.doc({\n    heading: 'Operations',\n    subheading: 'Basic math'\n  }), operation_1.operation], UnaryOps, \"log1p\", null);\n\n  __decorate([doc_1.doc({\n    heading: 'Operations',\n    subheading: 'Basic math'\n  }), operation_1.operation], UnaryOps, \"sqrt\", null);\n\n  __decorate([doc_1.doc({\n    heading: 'Operations',\n    subheading: 'Basic math'\n  }), operation_1.operation], UnaryOps, \"rsqrt\", null);\n\n  __decorate([doc_1.doc({\n    heading: 'Operations',\n    subheading: 'Basic math'\n  }), operation_1.operation], UnaryOps, \"square\", null);\n\n  __decorate([doc_1.doc({\n    heading: 'Operations',\n    subheading: 'Basic math'\n  }), operation_1.operation], UnaryOps, \"reciprocal\", null);\n\n  __decorate([doc_1.doc({\n    heading: 'Operations',\n    subheading: 'Basic math'\n  }), operation_1.operation], UnaryOps, \"abs\", null);\n\n  __decorate([doc_1.doc({\n    heading: 'Operations',\n    subheading: 'Basic math'\n  }), operation_1.operation], UnaryOps, \"clipByValue\", null);\n\n  __decorate([doc_1.doc({\n    heading: 'Operations',\n    subheading: 'Basic math'\n  }), operation_1.operation], UnaryOps, \"relu\", null);\n\n  __decorate([doc_1.doc({\n    heading: 'Operations',\n    subheading: 'Basic math'\n  }), operation_1.operation], UnaryOps, \"elu\", null);\n\n  __decorate([doc_1.doc({\n    heading: 'Operations',\n    subheading: 'Basic math'\n  }), operation_1.operation], UnaryOps, \"selu\", null);\n\n  __decorate([doc_1.doc({\n    heading: 'Operations',\n    subheading: 'Basic math'\n  }), operation_1.operation], UnaryOps, \"leakyRelu\", null);\n\n  __decorate([doc_1.doc({\n    heading: 'Operations',\n    subheading: 'Basic math'\n  }), operation_1.operation], UnaryOps, \"prelu\", null);\n\n  __decorate([doc_1.doc({\n    heading: 'Operations',\n    subheading: 'Basic math'\n  }), operation_1.operation], UnaryOps, \"sigmoid\", null);\n\n  __decorate([doc_1.doc({\n    heading: 'Operations',\n    subheading: 'Basic math'\n  }), operation_1.operation], UnaryOps, \"logSigmoid\", null);\n\n  __decorate([doc_1.doc({\n    heading: 'Operations',\n    subheading: 'Basic math'\n  }), operation_1.operation], UnaryOps, \"softplus\", null);\n\n  __decorate([doc_1.doc({\n    heading: 'Operations',\n    subheading: 'Basic math'\n  }), operation_1.operation], UnaryOps, \"sin\", null);\n\n  __decorate([doc_1.doc({\n    heading: 'Operations',\n    subheading: 'Basic math'\n  }), operation_1.operation], UnaryOps, \"cos\", null);\n\n  __decorate([doc_1.doc({\n    heading: 'Operations',\n    subheading: 'Basic math'\n  }), operation_1.operation], UnaryOps, \"tan\", null);\n\n  __decorate([doc_1.doc({\n    heading: 'Operations',\n    subheading: 'Basic math'\n  }), operation_1.operation], UnaryOps, \"asin\", null);\n\n  __decorate([doc_1.doc({\n    heading: 'Operations',\n    subheading: 'Basic math'\n  }), operation_1.operation], UnaryOps, \"acos\", null);\n\n  __decorate([doc_1.doc({\n    heading: 'Operations',\n    subheading: 'Basic math'\n  }), operation_1.operation], UnaryOps, \"atan\", null);\n\n  __decorate([doc_1.doc({\n    heading: 'Operations',\n    subheading: 'Basic math'\n  }), operation_1.operation], UnaryOps, \"sinh\", null);\n\n  __decorate([doc_1.doc({\n    heading: 'Operations',\n    subheading: 'Basic math'\n  }), operation_1.operation], UnaryOps, \"cosh\", null);\n\n  __decorate([doc_1.doc({\n    heading: 'Operations',\n    subheading: 'Basic math'\n  }), operation_1.operation], UnaryOps, \"tanh\", null);\n\n  __decorate([doc_1.doc({\n    heading: 'Operations',\n    subheading: 'Basic math'\n  }), operation_1.operation], UnaryOps, \"asinh\", null);\n\n  __decorate([doc_1.doc({\n    heading: 'Operations',\n    subheading: 'Basic math'\n  }), operation_1.operation], UnaryOps, \"acosh\", null);\n\n  __decorate([doc_1.doc({\n    heading: 'Operations',\n    subheading: 'Basic math'\n  }), operation_1.operation], UnaryOps, \"atanh\", null);\n\n  __decorate([doc_1.doc({\n    heading: 'Operations',\n    subheading: 'Basic math'\n  }), operation_1.operation], UnaryOps, \"erf\", null);\n\n  __decorate([doc_1.doc({\n    heading: 'Operations',\n    subheading: 'Basic math'\n  }), operation_1.operation], UnaryOps, \"step\", null);\n\n  return UnaryOps;\n}();\n\nexports.UnaryOps = UnaryOps;","map":null,"metadata":{},"sourceType":"script"}