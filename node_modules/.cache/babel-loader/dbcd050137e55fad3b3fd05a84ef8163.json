{"ast":null,"code":"\"use strict\";\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {\n    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  }\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar doc_1 = require(\"../doc\");\n\nvar environment_1 = require(\"../environment\");\n\nvar util = require(\"../util\");\n\nvar conv_util = require(\"./conv_util\");\n\nvar operation_1 = require(\"./operation\");\n\nvar PoolOps = function () {\n  function PoolOps() {}\n\n  PoolOps.maxPool = function (x, filterSize, strides, pad, dimRoundingMode) {\n    util.assertArgumentsAreTensors({\n      x: x\n    }, 'maxPool');\n    var x4D = x;\n    var reshapedTo4D = false;\n\n    if (x.rank === 3) {\n      reshapedTo4D = true;\n      x4D = x.as4D(1, x.shape[0], x.shape[1], x.shape[2]);\n    }\n\n    util.assert(x4D.rank === 4, \"Error in maxPool: input must be rank 4 but got rank \" + x4D.rank + \".\");\n\n    if (dimRoundingMode != null) {\n      util.assert(util.isInt(pad), \"Error in maxPool: pad must be an integer when using, \" + (\"dimRoundingMode \" + dimRoundingMode + \" but got pad \" + pad + \".\"));\n    }\n\n    var convInfo = conv_util.computePool2DInfo(x4D.shape, filterSize, strides, pad, dimRoundingMode);\n\n    var grad = function grad(dy, saved) {\n      var y4D = saved[0];\n      return {\n        x: function x() {\n          return PoolOps.maxPoolBackprop(dy, x4D, y4D, filterSize, strides, pad);\n        }\n      };\n    };\n\n    var res = environment_1.ENV.engine.runKernel(function (backend, save) {\n      return save(backend.maxPool(x4D, convInfo));\n    }, {\n      x: x4D\n    }, grad);\n\n    if (reshapedTo4D) {\n      return res.as3D(res.shape[1], res.shape[2], res.shape[3]);\n    }\n\n    return res;\n  };\n\n  PoolOps.maxPoolBackprop = function (dy, input, output, filterSize, strides, pad, dimRoundingMode) {\n    util.assertArgumentsAreTensors({\n      dy: dy,\n      input: input,\n      output: output\n    }, 'maxPoolBackprop');\n    util.assert(input.rank === dy.rank, \"Rank of input (\" + input.rank + \") does not match rank of dy (\" + dy.rank + \")\");\n    util.assert(dy.rank === 4, \"Error in maxPoolBackprop: dy must be rank 4 but got rank \" + (dy.rank + \".\"));\n    util.assert(input.rank === 4, \"Error in maxPoolBackprop: input must be rank 4 but got rank \" + (input.rank + \".\"));\n\n    if (dimRoundingMode != null) {\n      util.assert(util.isInt(pad), \"Error in maxPoolBackprop: pad must be an integer when using, \" + (\"dimRoundingMode \" + dimRoundingMode + \" but got pad \" + pad + \".\"));\n    }\n\n    var convInfo = conv_util.computePool2DInfo(input.shape, filterSize, strides, pad, dimRoundingMode);\n    var res = environment_1.ENV.engine.runKernel(function (backend) {\n      return backend.maxPoolBackprop(dy, input, output, convInfo);\n    }, {\n      dy: dy,\n      input: input\n    });\n    return res;\n  };\n\n  PoolOps.avgPool = function (x, filterSize, strides, pad, dimRoundingMode) {\n    util.assertArgumentsAreTensors({\n      x: x\n    }, 'avgPool');\n    util.assert(x.dtype === 'float32', 'The input dtype to avgPool must be float32');\n    var x4D = x;\n    var reshapedTo4D = false;\n\n    if (x.rank === 3) {\n      reshapedTo4D = true;\n      x4D = x.as4D(1, x.shape[0], x.shape[1], x.shape[2]);\n    }\n\n    util.assert(x4D.rank === 4, \"Error in avgPool: x must be rank 4 but got rank \" + x4D.rank + \".\");\n\n    if (dimRoundingMode != null) {\n      util.assert(util.isInt(pad), \"Error in avgPool: pad must be an integer when using, \" + (\"dimRoundingMode \" + dimRoundingMode + \" but got pad \" + pad + \".\"));\n    }\n\n    var convInfo = conv_util.computePool2DInfo(x4D.shape, filterSize, strides, pad);\n\n    var grad = function grad(dy) {\n      return {\n        x: function x() {\n          return PoolOps.avgPoolBackprop(dy, x4D, filterSize, strides, pad);\n        }\n      };\n    };\n\n    var res = environment_1.ENV.engine.runKernel(function (backend) {\n      return backend.avgPool(x4D, convInfo);\n    }, {\n      x: x4D\n    }, grad);\n    res = res.cast(x.dtype);\n\n    if (reshapedTo4D) {\n      return res.as3D(res.shape[1], res.shape[2], res.shape[3]);\n    }\n\n    return res;\n  };\n\n  PoolOps.avgPoolBackprop = function (dy, input, filterSize, strides, pad) {\n    util.assertArgumentsAreTensors({\n      dy: dy,\n      input: input\n    }, 'avgPoolBackprop');\n    util.assert(input.rank === dy.rank, \"Rank of input (\" + input.rank + \") does not match rank of dy (\" + dy.rank + \")\");\n    var input4D = input;\n    var dy4D = dy;\n    var reshapedTo4D = false;\n\n    if (input.rank === 3) {\n      reshapedTo4D = true;\n      input4D = input.as4D(1, input.shape[0], input.shape[1], input.shape[2]);\n      dy4D = dy.as4D(1, dy.shape[0], dy.shape[1], dy.shape[2]);\n    }\n\n    util.assert(dy4D.rank === 4, \"Error in avgPoolBackprop: dy must be rank 4 but got rank \" + (dy4D.rank + \".\"));\n    util.assert(input4D.rank === 4, \"Error in avgPoolBackprop: input must be rank 4 but got rank \" + (input4D.rank + \".\"));\n    var convInfo = conv_util.computePool2DInfo(input4D.shape, filterSize, strides, pad);\n    var res = environment_1.ENV.engine.runKernel(function (backend) {\n      return backend.avgPoolBackprop(dy4D, input4D, convInfo);\n    }, {\n      dy4D: dy4D,\n      input4D: input4D\n    });\n\n    if (reshapedTo4D) {\n      return res.as3D(res.shape[1], res.shape[2], res.shape[3]);\n    }\n\n    return res;\n  };\n\n  __decorate([doc_1.doc({\n    heading: 'Operations',\n    subheading: 'Convolution'\n  }), operation_1.operation], PoolOps, \"maxPool\", null);\n\n  __decorate([operation_1.operation], PoolOps, \"maxPoolBackprop\", null);\n\n  __decorate([doc_1.doc({\n    heading: 'Operations',\n    subheading: 'Convolution'\n  }), operation_1.operation], PoolOps, \"avgPool\", null);\n\n  __decorate([operation_1.operation], PoolOps, \"avgPoolBackprop\", null);\n\n  return PoolOps;\n}();\n\nexports.PoolOps = PoolOps;","map":null,"metadata":{},"sourceType":"script"}