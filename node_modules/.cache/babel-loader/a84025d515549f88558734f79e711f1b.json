{"ast":null,"code":"\"use strict\";\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {\n    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  }\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar doc_1 = require(\"../doc\");\n\nvar environment_1 = require(\"../environment\");\n\nvar globals_1 = require(\"../globals\");\n\nvar util = require(\"../util\");\n\nvar axis_util = require(\"./axis_util\");\n\nvar operation_1 = require(\"./operation\");\n\nvar ops = require(\"./ops\");\n\nvar ReductionOps = function () {\n  function ReductionOps() {}\n\n  ReductionOps.logSumExp = function (x, axis, keepDims) {\n    if (axis === void 0) {\n      axis = null;\n    }\n\n    if (keepDims === void 0) {\n      keepDims = false;\n    }\n\n    util.assertArgumentsAreTensors({\n      x: x\n    }, 'logSumExp');\n    var axes = axis_util.parseAxisParam(axis, x.shape);\n    var xMax = x.max(axes, true);\n    var a = x.sub(xMax);\n    var b = a.exp();\n    var c = b.sum(axes);\n    var d = c.log();\n    var res = xMax.reshape(d.shape).add(d);\n\n    if (keepDims) {\n      var newShape = axis_util.expandShapeToKeepDim(res.shape, axes);\n      return res.reshape(newShape);\n    }\n\n    return res;\n  };\n\n  ReductionOps.sum = function (x, axis, keepDims) {\n    if (axis === void 0) {\n      axis = null;\n    }\n\n    if (keepDims === void 0) {\n      keepDims = false;\n    }\n\n    util.assertArgumentsAreTensors({\n      x: x\n    }, 'sum');\n\n    if (x.dtype === 'bool') {\n      x = x.toInt();\n    }\n\n    var axes = axis_util.parseAxisParam(axis, x.shape);\n    var customOp = globals_1.customGrad(function (x) {\n      var permutation = axis_util.getAxesPermutation(axes, x.rank);\n      var reductionAxes = axes;\n      var permutedX = x;\n\n      if (permutation != null) {\n        permutedX = x.transpose(permutation);\n        reductionAxes = axis_util.getInnerMostAxes(reductionAxes.length, x.rank);\n      }\n\n      var value = environment_1.ENV.engine.runKernel(function (backend) {\n        return backend.sum(permutedX, reductionAxes);\n      }, {\n        permutedX: permutedX\n      });\n\n      if (keepDims) {\n        var newShape = axis_util.expandShapeToKeepDim(value.shape, axes);\n        value = value.reshape(newShape);\n      }\n\n      var gradFunc = function gradFunc(dy) {\n        var expandedDyShape = x.shape.slice();\n        axes.forEach(function (axis) {\n          expandedDyShape[axis] = 1;\n        });\n        var expandedDy = dy.reshape(expandedDyShape);\n        var derX = expandedDy.mul(ops.ones(x.shape, 'float32'));\n        return derX;\n      };\n\n      return {\n        value: value,\n        gradFunc: gradFunc\n      };\n    });\n    return customOp(x);\n  };\n\n  ReductionOps.mean = function (x, axis, keepDims) {\n    if (axis === void 0) {\n      axis = null;\n    }\n\n    if (keepDims === void 0) {\n      keepDims = false;\n    }\n\n    util.assertArgumentsAreTensors({\n      x: x\n    }, 'mean');\n    var axes = axis_util.parseAxisParam(axis, x.shape);\n    var shapes = axis_util.computeOutAndReduceShapes(x.shape, axes);\n    var reduceShape = shapes[1];\n    var reduceSize = util.sizeFromShape(reduceShape);\n    var customOp = globals_1.customGrad(function (x) {\n      var reduceSizeScalar = ops.scalar(reduceSize);\n      var xReduce = reduceSizeScalar.dtype === x.dtype ? x : x.cast(reduceSizeScalar.dtype);\n      var res = xReduce.div(reduceSizeScalar);\n      var value = res.sum(axis, keepDims);\n\n      var gradFunc = function gradFunc(dy) {\n        var expandedDyShape = x.shape.slice();\n        axes.forEach(function (axis) {\n          expandedDyShape[axis] = 1;\n        });\n        var expandedDy = dy.reshape(expandedDyShape);\n        var derX = expandedDy.mul(ops.ones(x.shape, 'float32')).div(reduceSizeScalar);\n        return derX;\n      };\n\n      return {\n        value: value,\n        gradFunc: gradFunc\n      };\n    });\n    return customOp(x);\n  };\n\n  ReductionOps.min = function (x, axis, keepDims) {\n    if (axis === void 0) {\n      axis = null;\n    }\n\n    if (keepDims === void 0) {\n      keepDims = false;\n    }\n\n    util.assertArgumentsAreTensors({\n      x: x\n    }, 'min');\n    var origAxes = axis_util.parseAxisParam(axis, x.shape);\n    var axes = origAxes;\n    var permutedAxes = axis_util.getAxesPermutation(axes, x.rank);\n\n    if (permutedAxes != null) {\n      x = x.transpose(permutedAxes);\n      axes = axis_util.getInnerMostAxes(axes.length, x.rank);\n    }\n\n    var res = environment_1.ENV.engine.runKernel(function (backend) {\n      return backend.min(x, axes);\n    }, {\n      x: x\n    });\n\n    if (keepDims) {\n      var newShape = axis_util.expandShapeToKeepDim(res.shape, origAxes);\n      return res.reshape(newShape);\n    }\n\n    return res;\n  };\n\n  ReductionOps.max = function (x, axis, keepDims) {\n    if (axis === void 0) {\n      axis = null;\n    }\n\n    if (keepDims === void 0) {\n      keepDims = false;\n    }\n\n    util.assertArgumentsAreTensors({\n      x: x\n    }, 'max');\n    var origAxes = axis_util.parseAxisParam(axis, x.shape);\n    var axes = origAxes;\n    var permutedAxes = axis_util.getAxesPermutation(axes, x.rank);\n\n    if (permutedAxes != null) {\n      x = x.transpose(permutedAxes);\n      axes = axis_util.getInnerMostAxes(axes.length, x.rank);\n    }\n\n    var res = environment_1.ENV.engine.runKernel(function (backend) {\n      return backend.max(x, axes);\n    }, {\n      x: x\n    });\n\n    if (keepDims) {\n      var newShape = axis_util.expandShapeToKeepDim(res.shape, origAxes);\n      return res.reshape(newShape);\n    }\n\n    return res;\n  };\n\n  ReductionOps.argMin = function (x, axis) {\n    if (axis === void 0) {\n      axis = 0;\n    }\n\n    util.assertArgumentsAreTensors({\n      x: x\n    }, 'argMin');\n\n    if (axis == null) {\n      axis = 0;\n    }\n\n    var axes = axis_util.parseAxisParam(axis, x.shape);\n    var permutedAxes = axis_util.getAxesPermutation(axes, x.rank);\n\n    if (permutedAxes != null) {\n      x = x.transpose(permutedAxes);\n      axes = axis_util.getInnerMostAxes(axes.length, x.rank);\n    }\n\n    return environment_1.ENV.engine.runKernel(function (backend) {\n      return backend.argMin(x, axes[0]);\n    }, {\n      x: x\n    });\n  };\n\n  ReductionOps.argMax = function (x, axis) {\n    if (axis === void 0) {\n      axis = 0;\n    }\n\n    util.assertArgumentsAreTensors({\n      x: x\n    }, 'argMax');\n\n    if (axis == null) {\n      axis = 0;\n    }\n\n    var axes = axis_util.parseAxisParam(axis, x.shape);\n    var permutedAxes = axis_util.getAxesPermutation(axes, x.rank);\n\n    if (permutedAxes != null) {\n      x = x.transpose(permutedAxes);\n      axes = axis_util.getInnerMostAxes(axes.length, x.rank);\n    }\n\n    return environment_1.ENV.engine.runKernel(function (backend) {\n      return backend.argMax(x, axes[0]);\n    }, {\n      x: x\n    });\n  };\n\n  ReductionOps.moments = function (x, axis, keepDims) {\n    if (axis === void 0) {\n      axis = null;\n    }\n\n    if (keepDims === void 0) {\n      keepDims = false;\n    }\n\n    util.assertArgumentsAreTensors({\n      x: x\n    }, 'moments');\n    var axes = axis_util.parseAxisParam(axis, x.shape);\n    var mean = x.mean(axes, keepDims);\n    var keepDimsShape = mean.shape;\n\n    if (!keepDims) {\n      keepDimsShape = axis_util.expandShapeToKeepDim(mean.shape, axes);\n    }\n\n    var devSquared = x.toFloat().sub(mean.reshape(keepDimsShape)).square();\n    var variance = devSquared.mean(axes, keepDims);\n    return {\n      mean: mean,\n      variance: variance\n    };\n  };\n\n  __decorate([doc_1.doc({\n    heading: 'Operations',\n    subheading: 'Reduction'\n  }), operation_1.operation], ReductionOps, \"logSumExp\", null);\n\n  __decorate([doc_1.doc({\n    heading: 'Operations',\n    subheading: 'Reduction'\n  }), operation_1.operation], ReductionOps, \"sum\", null);\n\n  __decorate([doc_1.doc({\n    heading: 'Operations',\n    subheading: 'Reduction'\n  }), operation_1.operation], ReductionOps, \"mean\", null);\n\n  __decorate([doc_1.doc({\n    heading: 'Operations',\n    subheading: 'Reduction'\n  }), operation_1.operation], ReductionOps, \"min\", null);\n\n  __decorate([doc_1.doc({\n    heading: 'Operations',\n    subheading: 'Reduction'\n  }), operation_1.operation], ReductionOps, \"max\", null);\n\n  __decorate([doc_1.doc({\n    heading: 'Operations',\n    subheading: 'Reduction'\n  }), operation_1.operation], ReductionOps, \"argMin\", null);\n\n  __decorate([doc_1.doc({\n    heading: 'Operations',\n    subheading: 'Reduction'\n  }), operation_1.operation], ReductionOps, \"argMax\", null);\n\n  __decorate([doc_1.doc({\n    heading: 'Operations',\n    subheading: 'Normalization'\n  }), operation_1.operation], ReductionOps, \"moments\", null);\n\n  return ReductionOps;\n}();\n\nexports.ReductionOps = ReductionOps;","map":null,"metadata":{},"sourceType":"script"}