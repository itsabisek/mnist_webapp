{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar ArgMinMaxProgram = function () {\n  function ArgMinMaxProgram(reduceInfo, op, firstPass) {\n    this.variableNames = ['A'];\n    var windowSize = reduceInfo.windowSize;\n    var batchSize = reduceInfo.batchSize;\n    var inSize = reduceInfo.inSize;\n    var outSize = Math.ceil(inSize / windowSize);\n\n    if (!firstPass) {\n      this.variableNames.push('bestIndicesA');\n    }\n\n    this.outputShape = [batchSize, outSize];\n    var compOp = op === 'max' ? '>' : '<';\n    var indexSnippet = firstPass ? 'inOffset + i;' : 'round(getBestIndicesA(batch, inOffset + i));';\n    this.userCode = \"\\n      void main() {\\n        ivec2 coords = getOutputCoords();\\n        int batch = coords[0];\\n        int outIdx = coords[1];\\n        int inOffset = outIdx * \" + windowSize + \";\\n\\n        int bestIndex = 0;\\n        float bestValue = getA(batch, inOffset);\\n\\n        for (int i = 0; i < \" + windowSize + \"; i++) {\\n          int inIdx = \" + indexSnippet + \";\\n          float candidate = getA(batch, inIdx);\\n          if (candidate \" + compOp + \" bestValue) {\\n            bestValue = candidate;\\n            bestIndex = inIdx;\\n          }\\n        }\\n        setOutput(float(bestIndex));\\n      }\\n    \";\n  }\n\n  return ArgMinMaxProgram;\n}();\n\nexports.ArgMinMaxProgram = ArgMinMaxProgram;","map":null,"metadata":{},"sourceType":"script"}