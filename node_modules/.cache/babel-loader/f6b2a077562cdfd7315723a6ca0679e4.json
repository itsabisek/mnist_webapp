{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) {\n      if (b.hasOwnProperty(p)) d[p] = b[p];\n    }\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar tfjs_core_1 = require(\"@tensorflow/tfjs-core\");\n\nvar activations_1 = require(\"../activations\");\n\nvar K = require(\"../backend/tfjs_backend\");\n\nvar constraints_1 = require(\"../constraints\");\n\nvar topology_1 = require(\"../engine/topology\");\n\nvar errors_1 = require(\"../errors\");\n\nvar initializers_1 = require(\"../initializers\");\n\nvar regularizers_1 = require(\"../regularizers\");\n\nvar generic_utils = require(\"../utils/generic_utils\");\n\nvar generic_utils_1 = require(\"../utils/generic_utils\");\n\nvar math_utils = require(\"../utils/math_utils\");\n\nvar Dropout = function (_super) {\n  __extends(Dropout, _super);\n\n  function Dropout(config) {\n    var _this = _super.call(this, config) || this;\n\n    _this.rate = Math.max(Math.min(config.rate, 1), 0);\n    _this.rateScalar = K.getScalar(_this.rate);\n    _this.noiseShape = config.noiseShape;\n    _this.seed = config.seed;\n\n    if (_this.seed != null) {\n      throw new errors_1.NotImplementedError('Non-default seed is not implemented in Dropout layer yet: ' + _this.seed);\n    }\n\n    _this.supportsMasking = true;\n    return _this;\n  }\n\n  Dropout.prototype.getNoiseShape = function (input) {\n    if (this.noiseShape == null) {\n      return this.noiseShape;\n    }\n\n    var inputShape = input.shape;\n    var noiseShape = [];\n\n    for (var i = 0; i < this.noiseShape.length; ++i) {\n      noiseShape.push(this.noiseShape[i] == null ? inputShape[i] : this.noiseShape[i]);\n    }\n\n    return noiseShape;\n  };\n\n  Dropout.prototype.call = function (inputs, kwargs) {\n    var _this = this;\n\n    this.invokeCallHook(inputs, kwargs);\n    var input = generic_utils.getExactlyOneTensor(inputs);\n\n    if (this.noiseShape != null && !tfjs_core_1.util.arraysEqual(input.shape, this.noiseShape)) {\n      throw new errors_1.NotImplementedError('Non-default noise shape is not implemented in Dropout layer yet: ' + JSON.stringify(this.noiseShape));\n    }\n\n    if (0 < this.rate && this.rate < 1) {\n      var training = kwargs['training'] == null ? false : kwargs['training'];\n      var noiseShape_1 = this.getNoiseShape(input);\n      var output = K.inTrainPhase(function () {\n        return K.dropout(input, _this.rateScalar, noiseShape_1, _this.seed);\n      }, function () {\n        return input;\n      }, training);\n      return output;\n    }\n\n    return inputs;\n  };\n\n  Dropout.prototype.getClassName = function () {\n    return 'Dropout';\n  };\n\n  Dropout.prototype.getConfig = function () {\n    var config = {\n      rate: this.rate,\n      noiseShape: this.noiseShape,\n      seed: this.seed\n    };\n\n    var baseConfig = _super.prototype.getConfig.call(this);\n\n    Object.assign(config, baseConfig);\n    return config;\n  };\n\n  return Dropout;\n}(topology_1.Layer);\n\nexports.Dropout = Dropout;\ngeneric_utils.ClassNameMap.register('Dropout', Dropout);\n\nvar Dense = function (_super) {\n  __extends(Dense, _super);\n\n  function Dense(config) {\n    var _this = _super.call(this, config) || this;\n\n    _this.activation = null;\n    _this.useBias = true;\n    _this.kernel = null;\n    _this.bias = null;\n    _this.DEFAULT_KERNEL_INITIALIZER = 'glorotNormal';\n    _this.DEFAULT_BIAS_INITIALIZER = 'zeros';\n\n    if (config.batchInputShape == null && config.inputShape == null && config.inputDim != null) {\n      var batchSize = null;\n\n      if (config.batchSize != null) {\n        batchSize = config.batchSize;\n      }\n\n      _this.batchInputShape = [batchSize, config.inputDim];\n    }\n\n    _this.units = config.units;\n    _this.activation = activations_1.getActivation(config.activation);\n\n    if (config.useBias != null) {\n      _this.useBias = config.useBias;\n    }\n\n    _this.kernelInitializer = initializers_1.getInitializer(config.kernelInitializer || _this.DEFAULT_KERNEL_INITIALIZER);\n    _this.biasInitializer = initializers_1.getInitializer(config.biasInitializer || _this.DEFAULT_BIAS_INITIALIZER);\n    _this.kernelConstraint = constraints_1.getConstraint(config.kernelConstraint);\n    _this.biasConstraint = constraints_1.getConstraint(config.biasConstraint);\n    _this.kernelRegularizer = regularizers_1.getRegularizer(config.kernelRegularizer);\n    _this.biasRegularizer = regularizers_1.getRegularizer(config.biasRegularizer);\n    _this.activityRegularizer = regularizers_1.getRegularizer(config.activityRegularizer);\n    _this.inputSpec = [{\n      minNDim: 2\n    }];\n    return _this;\n  }\n\n  Dense.prototype.build = function (inputShape) {\n    inputShape = generic_utils.getExactlyOneShape(inputShape);\n    var inputLastDim = inputShape[inputShape.length - 1];\n\n    if (this.kernel == null) {\n      this.kernel = this.addWeight('kernel', [inputLastDim, this.units], null, this.kernelInitializer, this.kernelRegularizer, true, this.kernelConstraint);\n\n      if (this.useBias) {\n        this.bias = this.addWeight('bias', [this.units], null, this.biasInitializer, this.biasRegularizer, true, this.biasConstraint);\n      }\n    }\n\n    this.inputSpec = [{\n      minNDim: 2,\n      axes: (_a = {}, _a[-1] = inputLastDim, _a)\n    }];\n    this.built = true;\n\n    var _a;\n  };\n\n  Dense.prototype.computeOutputShape = function (inputShape) {\n    inputShape = generic_utils.getExactlyOneShape(inputShape);\n    var outputShape = inputShape.slice();\n    outputShape[outputShape.length - 1] = this.units;\n    return outputShape;\n  };\n\n  Dense.prototype.call = function (inputs, kwargs) {\n    this.invokeCallHook(inputs, kwargs);\n    var input = generic_utils.getExactlyOneTensor(inputs);\n    var output = K.dot(input, this.kernel.read());\n\n    if (this.bias != null) {\n      output = K.biasAdd(output, this.bias.read());\n    }\n\n    if (this.activation != null) {\n      output = this.activation(output);\n    }\n\n    return output;\n  };\n\n  Dense.prototype.getClassName = function () {\n    return 'Dense';\n  };\n\n  Dense.prototype.getConfig = function () {\n    var config = {\n      units: this.units,\n      activation: activations_1.serializeActivation(this.activation),\n      useBias: this.useBias,\n      kernelInitializer: initializers_1.serializeInitializer(this.kernelInitializer),\n      biasInitializer: initializers_1.serializeInitializer(this.biasInitializer),\n      kernelRegularizer: regularizers_1.serializeRegularizer(this.kernelRegularizer),\n      biasRegularizer: regularizers_1.serializeRegularizer(this.biasRegularizer),\n      activityRegularizer: regularizers_1.serializeRegularizer(this.activityRegularizer),\n      kernelConstraint: constraints_1.serializeConstraint(this.kernelConstraint),\n      biasConstraint: constraints_1.serializeConstraint(this.biasConstraint)\n    };\n\n    var baseConfig = _super.prototype.getConfig.call(this);\n\n    Object.assign(config, baseConfig);\n    return config;\n  };\n\n  return Dense;\n}(topology_1.Layer);\n\nexports.Dense = Dense;\ngeneric_utils.ClassNameMap.register('Dense', Dense);\n\nvar Flatten = function (_super) {\n  __extends(Flatten, _super);\n\n  function Flatten(config) {\n    var _this = _super.call(this, config || {}) || this;\n\n    _this.inputSpec = [{\n      minNDim: 3\n    }];\n    return _this;\n  }\n\n  Flatten.prototype.computeOutputShape = function (inputShape) {\n    inputShape = generic_utils.getExactlyOneShape(inputShape);\n\n    for (var _i = 0, _a = inputShape.slice(1); _i < _a.length; _i++) {\n      var dim = _a[_i];\n\n      if (dim == null) {\n        throw new errors_1.ValueError(\"The shape of the input to \\\"Flatten\\\" is not fully defined \" + (\"(got \" + inputShape.slice(1) + \"). Make sure to pass a complete \") + \"\\\"input_shape\\\" or \\\"batch_input_shape\\\" argument to the first \" + \"layer in your model.\");\n      }\n    }\n\n    return [inputShape[0], math_utils.arrayProd(inputShape, 1)];\n  };\n\n  Flatten.prototype.getClassName = function () {\n    return 'Flatten';\n  };\n\n  Flatten.prototype.call = function (inputs, kwargs) {\n    this.invokeCallHook(inputs, kwargs);\n    return K.batchFlatten(generic_utils.getExactlyOneTensor(inputs));\n  };\n\n  return Flatten;\n}(topology_1.Layer);\n\nexports.Flatten = Flatten;\ngeneric_utils.ClassNameMap.register('Flatten', Flatten);\n\nvar Activation = function (_super) {\n  __extends(Activation, _super);\n\n  function Activation(config) {\n    var _this = _super.call(this, config) || this;\n\n    _this.supportsMasking = true;\n    _this.activation = activations_1.getActivation(config.activation);\n    return _this;\n  }\n\n  Activation.prototype.getClassName = function () {\n    return 'Activation';\n  };\n\n  Activation.prototype.call = function (inputs, kwargs) {\n    this.invokeCallHook(inputs, kwargs);\n    var input = generic_utils.getExactlyOneTensor(inputs);\n    return this.activation(input);\n  };\n\n  return Activation;\n}(topology_1.Layer);\n\nexports.Activation = Activation;\ngeneric_utils.ClassNameMap.register('Activation', Activation);\n\nvar RepeatVector = function (_super) {\n  __extends(RepeatVector, _super);\n\n  function RepeatVector(config) {\n    var _this = _super.call(this, config) || this;\n\n    _this.n = config.n;\n    _this.inputSpec = [{\n      ndim: 2\n    }];\n    return _this;\n  }\n\n  RepeatVector.prototype.computeOutputShape = function (inputShape) {\n    return [inputShape[0], this.n, inputShape[1]];\n  };\n\n  RepeatVector.prototype.call = function (inputs, kwargs) {\n    inputs = generic_utils_1.getExactlyOneTensor(inputs);\n    return K.repeat(inputs, this.n);\n  };\n\n  RepeatVector.prototype.getClassName = function () {\n    return 'RepeatVector';\n  };\n\n  RepeatVector.prototype.getConfig = function () {\n    var config = {\n      n: this.n\n    };\n\n    var baseConfig = _super.prototype.getConfig.call(this);\n\n    Object.assign(config, baseConfig);\n    return config;\n  };\n\n  return RepeatVector;\n}(topology_1.Layer);\n\nexports.RepeatVector = RepeatVector;\ngeneric_utils.ClassNameMap.register('RepeatVector', RepeatVector);\n\nvar Reshape = function (_super) {\n  __extends(Reshape, _super);\n\n  function Reshape(config) {\n    var _this = _super.call(this, config) || this;\n\n    _this.targetShape = config.targetShape;\n\n    for (var i = 0; i < _this.targetShape.length; ++i) {\n      if (_this.isUnknown(_this.targetShape[i])) {\n        _this.targetShape[i] = null;\n      }\n    }\n\n    return _this;\n  }\n\n  Reshape.prototype.isUnknown = function (dim) {\n    return dim < 0 || dim == null;\n  };\n\n  Reshape.prototype.fixUnknownDimension = function (inputShape, outputShape) {\n    var errorMsg = 'Total size of new array must be unchanged.';\n    var finalShape = outputShape.slice();\n    var known = 1;\n    var unknown = null;\n\n    for (var i = 0; i < finalShape.length; ++i) {\n      var dim = finalShape[i];\n\n      if (this.isUnknown(dim)) {\n        if (unknown === null) {\n          unknown = i;\n        } else {\n          throw new errors_1.ValueError('Can only specifiy one unknown dimension.');\n        }\n      } else {\n        known *= dim;\n      }\n    }\n\n    var originalSize = math_utils.arrayProd(inputShape);\n\n    if (unknown !== null) {\n      if (known === 0 || originalSize % known !== 0) {\n        throw new errors_1.ValueError(errorMsg);\n      }\n\n      finalShape[unknown] = originalSize / known;\n    } else if (originalSize !== known) {\n      throw new errors_1.ValueError(errorMsg);\n    }\n\n    return finalShape;\n  };\n\n  Reshape.prototype.computeOutputShape = function (inputShape) {\n    var anyUnknownDims = false;\n\n    for (var i = 0; i < inputShape.length; ++i) {\n      if (this.isUnknown(inputShape[i])) {\n        anyUnknownDims = true;\n        break;\n      }\n    }\n\n    if (anyUnknownDims) {\n      return inputShape.slice(0, 1).concat(this.targetShape);\n    } else {\n      return inputShape.slice(0, 1).concat(this.fixUnknownDimension(inputShape.slice(1), this.targetShape));\n    }\n  };\n\n  Reshape.prototype.getClassName = function () {\n    return 'Reshape';\n  };\n\n  Reshape.prototype.call = function (inputs, kwargs) {\n    this.invokeCallHook(inputs, kwargs);\n    var input = generic_utils.getExactlyOneTensor(inputs);\n    var inputShape = K.shape(input);\n    var outputShape = inputShape.slice(0, 1).concat(this.fixUnknownDimension(inputShape.slice(1), this.targetShape));\n    return K.reshape(input, outputShape);\n  };\n\n  return Reshape;\n}(topology_1.Layer);\n\nexports.Reshape = Reshape;\ngeneric_utils.ClassNameMap.register('Reshape', Reshape);","map":null,"metadata":{},"sourceType":"script"}