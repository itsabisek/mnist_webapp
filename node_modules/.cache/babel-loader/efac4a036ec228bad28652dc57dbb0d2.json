{"ast":null,"code":"\"use strict\";\n/**\n * @license\n * Copyright 2018 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function sent() {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) {\n      try {\n        if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n        if (y = 0, t) op = [op[0] & 2, t.value];\n\n        switch (op[0]) {\n          case 0:\n          case 1:\n            t = op;\n            break;\n\n          case 4:\n            _.label++;\n            return {\n              value: op[1],\n              done: false\n            };\n\n          case 5:\n            _.label++;\n            y = op[1];\n            op = [0];\n            continue;\n\n          case 7:\n            op = _.ops.pop();\n\n            _.trys.pop();\n\n            continue;\n\n          default:\n            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n              _ = 0;\n              continue;\n            }\n\n            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n              _.label = op[1];\n              break;\n            }\n\n            if (op[0] === 6 && _.label < t[1]) {\n              _.label = t[1];\n              t = op;\n              break;\n            }\n\n            if (t && _.label < t[2]) {\n              _.label = t[2];\n\n              _.ops.push(op);\n\n              break;\n            }\n\n            if (t[2]) _.ops.pop();\n\n            _.trys.pop();\n\n            continue;\n        }\n\n        op = body.call(thisArg, _);\n      } catch (e) {\n        op = [6, e];\n        y = 0;\n      } finally {\n        f = t = 0;\n      }\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n}); // tslint:disable-next-line:max-line-length\n\nvar tfjs_core_1 = require(\"@tensorflow/tfjs-core\");\n\nvar types_1 = require(\"@tensorflow/tfjs-core/dist/types\");\n\nvar util_1 = require(\"util\");\n\nvar int64_tensors_1 = require(\"./int64_tensors\"); // tslint:disable-next-line:max-line-length\n\n\nvar op_utils_1 = require(\"./ops/op_utils\");\n\nvar NodeJSKernelBackend =\n/** @class */\nfunction (_super) {\n  __extends(NodeJSKernelBackend, _super);\n\n  function NodeJSKernelBackend(binding, packageName) {\n    var _this = _super.call(this) || this;\n\n    _this.tensorMap = new WeakMap();\n    _this.binding = binding;\n    _this.isGPUPackage = packageName === '@tensorflow/tfjs-node-gpu';\n    return _this;\n  }\n\n  NodeJSKernelBackend.prototype.setDataMover = function (dataMover) {// TODO(kreeger, smilkov): Implement this.\n  };\n\n  NodeJSKernelBackend.prototype.getDTypeInteger = function (dtype) {\n    switch (dtype) {\n      case 'float32':\n        return this.binding.TF_FLOAT;\n\n      case 'int32':\n        return this.binding.TF_INT32;\n\n      case 'bool':\n        return this.binding.TF_BOOL;\n\n      case 'complex64':\n        return this.binding.TF_COMPLEX64;\n\n      case 'string':\n        return this.binding.TF_STRING;\n\n      default:\n        throw new Error(\"Unsupported DType: \" + dtype);\n    }\n  };\n\n  NodeJSKernelBackend.prototype.typeAttributeFromTensor = function (value) {\n    return this.getDTypeInteger(value.dtype);\n  }; // Creates a new Tensor and maps the dataId to the passed in ID.\n\n\n  NodeJSKernelBackend.prototype.createOutputTensor = function (metadata) {\n    var newId = {};\n    this.tensorMap.set(newId, {\n      shape: metadata.shape,\n      dtype: metadata.dtype,\n      id: metadata.id,\n      values: null\n    });\n    var dtype;\n\n    switch (metadata.dtype) {\n      case this.binding.TF_FLOAT:\n        dtype = 'float32';\n        break;\n\n      case this.binding.TF_INT32:\n        dtype = 'int32';\n        break;\n\n      case this.binding.TF_BOOL:\n        dtype = 'bool';\n        break;\n\n      case this.binding.TF_COMPLEX64:\n        dtype = 'complex64';\n        break;\n\n      case this.binding.TF_STRING:\n        dtype = 'string';\n        break;\n\n      case this.binding.TF_RESOURCE:\n        // NOTE(cais): We currently represent resource-type Tensors\n        // as string of ubytes.\n        dtype = 'string';\n        break;\n\n      default:\n        throw new Error(\"Unknown dtype enum \" + metadata.dtype);\n    }\n\n    return tfjs_core_1.Tensor.make(metadata.shape, {\n      dataId: newId\n    }, dtype);\n  }; // Prepares Tensor instances for Op execution.\n\n\n  NodeJSKernelBackend.prototype.getInputTensorIds = function (tensors) {\n    var ids = [];\n\n    for (var i = 0; i < tensors.length; i++) {\n      if (tensors[i] instanceof tfjs_core_1.Tensor) {\n        var info = this.tensorMap.get(tensors[i].dataId); // TODO - what about ID in this case? Handle in write()??\n\n        if (info.values != null) {\n          // Values were delayed to write into the TensorHandle. Do that before\n          // Op execution and clear stored values.\n          info.id = this.binding.createTensor(info.shape, info.dtype, info.values);\n          info.values = null;\n          this.tensorMap.set(tensors[i].dataId, info);\n        }\n\n        ids.push(info.id);\n      } else if (tensors[i] instanceof int64_tensors_1.Int64Scalar) {\n        // Then `tensors[i]` is a Int64Scalar, which we currently represent\n        // using an `Int32Array`.\n        var value = tensors[i].valueArray;\n        var id = this.binding.createTensor([], this.binding.TF_INT64, value);\n        ids.push(id);\n      } else {\n        throw new Error(\"Invalid Tensor type: \" + typeof tensors[i]);\n      }\n    }\n\n    return ids;\n  };\n\n  NodeJSKernelBackend.prototype.createReductionOpAttrs = function (tensor) {\n    return [{\n      name: 'keep_dims',\n      type: this.binding.TF_ATTR_BOOL,\n      value: false\n    }, op_utils_1.createTypeOpAttr('T', tensor.dtype), op_utils_1.createTypeOpAttr('Tidx', 'int32')];\n  };\n\n  NodeJSKernelBackend.prototype.executeSingleInput = function (name, input) {\n    var opAttrs = [op_utils_1.createTypeOpAttr('T', input.dtype)];\n    return this.executeSingleOutput(name, opAttrs, [input]);\n  };\n\n  NodeJSKernelBackend.prototype.floatPrecision = function () {\n    return 32;\n  };\n  /**\n   * Executes a TensorFlow Eager Op that provides one output Tensor.\n   * @param name The name of the Op to execute.\n   * @param opAttrs The list of Op attributes required to execute.\n   * @param inputs The list of input Tensors for the Op.\n   * @return A resulting Tensor from Op execution.\n   */\n\n\n  NodeJSKernelBackend.prototype.executeSingleOutput = function (name, opAttrs, inputs) {\n    var outputMetadata = this.binding.executeOp(name, opAttrs, this.getInputTensorIds(inputs), 1);\n    return this.createOutputTensor(outputMetadata[0]);\n  };\n  /**\n   * Executes a TensorFlow Eager Op that provides multiple output Tensors.\n   * @param name The name of the Op to execute.\n   * @param opAttrs The list of Op attributes required to execute.\n   * @param inputs The list of input Tensors for the Op.\n   * @param numOutputs The number of output Tensors for Op execution.\n   * @return A resulting Tensor array from Op execution.\n   */\n\n\n  NodeJSKernelBackend.prototype.executeMultipleOutputs = function (name, opAttrs, inputs, numOutputs) {\n    var _this = this;\n\n    var outputMetadata = this.binding.executeOp(name, opAttrs, this.getInputTensorIds(inputs), numOutputs);\n    return outputMetadata.map(function (m) {\n      return _this.createOutputTensor(m);\n    });\n  };\n\n  NodeJSKernelBackend.prototype.dispose = function () {};\n\n  NodeJSKernelBackend.prototype.read = function (dataId) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , this.readSync(dataId)];\n      });\n    });\n  };\n\n  NodeJSKernelBackend.prototype.readSync = function (dataId) {\n    if (!this.tensorMap.has(dataId)) {\n      throw new Error(\"Tensor \" + dataId + \" was not registered!\");\n    }\n\n    var info = this.tensorMap.get(dataId);\n\n    if (info.values != null) {\n      return info.values;\n    } else {\n      return this.binding.tensorDataSync(info.id);\n    }\n  };\n\n  NodeJSKernelBackend.prototype.disposeData = function (dataId) {\n    var id = this.tensorMap.get(dataId).id;\n\n    if (id != null && id >= 0) {\n      this.binding.deleteTensor(id);\n    }\n\n    this.tensorMap.delete(dataId);\n  };\n\n  NodeJSKernelBackend.prototype.write = function (dataId, values) {\n    if (!this.tensorMap.has(dataId)) {\n      throw new Error(\"Tensor \" + dataId + \" was not registered!\");\n    }\n\n    var info = this.tensorMap.get(dataId);\n    info.values = values;\n    this.tensorMap.set(dataId, info);\n  };\n\n  NodeJSKernelBackend.prototype.register = function (dataId, shape, dtype) {\n    if (!this.tensorMap.has(dataId)) {\n      this.tensorMap.set(dataId, {\n        shape: shape,\n        dtype: op_utils_1.getTFDType(dtype),\n        values: null,\n        id: -1\n      });\n    }\n  };\n\n  NodeJSKernelBackend.prototype.fill = function (shape, value, dtype) {\n    // TODO(cais, nkreeger): Investigate whether this can be made into\n    // a dtype helper method. The underlying op kernel doesn't accept undefined\n    // or null dtype.\n    if (dtype == null) {\n      if (typeof value === 'number') {\n        dtype = 'float32';\n      } else {\n        dtype = 'string';\n      }\n    }\n\n    var shapeTensor = tfjs_core_1.tensor1d(shape, 'int32');\n    var valueTensor = tfjs_core_1.scalar(value, dtype);\n    var opAttrs = [{\n      name: 'T',\n      type: this.binding.TF_ATTR_TYPE,\n      value: this.getDTypeInteger(dtype)\n    }, {\n      name: 'index_type',\n      type: this.binding.TF_ATTR_TYPE,\n      value: this.binding.TF_INT32\n    }];\n    return this.executeSingleOutput('Fill', opAttrs, [shapeTensor, valueTensor]);\n  };\n\n  NodeJSKernelBackend.prototype.onesLike = function (x) {\n    var opAttrs = [{\n      name: 'T',\n      type: this.binding.TF_ATTR_TYPE,\n      value: this.getDTypeInteger(x.dtype)\n    }];\n    return this.executeSingleOutput('OnesLike', opAttrs, [x]);\n  };\n\n  NodeJSKernelBackend.prototype.zerosLike = function (x) {\n    var opAttrs = [{\n      name: 'T',\n      type: this.binding.TF_ATTR_TYPE,\n      value: this.getDTypeInteger(x.dtype)\n    }];\n    return this.executeSingleOutput('ZerosLike', opAttrs, [x]);\n  };\n\n  NodeJSKernelBackend.prototype.stridedSlice = function (x, begin, end, strides, beginMask, endMask, ellipsisMask, newAxisMask, shrinkAxisMask) {\n    var beginTensor = tfjs_core_1.tensor1d(begin, 'int32');\n    var endTensor = tfjs_core_1.tensor1d(end, 'int32');\n    var stridesTensor = tfjs_core_1.tensor1d(strides, 'int32');\n    var opAttrs = [op_utils_1.createTypeOpAttr('T', x.dtype), op_utils_1.createTypeOpAttr('Index', 'int32'), {\n      name: 'begin_mask',\n      type: this.binding.TF_ATTR_INT,\n      value: beginMask\n    }, {\n      name: 'end_mask',\n      type: this.binding.TF_ATTR_INT,\n      value: endMask\n    }, {\n      name: 'ellipsis_mask',\n      type: this.binding.TF_ATTR_INT,\n      value: ellipsisMask\n    }, {\n      name: 'new_axis_mask',\n      type: this.binding.TF_ATTR_INT,\n      value: newAxisMask\n    }, {\n      name: 'shrink_axis_mask',\n      type: this.binding.TF_ATTR_INT,\n      value: shrinkAxisMask\n    }];\n    return this.executeSingleOutput('StridedSlice', opAttrs, [x, beginTensor, endTensor, stridesTensor]);\n  };\n\n  NodeJSKernelBackend.prototype.unstack = function (x, axis) {\n    if (axis >= x.shape.length) {\n      throw new Error(\"Invalid axis supplied: \" + axis + \" shape length: \" + x.shape.length);\n    }\n\n    var num = x.shape[axis];\n    var opAttrs = [{\n      name: 'num',\n      type: this.binding.TF_ATTR_INT,\n      value: num\n    }, op_utils_1.createTypeOpAttr('T', x.dtype), {\n      name: 'axis',\n      type: this.binding.TF_ATTR_INT,\n      value: axis\n    }];\n    return this.executeMultipleOutputs('Unpack', opAttrs, [x], num);\n  };\n\n  NodeJSKernelBackend.prototype.batchMatMul = function (a, b, transposeA, transposeB) {\n    var opAttrs = [op_utils_1.createTypeOpAttr('T', a.dtype), {\n      name: 'adj_x',\n      type: this.binding.TF_ATTR_BOOL,\n      value: transposeA\n    }, {\n      name: 'adj_y',\n      type: this.binding.TF_ATTR_BOOL,\n      value: transposeB\n    }];\n    return this.executeSingleOutput('BatchMatMul', opAttrs, [a, b]);\n  };\n\n  NodeJSKernelBackend.prototype.fusedBatchMatMul = function (a, b, transposeA, transposeB, bias, activation) {\n    // Core TensorFlow does not have a fused BatchMatMul op. Combine calls to\n    // achieve the same results:\n    var result = this.batchMatMul(a, b, transposeA, transposeB);\n\n    if (bias) {\n      result = this.add(result, bias);\n    }\n\n    if (activation) {\n      if (activation === 'linear') {// No-op\n      } else if (activation === 'relu') {\n        result = this.relu(result);\n      } else {\n        throw new Error(\"Activation: \" + activation + \" has not been implemented for the Node.js backend\");\n      }\n    }\n\n    return result;\n  };\n\n  NodeJSKernelBackend.prototype.slice = function (x, begin, size) {\n    var opAttrs = [op_utils_1.createTypeOpAttr('T', x.dtype), op_utils_1.createTypeOpAttr('Index', 'int32')]; // Bind tensor values\n\n    var beginTensor = tfjs_core_1.tensor1d(begin, 'int32');\n    var sizeTensor = tfjs_core_1.tensor1d(size, 'int32');\n    return this.executeSingleOutput('Slice', opAttrs, [x, beginTensor, sizeTensor]);\n  };\n\n  NodeJSKernelBackend.prototype.reverse = function (a, axis) {\n    var opAttrs = [op_utils_1.createTypeOpAttr('Tidx', 'int32'), op_utils_1.createTypeOpAttr('T', a.dtype)];\n    var axisTensor = tfjs_core_1.tensor1d(axis, 'int32');\n    return this.executeSingleOutput('ReverseV2', opAttrs, [a, axisTensor]);\n  };\n\n  NodeJSKernelBackend.prototype.concat = function (tensors, axis) {\n    var opAttrs = [{\n      name: 'N',\n      type: this.binding.TF_ATTR_INT,\n      value: tensors.length\n    }, {\n      name: 'Tidx',\n      type: this.binding.TF_ATTR_TYPE,\n      value: this.binding.TF_INT32\n    }, op_utils_1.createTensorsTypeOpAttr('T', tensors)];\n    var inputs = Array.from(tensors);\n    inputs.push(tfjs_core_1.scalar(axis, 'int32'));\n    return this.executeSingleOutput('ConcatV2', opAttrs, inputs);\n  };\n\n  NodeJSKernelBackend.prototype.neg = function (a) {\n    return this.executeSingleInput('Neg', a);\n  };\n\n  NodeJSKernelBackend.prototype.add = function (a, b) {\n    var opAttrs = [op_utils_1.createTypeOpAttr('T', types_1.upcastType(a.dtype, b.dtype))];\n    return this.executeSingleOutput('Add', opAttrs, [a, b]);\n  };\n\n  NodeJSKernelBackend.prototype.select = function (condition, a, b) {\n    var opAttrs = [op_utils_1.createTypeOpAttr('T', types_1.upcastType(a.dtype, b.dtype))];\n    return this.executeSingleOutput('Select', opAttrs, [condition, a, b]);\n  };\n\n  NodeJSKernelBackend.prototype.addN = function (tensors) {\n    var opAttrs = [op_utils_1.createTypeOpAttr('T', tensors[0].dtype), {\n      name: 'N',\n      type: this.binding.TF_ATTR_INT,\n      value: tensors.length\n    }];\n    return this.executeSingleOutput('AddN', opAttrs, tensors);\n  };\n\n  NodeJSKernelBackend.prototype.subtract = function (a, b) {\n    var opAttrs = [op_utils_1.createTypeOpAttr('T', types_1.upcastType(a.dtype, b.dtype))];\n    return this.executeSingleOutput('Sub', opAttrs, [a, b]);\n  };\n\n  NodeJSKernelBackend.prototype.multiply = function (a, b) {\n    var opAttrs = [op_utils_1.createTypeOpAttr('T', types_1.upcastType(a.dtype, b.dtype))];\n    return this.executeSingleOutput('Mul', opAttrs, [a, b]);\n  };\n\n  NodeJSKernelBackend.prototype.realDivide = function (a, b) {\n    var opAttrs = [op_utils_1.createTypeOpAttr('T', types_1.upcastType(a.dtype, b.dtype))];\n    return this.executeSingleOutput('RealDiv', opAttrs, [a, b]);\n  };\n\n  NodeJSKernelBackend.prototype.floorDiv = function (a, b) {\n    var opAttrs = [op_utils_1.createTypeOpAttr('T', types_1.upcastType(a.dtype, b.dtype))];\n    return this.executeSingleOutput('FloorDiv', opAttrs, [a, b]);\n  };\n\n  NodeJSKernelBackend.prototype.divide = function (a, b) {\n    var opAttrs = [op_utils_1.createTypeOpAttr('T', types_1.upcastType(a.dtype, b.dtype))];\n    return this.executeSingleOutput('Div', opAttrs, [a, b]);\n  };\n\n  NodeJSKernelBackend.prototype.unsortedSegmentSum = function (x, segmentIds, numSegments) {\n    var opAttrs = [op_utils_1.createTypeOpAttr('T', x.dtype), op_utils_1.createTypeOpAttr('Tindices', 'int32'), op_utils_1.createTypeOpAttr('Tnumsegments', 'int32')];\n    return this.executeSingleOutput('UnsortedSegmentSum', opAttrs, [x, segmentIds, tfjs_core_1.scalar(numSegments, 'int32')]);\n  };\n\n  NodeJSKernelBackend.prototype.sum = function (x, axes) {\n    var axisTensor = tfjs_core_1.tensor1d(axes, 'int32');\n    return this.executeSingleOutput('Sum', this.createReductionOpAttrs(x), [x, axisTensor]);\n  };\n\n  NodeJSKernelBackend.prototype.prod = function (x, axes) {\n    var axesTensor = tfjs_core_1.tensor1d(axes, 'int32');\n    var opAttrs = [{\n      name: 'keep_dims',\n      type: this.binding.TF_ATTR_BOOL,\n      value: false\n    }, op_utils_1.createTypeOpAttr('T', x.dtype), op_utils_1.createTypeOpAttr('Tidx', 'int32')];\n    return this.executeSingleOutput('Prod', opAttrs, [x, axesTensor]);\n  };\n\n  NodeJSKernelBackend.prototype.argMin = function (x, axis) {\n    var xInput = x.dtype === 'bool' ? x.toInt() : x;\n    var axisScalar = tfjs_core_1.scalar(axis, 'int32');\n    var opAttrs = [op_utils_1.createTypeOpAttr('T', xInput.dtype), op_utils_1.createTypeOpAttr('Tidx', 'int32'), op_utils_1.createTypeOpAttr('output_type', 'int32')];\n    return this.executeSingleOutput('ArgMin', opAttrs, [xInput, axisScalar]);\n  };\n\n  NodeJSKernelBackend.prototype.argMax = function (x, axis) {\n    var xInput = x.dtype === 'bool' ? x.toInt() : x;\n    var axisScalar = tfjs_core_1.scalar(axis, 'int32');\n    var opAttrs = [op_utils_1.createTypeOpAttr('T', xInput.dtype), op_utils_1.createTypeOpAttr('Tidx', 'int32'), op_utils_1.createTypeOpAttr('output_type', 'int32')];\n    return this.executeSingleOutput('ArgMax', opAttrs, [xInput, axisScalar]);\n  };\n\n  NodeJSKernelBackend.prototype.equal = function (a, b) {\n    var opAttrs = [op_utils_1.createTypeOpAttr('T', types_1.upcastType(a.dtype, b.dtype))];\n    return this.executeSingleOutput('Equal', opAttrs, [a, b]);\n  };\n\n  NodeJSKernelBackend.prototype.notEqual = function (a, b) {\n    var opAttrs = [op_utils_1.createTypeOpAttr('T', types_1.upcastType(a.dtype, b.dtype))];\n    return this.executeSingleOutput('NotEqual', opAttrs, [a, b]);\n  };\n\n  NodeJSKernelBackend.prototype.less = function (a, b) {\n    var opAttrs = [op_utils_1.createTypeOpAttr('T', types_1.upcastType(a.dtype, b.dtype))];\n    return this.executeSingleOutput('Less', opAttrs, [a, b]);\n  };\n\n  NodeJSKernelBackend.prototype.lessEqual = function (a, b) {\n    var opAttrs = [op_utils_1.createTypeOpAttr('T', types_1.upcastType(a.dtype, b.dtype))];\n    return this.executeSingleOutput('LessEqual', opAttrs, [a, b]);\n  };\n\n  NodeJSKernelBackend.prototype.greater = function (a, b) {\n    var opAttrs = [op_utils_1.createTypeOpAttr('T', types_1.upcastType(a.dtype, b.dtype))];\n    return this.executeSingleOutput('Greater', opAttrs, [a, b]);\n  };\n\n  NodeJSKernelBackend.prototype.greaterEqual = function (a, b) {\n    var opAttrs = [op_utils_1.createTypeOpAttr('T', types_1.upcastType(a.dtype, b.dtype))];\n    return this.executeSingleOutput('GreaterEqual', opAttrs, [a, b]);\n  };\n\n  NodeJSKernelBackend.prototype.logicalNot = function (a) {\n    return this.executeSingleOutput('LogicalNot', [], [a]);\n  };\n\n  NodeJSKernelBackend.prototype.logicalAnd = function (a, b) {\n    return this.executeSingleOutput('LogicalAnd', [], [a, b]);\n  };\n\n  NodeJSKernelBackend.prototype.logicalOr = function (a, b) {\n    return this.executeSingleOutput('LogicalOr', [], [a, b]);\n  };\n\n  NodeJSKernelBackend.prototype.where = function (condition) {\n    return this.executeSingleOutput('Where', [], [condition]);\n  };\n\n  NodeJSKernelBackend.prototype.topKValues = function (x, k) {\n    throw new Error('Method not implemented.');\n  };\n\n  NodeJSKernelBackend.prototype.topKIndices = function (x, k) {\n    throw new Error('Method not implemented.');\n  };\n\n  NodeJSKernelBackend.prototype.topk = function (x, k, sorted) {\n    var kCount = util_1.isNullOrUndefined(k) ? 1 : k;\n    var isSorted = util_1.isNullOrUndefined(sorted) ? true : sorted;\n    var opAttrs = [{\n      name: 'sorted',\n      type: this.binding.TF_ATTR_BOOL,\n      value: isSorted\n    }, op_utils_1.createTypeOpAttr('T', x.dtype)];\n    var kTensor = tfjs_core_1.scalar(kCount, 'int32'); // 'TopKV2' has two-hard coded output attributes:\n\n    return this.executeMultipleOutputs('TopKV2', opAttrs, [x, kTensor], 2);\n  };\n\n  NodeJSKernelBackend.prototype.min = function (x, axes) {\n    var axesTensor = tfjs_core_1.tensor1d(axes, 'int32');\n    return this.executeSingleOutput('Min', this.createReductionOpAttrs(x), [x, axesTensor]);\n  };\n\n  NodeJSKernelBackend.prototype.minimum = function (a, b) {\n    var opAttrs = [op_utils_1.createTypeOpAttr('T', types_1.upcastType(a.dtype, b.dtype))];\n    return this.executeSingleOutput('Minimum', opAttrs, [a, b]);\n  };\n\n  NodeJSKernelBackend.prototype.max = function (x, axes) {\n    var axesTensor = tfjs_core_1.tensor1d(axes, 'int32');\n    return this.executeSingleOutput('Max', this.createReductionOpAttrs(x), [x, axesTensor]);\n  };\n\n  NodeJSKernelBackend.prototype.maximum = function (a, b) {\n    var opAttrs = [op_utils_1.createTypeOpAttr('T', types_1.upcastType(a.dtype, b.dtype))];\n    return this.executeSingleOutput('Maximum', opAttrs, [a, b]);\n  };\n\n  NodeJSKernelBackend.prototype.all = function (x, axes) {\n    var opAttrs = [{\n      name: 'keep_dims',\n      type: this.binding.TF_ATTR_BOOL,\n      value: false\n    }, op_utils_1.createTypeOpAttr('Tidx', 'int32')];\n    var axesTensor = tfjs_core_1.tensor1d(axes, 'int32');\n    return this.executeSingleOutput('All', opAttrs, [x, axesTensor]);\n  };\n\n  NodeJSKernelBackend.prototype.any = function (x, axes) {\n    var opAttrs = [{\n      name: 'keep_dims',\n      type: this.binding.TF_ATTR_BOOL,\n      value: false\n    }, op_utils_1.createTypeOpAttr('Tidx', 'int32')];\n    var axesTensor = tfjs_core_1.tensor1d(axes, 'int32');\n    return this.executeSingleOutput('Any', opAttrs, [x, axesTensor]);\n  };\n\n  NodeJSKernelBackend.prototype.ceil = function (x) {\n    return this.executeSingleInput('Ceil', x);\n  };\n\n  NodeJSKernelBackend.prototype.floor = function (x) {\n    return this.executeSingleInput('Floor', x);\n  };\n\n  NodeJSKernelBackend.prototype.pow = function (a, b) {\n    var dtype = types_1.upcastType(a.dtype, b.dtype);\n    var opAttrs = [op_utils_1.createTypeOpAttr('T', dtype)];\n    return this.executeSingleOutput('Pow', opAttrs, [a.cast(dtype), b.cast(dtype)]);\n  };\n\n  NodeJSKernelBackend.prototype.exp = function (x) {\n    var xTensor = x.dtype === 'int32' ? x.toFloat() : x;\n    return this.executeSingleInput('Exp', xTensor);\n  };\n\n  NodeJSKernelBackend.prototype.log = function (x) {\n    return this.executeSingleInput('Log', x);\n  };\n\n  NodeJSKernelBackend.prototype.log1p = function (x) {\n    return this.executeSingleInput('Log1p', x);\n  };\n\n  NodeJSKernelBackend.prototype.sqrt = function (x) {\n    return this.executeSingleInput('Sqrt', x);\n  };\n\n  NodeJSKernelBackend.prototype.square = function (x) {\n    return this.executeSingleInput('Square', x);\n  };\n\n  NodeJSKernelBackend.prototype.relu = function (x) {\n    return this.executeSingleInput('Relu', x);\n  };\n\n  NodeJSKernelBackend.prototype.prelu = function (x, a) {\n    var pos = this.relu(x);\n    var neg = a.mul(x.sub(this.abs(x))).mul(0.5);\n    return pos.add(neg);\n  };\n\n  NodeJSKernelBackend.prototype.elu = function (x) {\n    return this.executeSingleInput('Elu', x);\n  };\n\n  NodeJSKernelBackend.prototype.eluDer = function (dy, y) {\n    var opAttrs = [op_utils_1.createTypeOpAttr('T', y.dtype)];\n    return this.executeSingleOutput('EluGrad', opAttrs, [dy, y]);\n  };\n\n  NodeJSKernelBackend.prototype.selu = function (x) {\n    return this.executeSingleInput('Selu', x);\n  };\n\n  NodeJSKernelBackend.prototype.int = function (x) {\n    throw new Error('Method not implemented.');\n  };\n\n  NodeJSKernelBackend.prototype.clip = function (x, min, max) {\n    var xMin = this.minimum(x, tfjs_core_1.scalar(max));\n    return this.maximum(xMin, tfjs_core_1.scalar(min));\n  };\n\n  NodeJSKernelBackend.prototype.abs = function (x) {\n    return this.executeSingleInput('Abs', x);\n  };\n\n  NodeJSKernelBackend.prototype.complexAbs = function (x) {\n    var opAttrs = [op_utils_1.createTypeOpAttr('T', x.dtype), op_utils_1.createTypeOpAttr('Tout', 'float32')];\n    return this.executeSingleOutput('ComplexAbs', opAttrs, [x]);\n  };\n\n  NodeJSKernelBackend.prototype.sigmoid = function (x) {\n    return this.executeSingleInput('Sigmoid', x);\n  };\n\n  NodeJSKernelBackend.prototype.sin = function (x) {\n    return this.executeSingleInput('Sin', x);\n  };\n\n  NodeJSKernelBackend.prototype.cos = function (x) {\n    return this.executeSingleInput('Cos', x);\n  };\n\n  NodeJSKernelBackend.prototype.tan = function (x) {\n    return this.executeSingleInput('Tan', x);\n  };\n\n  NodeJSKernelBackend.prototype.asin = function (x) {\n    return this.executeSingleInput('Asin', x);\n  };\n\n  NodeJSKernelBackend.prototype.acos = function (x) {\n    return this.executeSingleInput('Acos', x);\n  };\n\n  NodeJSKernelBackend.prototype.atan = function (x) {\n    return this.executeSingleInput('Atan', x);\n  };\n\n  NodeJSKernelBackend.prototype.sinh = function (x) {\n    return this.executeSingleInput('Sinh', x);\n  };\n\n  NodeJSKernelBackend.prototype.cosh = function (x) {\n    return this.executeSingleInput('Cosh', x);\n  };\n\n  NodeJSKernelBackend.prototype.tanh = function (x) {\n    return this.executeSingleInput('Tanh', x);\n  };\n\n  NodeJSKernelBackend.prototype.mod = function (a, b) {\n    var opAttrs = [op_utils_1.createTypeOpAttr('T', a.dtype)];\n    return this.executeSingleOutput('FloorMod', opAttrs, [a, b]);\n  };\n\n  NodeJSKernelBackend.prototype.round = function (x) {\n    return this.executeSingleInput('Round', x);\n  };\n\n  NodeJSKernelBackend.prototype.sign = function (x) {\n    return this.executeSingleInput('Sign', x);\n  };\n\n  NodeJSKernelBackend.prototype.isNaN = function (x) {\n    return this.executeSingleInput('IsNan', x);\n  };\n\n  NodeJSKernelBackend.prototype.isInf = function (x) {\n    return this.executeSingleInput('IsInf', x);\n  };\n\n  NodeJSKernelBackend.prototype.isFinite = function (x) {\n    return this.executeSingleInput('IsFinite', x);\n  };\n\n  NodeJSKernelBackend.prototype.rsqrt = function (x) {\n    return this.executeSingleInput('Rsqrt', x);\n  };\n\n  NodeJSKernelBackend.prototype.reciprocal = function (x) {\n    return this.executeSingleInput('Reciprocal', x);\n  };\n\n  NodeJSKernelBackend.prototype.asinh = function (x) {\n    return this.executeSingleInput('Asinh', x);\n  };\n\n  NodeJSKernelBackend.prototype.acosh = function (x) {\n    return this.executeSingleInput('Acosh', x);\n  };\n\n  NodeJSKernelBackend.prototype.atanh = function (x) {\n    return this.executeSingleInput('Atanh', x);\n  };\n\n  NodeJSKernelBackend.prototype.erf = function (x) {\n    return this.executeSingleInput('Erf', x);\n  };\n\n  NodeJSKernelBackend.prototype.squaredDifference = function (a, b) {\n    var opAttrs = [op_utils_1.createTypeOpAttr('T', a.dtype)];\n    return this.executeSingleOutput('SquaredDifference', opAttrs, [a, b]);\n  };\n\n  NodeJSKernelBackend.prototype.expm1 = function (x) {\n    return this.executeSingleInput('Expm1', x);\n  };\n\n  NodeJSKernelBackend.prototype.softplus = function (x) {\n    return this.executeSingleInput('Softplus', x);\n  };\n\n  NodeJSKernelBackend.prototype.atan2 = function (a, b) {\n    var opAttrs = [op_utils_1.createTypeOpAttr('T', a.dtype)];\n    return this.executeSingleOutput('Atan2', opAttrs, [a, b]);\n  };\n\n  NodeJSKernelBackend.prototype.step = function (x, alpha) {\n    var dtype = x.dtype;\n    var nans = this.isNaN(x);\n    var stepNoNans = this.select(this.greater(x, tfjs_core_1.scalar(0, dtype)), tfjs_core_1.ones(x.shape), tfjs_core_1.fill(x.shape, alpha, dtype));\n    return this.select(nans, x, stepNoNans);\n  };\n\n  NodeJSKernelBackend.prototype.conv2d = function (x, filter, convInfo) {\n    if (convInfo.padInfo.type !== 'VALID' && convInfo.padInfo.type !== 'SAME') {\n      throw new Error(\"TF Backend supports only 'valid' and 'same' padding \" + (\"while padding was \" + convInfo.padInfo.type));\n    }\n\n    var strides = [1, convInfo.strideHeight, convInfo.strideWidth, 1];\n    var padding = convInfo.padInfo.type;\n    var dataFormat = convInfo.dataFormat === 'channelsLast' ? 'NHWC' : 'NCHW';\n    var dilations = [1, convInfo.dilationHeight, convInfo.dilationWidth, 1];\n    var opAttrs = [op_utils_1.createTypeOpAttr('T', x.dtype), {\n      name: 'strides',\n      type: this.binding.TF_ATTR_INT,\n      value: strides\n    }, {\n      name: 'padding',\n      type: this.binding.TF_ATTR_STRING,\n      value: padding\n    }, {\n      name: 'data_format',\n      type: this.binding.TF_ATTR_STRING,\n      value: dataFormat\n    }, {\n      name: 'use_cudnn_on_gpu',\n      type: this.binding.TF_ATTR_BOOL,\n      value: true\n    }, {\n      name: 'dilations',\n      type: this.binding.TF_ATTR_INT,\n      value: dilations\n    }];\n    return this.executeSingleOutput('Conv2D', opAttrs, [x, filter]);\n  };\n\n  NodeJSKernelBackend.prototype.conv2dDerInput = function (dy, filter, convInfo) {\n    if (convInfo.padInfo.type !== 'VALID' && convInfo.padInfo.type !== 'SAME') {\n      throw new Error(\"TF Backend supports only 'valid' and 'same' padding \" + (\"while padding was \" + convInfo.padInfo.type));\n    }\n\n    var strides = [1, convInfo.strideHeight, convInfo.strideWidth, 1];\n    var padding = convInfo.padInfo.type;\n    var dataFormat = convInfo.dataFormat === 'channelsLast' ? 'NHWC' : 'NCHW';\n    var dilations = [1, convInfo.dilationHeight, convInfo.dilationWidth, 1];\n    var opAttrs = [op_utils_1.createTypeOpAttr('T', 'float32'), {\n      name: 'strides',\n      type: this.binding.TF_ATTR_INT,\n      value: strides\n    }, {\n      name: 'padding',\n      type: this.binding.TF_ATTR_STRING,\n      value: padding\n    }, {\n      name: 'data_format',\n      type: this.binding.TF_ATTR_STRING,\n      value: dataFormat\n    }, {\n      name: 'use_cudnn_on_gpu',\n      type: this.binding.TF_ATTR_BOOL,\n      value: true\n    }, {\n      name: 'dilations',\n      type: this.binding.TF_ATTR_INT,\n      value: dilations\n    }];\n    var inputSizes = tfjs_core_1.tensor1d(convInfo.inShape, 'int32');\n    return this.executeSingleOutput('Conv2DBackpropInput', opAttrs, [inputSizes, filter, dy]);\n  };\n\n  NodeJSKernelBackend.prototype.conv2dDerFilter = function (x, dy, convInfo) {\n    if (convInfo.padInfo.type !== 'VALID' && convInfo.padInfo.type !== 'SAME') {\n      throw new Error(\"TF Backend supports only 'valid' and 'same' padding \" + (\"while padding was \" + convInfo.padInfo.type));\n    }\n\n    var strides = [1, convInfo.strideHeight, convInfo.strideWidth, 1];\n    var padding = convInfo.padInfo.type;\n    var dataFormat = convInfo.dataFormat === 'channelsLast' ? 'NHWC' : 'NCHW';\n    var dilations = [1, convInfo.dilationHeight, convInfo.dilationWidth, 1];\n    var opAttrs = [op_utils_1.createTypeOpAttr('T', 'float32'), {\n      name: 'strides',\n      type: this.binding.TF_ATTR_INT,\n      value: strides\n    }, {\n      name: 'padding',\n      type: this.binding.TF_ATTR_STRING,\n      value: padding\n    }, {\n      name: 'data_format',\n      type: this.binding.TF_ATTR_STRING,\n      value: dataFormat\n    }, {\n      name: 'use_cudnn_on_gpu',\n      type: this.binding.TF_ATTR_BOOL,\n      value: true\n    }, {\n      name: 'dilations',\n      type: this.binding.TF_ATTR_INT,\n      value: dilations\n    }];\n    var filterSizes = tfjs_core_1.tensor1d(convInfo.filterShape, 'int32');\n    return this.executeSingleOutput('Conv2DBackpropFilter', opAttrs, [x, filterSizes, dy]);\n  };\n\n  NodeJSKernelBackend.prototype.depthwiseConv2DDerInput = function (dy, filter, convInfo) {\n    var strides = [1, convInfo.strideHeight, convInfo.strideWidth, 1];\n    var padding = convInfo.padInfo.type;\n    var dataFormat = convInfo.dataFormat === 'channelsLast' ? 'NHWC' : 'NCHW';\n    var dilations = [1, convInfo.dilationHeight, convInfo.dilationWidth, 1];\n    var opAttrs = [op_utils_1.createTypeOpAttr('T', 'float32'), {\n      name: 'strides',\n      type: this.binding.TF_ATTR_INT,\n      value: strides\n    }, {\n      name: 'padding',\n      type: this.binding.TF_ATTR_STRING,\n      value: padding\n    }, {\n      name: 'data_format',\n      type: this.binding.TF_ATTR_STRING,\n      value: dataFormat\n    }, {\n      name: 'dilations',\n      type: this.binding.TF_ATTR_INT,\n      value: dilations\n    }];\n    var inputSizes = tfjs_core_1.tensor1d(convInfo.inShape, 'int32');\n    return this.executeSingleOutput('DepthwiseConv2dNativeBackpropInput', opAttrs, [inputSizes, filter, dy]);\n  };\n\n  NodeJSKernelBackend.prototype.depthwiseConv2DDerFilter = function (x, dY, convInfo) {\n    var strides = [1, convInfo.strideHeight, convInfo.strideWidth, 1];\n    var padding = convInfo.padInfo.type;\n    var dataFormat = convInfo.dataFormat === 'channelsLast' ? 'NHWC' : 'NCHW';\n    var dilations = [1, convInfo.dilationHeight, convInfo.dilationWidth, 1];\n    var opAttrs = [op_utils_1.createTypeOpAttr('T', 'float32'), {\n      name: 'strides',\n      type: this.binding.TF_ATTR_INT,\n      value: strides\n    }, {\n      name: 'padding',\n      type: this.binding.TF_ATTR_STRING,\n      value: padding\n    }, {\n      name: 'data_format',\n      type: this.binding.TF_ATTR_STRING,\n      value: dataFormat\n    }, {\n      name: 'dilations',\n      type: this.binding.TF_ATTR_INT,\n      value: dilations\n    }];\n    var filterSizes = tfjs_core_1.tensor1d(convInfo.filterShape, 'int32');\n    return this.executeSingleOutput('DepthwiseConv2dNativeBackpropFilter', opAttrs, [x, filterSizes, dY]);\n  };\n\n  NodeJSKernelBackend.prototype.depthwiseConv2D = function (input, filter, convInfo) {\n    if (convInfo.padInfo.type !== 'VALID' && convInfo.padInfo.type !== 'SAME') {\n      throw new Error(\"TF Backend supports only 'valid' and 'same' padding \" + (\"while padding was \" + convInfo.padInfo.type));\n    }\n\n    var strides = [1, convInfo.strideHeight, convInfo.strideWidth, 1];\n    var padding = convInfo.padInfo.type;\n    var dataFormat = convInfo.dataFormat === 'channelsLast' ? 'NHWC' : 'NCHW';\n    var dilations = [1, convInfo.dilationHeight, convInfo.dilationWidth, 1];\n    var opAttrs = [op_utils_1.createTypeOpAttr('T', input.dtype), {\n      name: 'strides',\n      type: this.binding.TF_ATTR_INT,\n      value: strides\n    }, {\n      name: 'padding',\n      type: this.binding.TF_ATTR_STRING,\n      value: padding\n    }, {\n      name: 'data_format',\n      type: this.binding.TF_ATTR_STRING,\n      value: dataFormat\n    }, {\n      name: 'dilations',\n      type: this.binding.TF_ATTR_INT,\n      value: dilations\n    }];\n    return this.executeSingleOutput('DepthwiseConv2dNative', opAttrs, [input, filter]);\n  };\n\n  NodeJSKernelBackend.prototype.conv3d = function (x, filter, convInfo) {\n    var strides = [1, convInfo.strideDepth, convInfo.strideHeight, convInfo.strideWidth, 1];\n    var padding = convInfo.padInfo.type;\n    var dataFormat = convInfo.dataFormat === 'channelsLast' ? 'NDHWC' : 'NCDHW';\n\n    if (!this.isGPUPackage && convInfo.dilationDepth > 1) {\n      throw new Error('CPU Dilation depth must be 1');\n    }\n\n    var dilations = [1, convInfo.dilationDepth, convInfo.dilationHeight, convInfo.dilationWidth, 1];\n    var opAttrs = [op_utils_1.createTypeOpAttr('T', x.dtype), {\n      name: 'strides',\n      type: this.binding.TF_ATTR_INT,\n      value: strides\n    }, {\n      name: 'padding',\n      type: this.binding.TF_ATTR_STRING,\n      value: padding\n    }, {\n      name: 'data_format',\n      type: this.binding.TF_ATTR_STRING,\n      value: dataFormat\n    }, {\n      name: 'dilations',\n      type: this.binding.TF_ATTR_INT,\n      value: dilations\n    }];\n    return this.executeSingleOutput('Conv3D', opAttrs, [x, filter]);\n  };\n\n  NodeJSKernelBackend.prototype.conv3dDerInput = function (dy, filter, convInfo) {\n    var strides = [1, convInfo.strideDepth, convInfo.strideHeight, convInfo.strideWidth, 1];\n    var padding = convInfo.padInfo.type;\n    var dataFormat = convInfo.dataFormat === 'channelsLast' ? 'NDHWC' : 'NCDHW';\n\n    if (!this.isGPUPackage && convInfo.dilationDepth > 1) {\n      throw new Error('CPU Dilation depth must be 1');\n    }\n\n    var dilations = [1, convInfo.dilationDepth, convInfo.dilationHeight, convInfo.dilationWidth, 1];\n    var opAttrs = [op_utils_1.createTypeOpAttr('T', dy.dtype), {\n      name: 'strides',\n      type: this.binding.TF_ATTR_INT,\n      value: strides\n    }, {\n      name: 'padding',\n      type: this.binding.TF_ATTR_STRING,\n      value: padding\n    }, {\n      name: 'data_format',\n      type: this.binding.TF_ATTR_STRING,\n      value: dataFormat\n    }, {\n      name: 'dilations',\n      type: this.binding.TF_ATTR_INT,\n      value: dilations\n    }, op_utils_1.createTypeOpAttr('Tshape', 'int32')];\n    var inputSizes = tfjs_core_1.tensor1d(convInfo.inShape, 'int32');\n    return this.executeSingleOutput('Conv3DBackpropInputV2', opAttrs, [inputSizes, filter, dy]);\n  };\n\n  NodeJSKernelBackend.prototype.conv3dDerFilter = function (x, dY, convInfo) {\n    var strides = [1, convInfo.strideDepth, convInfo.strideHeight, convInfo.strideWidth, 1];\n    var padding = convInfo.padInfo.type;\n    var dataFormat = convInfo.dataFormat === 'channelsLast' ? 'NDHWC' : 'NCDHW';\n\n    if (!this.isGPUPackage && convInfo.dilationDepth > 1) {\n      throw new Error('CPU Dilation depth must be 1');\n    }\n\n    var dilations = [1, convInfo.dilationDepth, convInfo.dilationHeight, convInfo.dilationWidth, 1];\n    var opAttrs = [op_utils_1.createTypeOpAttr('T', x.dtype), {\n      name: 'strides',\n      type: this.binding.TF_ATTR_INT,\n      value: strides\n    }, {\n      name: 'padding',\n      type: this.binding.TF_ATTR_STRING,\n      value: padding\n    }, {\n      name: 'data_format',\n      type: this.binding.TF_ATTR_STRING,\n      value: dataFormat\n    }, {\n      name: 'dilations',\n      type: this.binding.TF_ATTR_INT,\n      value: dilations\n    }];\n    var filterSizes = tfjs_core_1.tensor1d(convInfo.filterShape, 'int32');\n    return this.executeSingleOutput('Conv3DBackpropFilterV2', opAttrs, [x, filterSizes, dY]);\n  };\n\n  NodeJSKernelBackend.prototype.maxPool = function (x, convInfo) {\n    if (convInfo.padInfo.type !== 'VALID' && convInfo.padInfo.type !== 'SAME') {\n      throw new Error(\"TF Backend supports only 'valid' and 'same' padding \" + (\"while padding was \" + convInfo.padInfo.type));\n    }\n\n    var ksize = [1, convInfo.filterHeight, convInfo.filterWidth, 1];\n    var strides = [1, convInfo.strideHeight, convInfo.strideWidth, 1];\n    var padding = convInfo.padInfo.type;\n    var dataFormat = convInfo.dataFormat === 'channelsLast' ? 'NHWC' : 'NCHW';\n    var opAttrs = [op_utils_1.createTypeOpAttr('T', x.dtype), {\n      name: 'ksize',\n      type: this.binding.TF_ATTR_INT,\n      value: ksize\n    }, {\n      name: 'strides',\n      type: this.binding.TF_ATTR_INT,\n      value: strides\n    }, {\n      name: 'padding',\n      type: this.binding.TF_ATTR_STRING,\n      value: padding\n    }, {\n      name: 'data_format',\n      type: this.binding.TF_ATTR_STRING,\n      value: dataFormat\n    }];\n    return this.executeSingleOutput('MaxPool', opAttrs, [x]);\n  };\n\n  NodeJSKernelBackend.prototype.maxPoolBackprop = function (dy, x, y, convInfo) {\n    if (convInfo.padInfo.type !== 'VALID' && convInfo.padInfo.type !== 'SAME') {\n      throw new Error(\"TF Backend supports only 'valid' and 'same' padding \" + (\"while padding type was \" + convInfo.padInfo.type));\n    }\n\n    var ksize = [1, convInfo.filterHeight, convInfo.filterWidth, 1];\n    var strides = [1, convInfo.strideHeight, convInfo.strideWidth, 1];\n    var padding = convInfo.padInfo.type;\n    var dataFormat = convInfo.dataFormat === 'channelsLast' ? 'NHWC' : 'NCHW';\n    var opAttrs = [op_utils_1.createTypeOpAttr('T', x.dtype), {\n      name: 'ksize',\n      type: this.binding.TF_ATTR_INT,\n      value: ksize\n    }, {\n      name: 'strides',\n      type: this.binding.TF_ATTR_INT,\n      value: strides\n    }, {\n      name: 'padding',\n      type: this.binding.TF_ATTR_STRING,\n      value: padding\n    }, {\n      name: 'data_format',\n      type: this.binding.TF_ATTR_STRING,\n      value: dataFormat\n    }];\n    return this.executeSingleOutput('MaxPoolGrad', opAttrs, [x, y, dy]);\n  };\n\n  NodeJSKernelBackend.prototype.avgPool = function (x, convInfo) {\n    if (convInfo.padInfo.type !== 'VALID' && convInfo.padInfo.type !== 'SAME') {\n      throw new Error(\"TF Backend supports only 'valid' and 'same' padding \" + (\"while padding was \" + convInfo.padInfo.type));\n    }\n\n    var ksize = [1, convInfo.filterHeight, convInfo.filterWidth, 1];\n    var strides = [1, convInfo.strideHeight, convInfo.strideWidth, 1];\n    var padding = convInfo.padInfo.type;\n    var dataFormat = convInfo.dataFormat === 'channelsLast' ? 'NHWC' : 'NCHW';\n    var opAttrs = [op_utils_1.createTypeOpAttr('T', x.dtype), {\n      name: 'ksize',\n      type: this.binding.TF_ATTR_INT,\n      value: ksize\n    }, {\n      name: 'strides',\n      type: this.binding.TF_ATTR_INT,\n      value: strides\n    }, {\n      name: 'padding',\n      type: this.binding.TF_ATTR_STRING,\n      value: padding\n    }, {\n      name: 'data_format',\n      type: this.binding.TF_ATTR_STRING,\n      value: dataFormat\n    }];\n    return this.executeSingleOutput('AvgPool', opAttrs, [x]);\n  };\n\n  NodeJSKernelBackend.prototype.avgPoolBackprop = function (dy, x, convInfo) {\n    if (convInfo.padInfo.type !== 'VALID' && convInfo.padInfo.type !== 'SAME') {\n      throw new Error(\"TF Backend supports only 'valid' and 'same' padding \" + (\"while padding type was \" + convInfo.padInfo.type));\n    }\n\n    var ksize = [1, convInfo.filterHeight, convInfo.filterWidth, 1];\n    var strides = [1, convInfo.strideHeight, convInfo.strideWidth, 1];\n    var padding = convInfo.padInfo.type;\n    var dataFormat = convInfo.dataFormat === 'channelsLast' ? 'NHWC' : 'NCHW';\n    var opAttrs = [op_utils_1.createTypeOpAttr('T', x.dtype), {\n      name: 'ksize',\n      type: this.binding.TF_ATTR_INT,\n      value: ksize\n    }, {\n      name: 'strides',\n      type: this.binding.TF_ATTR_INT,\n      value: strides\n    }, {\n      name: 'padding',\n      type: this.binding.TF_ATTR_STRING,\n      value: padding\n    }, {\n      name: 'data_format',\n      type: this.binding.TF_ATTR_STRING,\n      value: dataFormat\n    }];\n    var origInputShape = tfjs_core_1.tensor1d(x.shape, 'int32');\n    return this.executeSingleOutput('AvgPoolGrad', opAttrs, [origInputShape, dy]);\n  };\n\n  NodeJSKernelBackend.prototype.reshape = function (x, shape) {\n    var shapeTensor = tfjs_core_1.tensor1d(shape, 'int32');\n    var opAttrs = [op_utils_1.createTypeOpAttr('T', x.dtype), op_utils_1.createTypeOpAttr('Tshape', shapeTensor.dtype)];\n    return this.executeSingleOutput('Reshape', opAttrs, [x, shapeTensor]);\n  };\n\n  NodeJSKernelBackend.prototype.cast = function (x, dtype) {\n    var opAttrs = [op_utils_1.createTypeOpAttr('SrcT', x.dtype), op_utils_1.createTypeOpAttr('DstT', dtype), {\n      name: 'Truncate',\n      type: this.binding.TF_ATTR_BOOL,\n      value: false\n    }];\n    return this.executeSingleOutput('Cast', opAttrs, [x]);\n  };\n\n  NodeJSKernelBackend.prototype.tile = function (x, reps) {\n    var opAttrs = [op_utils_1.createTypeOpAttr('T', x.dtype), op_utils_1.createTypeOpAttr('Tmultiples', 'int32')];\n    var multiples = tfjs_core_1.tensor1d(reps, 'int32');\n    return this.executeSingleOutput('Tile', opAttrs, [x, multiples]);\n  };\n\n  NodeJSKernelBackend.prototype.pad = function (x, paddings, constantValue) {\n    // Bind tensor values\n    var paddingsTensor = tfjs_core_1.tensor2d(paddings, [paddings.length, 2], 'int32');\n    var constantTensor = tfjs_core_1.scalar(constantValue, x.dtype);\n    var opAttrs = [op_utils_1.createTypeOpAttr('T', x.dtype), op_utils_1.createTypeOpAttr('Tpaddings', paddingsTensor.dtype)];\n    return this.executeSingleOutput('PadV2', opAttrs, [x, paddingsTensor, constantTensor]);\n  };\n\n  NodeJSKernelBackend.prototype.transpose = function (x, perm) {\n    var permTensor = tfjs_core_1.tensor1d(perm, 'int32');\n    var opAttrs = [op_utils_1.createTypeOpAttr('T', x.dtype), op_utils_1.createTypeOpAttr('Tperm', 'int32')];\n    return this.executeSingleOutput('Transpose', opAttrs, [x, permTensor]);\n  };\n\n  NodeJSKernelBackend.prototype.gather = function (x, indices, axis) {\n    var axisTensor = tfjs_core_1.scalar(axis, 'int32');\n    var opAttrs = [op_utils_1.createTypeOpAttr('Tparams', x.dtype), op_utils_1.createTypeOpAttr('Tindices', indices.dtype), op_utils_1.createTypeOpAttr('Taxis', 'int32')];\n    return this.executeSingleOutput('GatherV2', opAttrs, [x, indices, axisTensor]);\n  };\n\n  NodeJSKernelBackend.prototype.gatherND = function (x, indices) {\n    var opAttrs = [op_utils_1.createTypeOpAttr('Tparams', x.dtype), op_utils_1.createTypeOpAttr('Tindices', 'int32')];\n    return this.executeSingleOutput('GatherNd', opAttrs, [x, indices]);\n  };\n\n  NodeJSKernelBackend.prototype.scatterND = function (indices, updates, shape) {\n    var opAttrs = [op_utils_1.createTypeOpAttr('T', updates.dtype), op_utils_1.createTypeOpAttr('Tindices', 'int32')];\n    var shapeTensor = tfjs_core_1.tensor1d(shape, 'int32');\n    return this.executeSingleOutput('ScatterNd', opAttrs, [indices, updates, shapeTensor]);\n  };\n\n  NodeJSKernelBackend.prototype.batchToSpaceND = function (x, blockShape, crops) {\n    var blockShapeTensor = tfjs_core_1.tensor1d(blockShape, 'int32');\n    var cropsTensor = tfjs_core_1.tensor2d(crops, [crops.length, crops[0].length], 'int32');\n    var opAttrs = [op_utils_1.createTypeOpAttr('T', x.dtype), op_utils_1.createTypeOpAttr('Tblock_shape', 'int32'), op_utils_1.createTypeOpAttr('Tcrops', cropsTensor.dtype)];\n    return this.executeSingleOutput('BatchToSpaceND', opAttrs, [x, blockShapeTensor, cropsTensor]);\n  };\n\n  NodeJSKernelBackend.prototype.spaceToBatchND = function (x, blockShape, paddings) {\n    var blockShapeTensor = tfjs_core_1.tensor1d(blockShape, 'int32');\n    var paddingsTensor = tfjs_core_1.tensor2d(paddings, [paddings.length, paddings[0].length], 'int32');\n    var opAttrs = [op_utils_1.createTypeOpAttr('T', x.dtype), op_utils_1.createTypeOpAttr('Tblock_shape', 'int32'), op_utils_1.createTypeOpAttr('Tpaddings', paddingsTensor.dtype)];\n    return this.executeSingleOutput('SpaceToBatchND', opAttrs, [x, blockShapeTensor, paddingsTensor]);\n  };\n\n  NodeJSKernelBackend.prototype.resizeBilinear = function (x, newHeight, newWidth, alignCorners) {\n    var opAttrs = [op_utils_1.createTypeOpAttr('T', x.dtype), {\n      name: 'align_corners',\n      type: this.binding.TF_ATTR_BOOL,\n      value: alignCorners\n    }];\n    var size = tfjs_core_1.tensor1d([newHeight, newWidth], 'int32');\n    return this.executeSingleOutput('ResizeBilinear', opAttrs, [x, size]);\n  };\n\n  NodeJSKernelBackend.prototype.resizeBilinearBackprop = function (dy, x, alignCorners) {\n    var opAttrs = [op_utils_1.createTypeOpAttr('T', x.dtype), {\n      name: 'align_corners',\n      type: this.binding.TF_ATTR_BOOL,\n      value: alignCorners\n    }];\n    return this.executeSingleOutput('ResizeBilinearGrad', opAttrs, [dy, x]);\n  };\n\n  NodeJSKernelBackend.prototype.resizeNearestNeighbor = function (x, newHeight, newWidth, alignCorners) {\n    var opAttrs = [op_utils_1.createTypeOpAttr('T', x.dtype), {\n      name: 'align_corners',\n      type: this.binding.TF_ATTR_BOOL,\n      value: alignCorners\n    }];\n    var size = tfjs_core_1.tensor1d([newHeight, newWidth], 'int32');\n    return this.executeSingleOutput('ResizeNearestNeighbor', opAttrs, [x, size]);\n  };\n\n  NodeJSKernelBackend.prototype.resizeNearestNeighborBackprop = function (dy, x, alignCorners) {\n    var opAttrs = [op_utils_1.createTypeOpAttr('T', x.dtype), {\n      name: 'align_corners',\n      type: this.binding.TF_ATTR_BOOL,\n      value: alignCorners\n    }];\n    var _a = x.shape,\n        origHeight = _a[1],\n        origWidth = _a[2];\n    var size = tfjs_core_1.tensor1d([origHeight, origWidth], 'int32');\n    return this.executeSingleOutput('ResizeNearestNeighborGrad', opAttrs, [dy, size]);\n  };\n\n  NodeJSKernelBackend.prototype.batchNormalization = function (x, mean, variance, varianceEpsilon, scale, offset) {\n    if (mean.rank > 1) {\n      // Fused batch norm doesn't work with high-dim mean/var/scale/offset.\n      var inv = tfjs_core_1.rsqrt(variance.add(tfjs_core_1.scalar(varianceEpsilon)));\n\n      if (scale != null) {\n        inv = inv.mul(scale);\n      }\n\n      var xNorm = x.sub(mean).mul(inv);\n      return offset != null ? xNorm.add(offset) : xNorm;\n    }\n\n    var dataFormat = 'NHWC';\n    var depth = x.shape[3];\n    var opAttrs = [op_utils_1.createTypeOpAttr('T', x.dtype), {\n      name: 'epsilon',\n      type: this.binding.TF_ATTR_FLOAT,\n      value: varianceEpsilon\n    }, {\n      name: 'data_format',\n      type: this.binding.TF_ATTR_STRING,\n      value: dataFormat\n    }, {\n      name: 'is_training',\n      type: this.binding.TF_ATTR_BOOL,\n      value: false\n    }];\n    var numOutputs = 5;\n\n    if (scale == null) {\n      scale = tfjs_core_1.fill([depth], 1);\n    }\n\n    if (offset == null) {\n      offset = tfjs_core_1.fill([depth], 0);\n    }\n\n    return this.executeMultipleOutputs('FusedBatchNorm', opAttrs, [x, scale, offset, mean, variance], numOutputs)[0];\n  };\n\n  NodeJSKernelBackend.prototype.localResponseNormalization4D = function (x, radius, bias, alpha, beta) {\n    var opAttrs = [op_utils_1.createTypeOpAttr('T', x.dtype), {\n      name: 'depth_radius',\n      type: this.binding.TF_ATTR_INT,\n      value: radius\n    }, {\n      name: 'bias',\n      type: this.binding.TF_ATTR_FLOAT,\n      value: bias\n    }, {\n      name: 'alpha',\n      type: this.binding.TF_ATTR_FLOAT,\n      value: alpha\n    }, {\n      name: 'beta',\n      type: this.binding.TF_ATTR_FLOAT,\n      value: beta\n    }];\n    return this.executeSingleOutput('LRN', opAttrs, [x]);\n  };\n\n  NodeJSKernelBackend.prototype.LRNGrad = function (dy, inputImage, outputImage, radius, bias, alpha, beta) {\n    var opAttrs = [op_utils_1.createTypeOpAttr('T', dy.dtype), {\n      name: 'depth_radius',\n      type: this.binding.TF_ATTR_INT,\n      value: radius\n    }, {\n      name: 'bias',\n      type: this.binding.TF_ATTR_FLOAT,\n      value: bias\n    }, {\n      name: 'alpha',\n      type: this.binding.TF_ATTR_FLOAT,\n      value: alpha\n    }, {\n      name: 'beta',\n      type: this.binding.TF_ATTR_FLOAT,\n      value: beta\n    }];\n    return this.executeSingleOutput('LRNGrad', opAttrs, [dy, inputImage, outputImage]);\n  };\n\n  NodeJSKernelBackend.prototype.multinomial = function (logits, normalized, numSamples, seed) {\n    if (normalized) {\n      throw new Error('TF Node backend does not support normalized logits ' + 'passed to multinomial');\n    }\n\n    var opAttrs = [op_utils_1.createTypeOpAttr('T', logits.dtype), op_utils_1.createTypeOpAttr('output_dtype', 'int32'), {\n      name: 'seed',\n      type: this.binding.TF_ATTR_INT,\n      value: seed\n    }, {\n      name: 'seed2',\n      type: this.binding.TF_ATTR_INT,\n      value: seed * seed\n    }];\n    return this.executeSingleOutput('Multinomial', opAttrs, [logits, tfjs_core_1.scalar(numSamples, 'int32')]);\n  };\n\n  NodeJSKernelBackend.prototype.oneHot = function (indices, depth, onValue, offValue) {\n    var depthTensor = tfjs_core_1.scalar(depth, 'int32');\n    var onValueTensor = tfjs_core_1.scalar(onValue, 'int32');\n    var offValueTensor = tfjs_core_1.scalar(offValue, 'int32');\n    var opAttrs = [{\n      name: 'axis',\n      type: this.binding.TF_ATTR_INT,\n      value: -1\n    }, op_utils_1.createTypeOpAttr('T', indices.dtype), op_utils_1.createTypeOpAttr('TI', indices.dtype)];\n    return this.executeSingleOutput('OneHot', opAttrs, [indices, depthTensor, onValueTensor, offValueTensor]);\n  };\n\n  NodeJSKernelBackend.prototype.cumsum = function (x, axis, exclusive, reverse) {\n    var axisTensor = tfjs_core_1.scalar(axis, 'int32');\n    var opAttrs = [{\n      name: 'exclusive',\n      type: this.binding.TF_ATTR_BOOL,\n      value: exclusive\n    }, {\n      name: 'reverse',\n      type: this.binding.TF_ATTR_BOOL,\n      value: reverse\n    }, op_utils_1.createTypeOpAttr('T', x.dtype), op_utils_1.createTypeOpAttr('Tidx', 'int32')];\n    return this.executeSingleOutput('Cumsum', opAttrs, [x, axisTensor]);\n  };\n\n  NodeJSKernelBackend.prototype.nonMaxSuppression = function (boxes, scores, maxOutputSize, iouThreshold, scoreThreshold) {\n    var opAttrs = [op_utils_1.createTypeOpAttr('T', boxes.dtype)];\n    var maxOutputSizeTensor = tfjs_core_1.scalar(maxOutputSize, 'int32');\n    var iouThresholdTensor = tfjs_core_1.scalar(iouThreshold);\n    var scoreThresholdTensor = tfjs_core_1.scalar(scoreThreshold);\n    return this.executeSingleOutput('NonMaxSuppressionV3', opAttrs, [boxes, scores, maxOutputSizeTensor, iouThresholdTensor, scoreThresholdTensor]);\n  };\n\n  NodeJSKernelBackend.prototype.fft = function (x) {\n    var opAttrs = [op_utils_1.createTypeOpAttr('Tcomplex', x.dtype)];\n    return this.executeSingleOutput('FFT', opAttrs, [x]);\n  };\n\n  NodeJSKernelBackend.prototype.ifft = function (x) {\n    var opAttrs = [op_utils_1.createTypeOpAttr('Tcomplex', x.dtype)];\n    return this.executeSingleOutput('IFFT', opAttrs, [x]);\n  };\n\n  NodeJSKernelBackend.prototype.complex = function (real, imag) {\n    var opAttrs = [op_utils_1.createTensorsTypeOpAttr('T', real), {\n      name: 'Tout',\n      type: this.binding.TF_ATTR_TYPE,\n      value: this.binding.TF_COMPLEX64\n    }];\n    var inputs = [real, imag];\n    return this.executeSingleOutput('Complex', opAttrs, inputs);\n  };\n\n  NodeJSKernelBackend.prototype.real = function (input) {\n    var opAttrs = [op_utils_1.createTensorsTypeOpAttr('T', input), {\n      name: 'Tout',\n      type: this.binding.TF_ATTR_TYPE,\n      value: this.binding.TF_FLOAT\n    }];\n    var inputs = [input];\n    return this.executeSingleOutput('Real', opAttrs, inputs);\n  };\n\n  NodeJSKernelBackend.prototype.imag = function (input) {\n    var opAttrs = [{\n      name: 'T',\n      type: this.binding.TF_ATTR_TYPE,\n      value: this.binding.TF_COMPLEX64\n    }, {\n      name: 'Tout',\n      type: this.binding.TF_ATTR_TYPE,\n      value: this.binding.TF_FLOAT\n    }];\n    var inputs = [input];\n    return this.executeSingleOutput('Imag', opAttrs, inputs);\n  };\n\n  NodeJSKernelBackend.prototype.cropAndResize = function (image, boxes, boxIndex, cropSize, method, extrapolationValue) {\n    var opAttrs = [op_utils_1.createTypeOpAttr('T', image.dtype), {\n      name: 'method',\n      type: this.binding.TF_ATTR_STRING,\n      value: method\n    }, {\n      name: 'extrapolation_value',\n      type: this.binding.TF_ATTR_FLOAT,\n      value: extrapolationValue\n    }];\n    var cropSizeTensor = tfjs_core_1.tensor1d(cropSize, 'int32');\n    return this.executeSingleOutput('CropAndResize', opAttrs, [image, boxes, boxIndex, cropSizeTensor]);\n  };\n\n  NodeJSKernelBackend.prototype.depthToSpace = function (x, blockSize, dataFormat) {\n    var opAttrs = [op_utils_1.createTensorsTypeOpAttr('T', x), {\n      name: 'block_size',\n      type: this.binding.TF_ATTR_INT,\n      value: blockSize < 2 ? 2 : blockSize\n    }, {\n      name: 'data_format',\n      type: this.binding.TF_ATTR_STRING,\n      value: dataFormat\n    }];\n    var inputs = [x];\n    return this.executeSingleOutput('DepthToSpace', opAttrs, inputs);\n  };\n\n  NodeJSKernelBackend.prototype.split = function (value, sizeSplits, axis) {\n    var opAttrs = [{\n      name: 'num_split',\n      type: this.binding.TF_ATTR_INT,\n      value: sizeSplits.length\n    }, op_utils_1.createTensorsTypeOpAttr('T', value), {\n      name: 'Tlen',\n      type: this.binding.TF_ATTR_TYPE,\n      value: this.binding.TF_INT32\n    }];\n    var inputs = [value];\n    inputs.push(tfjs_core_1.tensor1d(sizeSplits, 'int32'));\n    inputs.push(tfjs_core_1.scalar(axis, 'int32'));\n    return this.executeMultipleOutputs('SplitV', opAttrs, inputs, sizeSplits.length);\n  };\n\n  NodeJSKernelBackend.prototype.sparseToDense = function (sparseIndices, sparseValues, outputShape, defaultValue) {\n    var opAttrs = [{\n      name: 'validate_indices',\n      type: this.binding.TF_ATTR_BOOL,\n      value: true\n    }, op_utils_1.createTypeOpAttr('T', sparseValues.dtype), op_utils_1.createTypeOpAttr('Tindices', sparseIndices.dtype)];\n    var outputShapeTensor = tfjs_core_1.tensor1d(outputShape, 'int32');\n    return this.executeSingleOutput('SparseToDense', opAttrs, [sparseIndices, outputShapeTensor, sparseValues, defaultValue]);\n  };\n\n  NodeJSKernelBackend.prototype.linspace = function (start, stop, num) {\n    var opAttrs = [op_utils_1.createTypeOpAttr('T', 'float32'), op_utils_1.createTypeOpAttr('Tidx', 'int32')];\n    var inputs = [tfjs_core_1.scalar(start, 'float32'), tfjs_core_1.scalar(stop, 'float32'), tfjs_core_1.scalar(num, 'int32')];\n    return this.executeSingleOutput('LinSpace', opAttrs, inputs);\n  };\n\n  NodeJSKernelBackend.prototype.fromPixels = function (pixels, numChannels) {\n    if (pixels == null) {\n      throw new Error('pixels passed to fromPixels() can not be null');\n    } // tslint:disable-next-line:no-any\n\n\n    if (pixels.getContext == null) {\n      throw new Error('When running in node, pixels must be an HTMLCanvasElement ' + 'like the one returned by the `canvas` npm package');\n    }\n\n    var vals = // tslint:disable-next-line:no-any\n    pixels.getContext('2d').getImageData(0, 0, pixels.width, pixels.height).data;\n    var values;\n\n    if (numChannels === 4) {\n      values = new Int32Array(vals);\n    } else {\n      var numPixels = pixels.width * pixels.height;\n      values = new Int32Array(numPixels * numChannels);\n\n      for (var i = 0; i < numPixels; i++) {\n        for (var channel = 0; channel < numChannels; ++channel) {\n          values[i * numChannels + channel] = vals[i * 4 + channel];\n        }\n      }\n    }\n\n    var outShape = [pixels.height, pixels.width, numChannels];\n    return tfjs_core_1.tensor3d(values, outShape, 'int32');\n  }; // ------------------------------------------------------------\n  // TensorBoard-related (tfjs-node-specific) backend kernels.\n\n\n  NodeJSKernelBackend.prototype.summaryWriter = function (logdir) {\n    var opAttrs = [{\n      name: 'shared_name',\n      type: this.binding.TF_ATTR_STRING,\n      value: \"logdir:\" + logdir\n    }, {\n      name: 'container',\n      type: this.binding.TF_ATTR_STRING,\n      value: ''\n    }];\n    var writerResource = this.executeSingleOutput('SummaryWriter', opAttrs, []);\n    return writerResource;\n  };\n\n  NodeJSKernelBackend.prototype.createSummaryFileWriter = function (resourceHandle, logdir, maxQueue, flushMillis, filenameSuffix) {\n    var inputArgs = [resourceHandle, tfjs_core_1.scalar(logdir), tfjs_core_1.scalar(maxQueue == null ? 10 : maxQueue, 'int32'), tfjs_core_1.scalar(flushMillis == null ? 2 * 60 * 1000 : flushMillis, 'int32'), tfjs_core_1.scalar(filenameSuffix == null ? '.v2' : filenameSuffix)];\n    this.executeMultipleOutputs('CreateSummaryFileWriter', [], inputArgs, 0);\n  };\n\n  NodeJSKernelBackend.prototype.writeScalarSummary = function (resourceHandle, step, name, value) {\n    var _this = this;\n\n    tfjs_core_1.tidy(function () {\n      tfjs_core_1.util.assert(Number.isInteger(step), function () {\n        return \"step is expected to be an integer, but is instead \" + step;\n      });\n      var inputArgs = [resourceHandle, new int64_tensors_1.Int64Scalar(step), tfjs_core_1.scalar(name, 'string')];\n      var typeAttr;\n\n      if (typeof value === 'number') {\n        inputArgs.push(tfjs_core_1.scalar(value));\n        typeAttr = _this.binding.TF_FLOAT;\n      } else {\n        // `value` is a Scalar.\n        tfjs_core_1.util.assert(value.rank === 0, function () {\n          return \"A non-scalar tensor (rank \" + value.rank + \") is passed to \" + \"writeScalarSummary()\";\n        });\n        inputArgs.push(value);\n        typeAttr = _this.typeAttributeFromTensor(value);\n      }\n\n      var opAttrs = [{\n        name: 'T',\n        type: _this.binding.TF_ATTR_TYPE,\n        value: typeAttr\n      }];\n\n      _this.binding.executeOp('WriteScalarSummary', opAttrs, _this.getInputTensorIds(inputArgs), 0);\n    });\n  };\n\n  NodeJSKernelBackend.prototype.flushSummaryWriter = function (resourceHandle) {\n    var inputArgs = [resourceHandle];\n    this.executeMultipleOutputs('FlushSummaryWriter', [], inputArgs, 0);\n  }; // ~ TensorBoard-related (tfjs-node-specific) backend kernels.\n  // ------------------------------------------------------------\n\n\n  NodeJSKernelBackend.prototype.memory = function () {\n    // Due to automatic garbage collection, the numbers are unreliable.\n    // TODO(kreeger): Since there is finalization in C, count the true\n    // number of undisposed tensors.\n    return {\n      unreliable: true\n    };\n  };\n\n  NodeJSKernelBackend.prototype.time = function (f) {\n    return __awaiter(this, void 0, void 0, function () {\n      var start, elapsed;\n      return __generator(this, function (_a) {\n        start = process.hrtime();\n        f();\n        elapsed = process.hrtime(start);\n        return [2\n        /*return*/\n        , {\n          kernelMs: elapsed[0] * 1000 + elapsed[1] / 1000000\n        }];\n      });\n    });\n  };\n\n  return NodeJSKernelBackend;\n}(tfjs_core_1.KernelBackend);\n\nexports.NodeJSKernelBackend = NodeJSKernelBackend;","map":null,"metadata":{},"sourceType":"script"}