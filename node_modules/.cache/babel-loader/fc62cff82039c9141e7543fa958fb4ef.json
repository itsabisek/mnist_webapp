{"ast":null,"code":"\"use strict\";\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {\n    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  }\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar doc_1 = require(\"../doc\");\n\nvar environment_1 = require(\"../environment\");\n\nvar util = require(\"../util\");\n\nvar operation_1 = require(\"./operation\");\n\nvar MatmulOps = function () {\n  function MatmulOps() {}\n\n  MatmulOps.matMul = function (a, b, transposeA, transposeB) {\n    if (transposeA === void 0) {\n      transposeA = false;\n    }\n\n    if (transposeB === void 0) {\n      transposeB = false;\n    }\n\n    util.assertArgumentsAreTensors({\n      a: a,\n      b: b\n    }, 'matMul');\n    var innerShapeA = transposeA ? a.shape[0] : a.shape[1];\n    var innerShapeB = transposeB ? b.shape[1] : b.shape[0];\n    util.assert(a.rank === 2 && b.rank === 2, \"Error in matMul: inputs must be rank 2, got ranks \" + a.rank + (\" and \" + b.rank + \".\"));\n    util.assert(innerShapeA === innerShapeB, \"Error in matMul: inner shapes (\" + innerShapeA + \") and (\" + (innerShapeB + \") of Tensors with shapes \" + a.shape + \" and \") + (b.shape + \" and transposeA=\" + transposeA) + (\" and transposeB=\" + transposeB + \" must match.\"));\n\n    var grad = function grad(dy) {\n      if (!transposeA && !transposeB) {\n        return {\n          a: function a() {\n            return dy.matMul(b.toFloat(), false, true);\n          },\n          b: function b() {\n            return a.toFloat().matMul(dy, true, false);\n          }\n        };\n      } else if (!transposeA && transposeB) {\n        return {\n          a: function a() {\n            return dy.matMul(b.toFloat(), false, false);\n          },\n          b: function b() {\n            return dy.matMul(a.toFloat(), true, false);\n          }\n        };\n      } else if (transposeA && !transposeB) {\n        return {\n          a: function a() {\n            return b.toFloat().matMul(dy, false, true);\n          },\n          b: function b() {\n            return a.toFloat().matMul(dy, false, false);\n          }\n        };\n      } else {\n        return {\n          a: function a() {\n            return b.toFloat().matMul(dy, true, true);\n          },\n          b: function b() {\n            return dy.matMul(a.toFloat(), true, true);\n          }\n        };\n      }\n    };\n\n    return environment_1.ENV.engine.runKernel(function (backend) {\n      return backend.matMul(a, b, transposeA, transposeB);\n    }, {\n      a: a,\n      b: b\n    }, grad);\n  };\n\n  MatmulOps.vectorTimesMatrix = function (v, matrix) {\n    util.assert(v.rank === 1, \"Error in vectorTimesMatrix: first input must be rank 1, but got \" + (\"rank \" + v.rank + \".\"));\n    util.assert(matrix.rank === 2, \"Error in vectorTimesMatrix: second input must be rank 2, but got \" + (\"rank \" + matrix.rank + \".\"));\n    util.assert(v.size === matrix.shape[0], \"Error in vectorTimesMatrix: size of vector (\" + v.size + \") \" + (\"must match first dimension of matrix (\" + matrix.shape[0] + \")\"));\n    return v.as2D(1, -1).matMul(matrix).as1D();\n  };\n\n  MatmulOps.matrixTimesVector = function (matrix, v) {\n    util.assert(v.rank === 1, \"Error in matrixTimesVector: second input must rank 1, but got \" + (\"rank \" + v.rank + \".\"));\n    util.assert(matrix.rank === 2, \"Error in matrixTimesVector: first input must be a rank 2, but got \" + (\"rank \" + matrix.rank + \".\"));\n    util.assert(v.size === matrix.shape[1], \"Error in matrixTimesVector: size of first rank 1 input \" + v.size + \" \" + \"must match inner dimension of second rank 2 input, but got \" + (\"shape \" + matrix.shape + \".\"));\n    return matrix.matMul(v.as2D(-1, 1)).as1D();\n  };\n\n  MatmulOps.dotProduct = function (v1, v2) {\n    util.assert(v1.rank === 1 && v2.rank === 1, \"Error in dotProduct: inputs must be rank 1, but got ranks \" + (v1.rank + \" and \" + v2.rank + \".\"));\n    util.assert(v1.size === v2.size, \"Error in dotProduct: size of inputs (\" + v1.size + \") and (\" + (v2.size + \") must match.\"));\n    return v1.as2D(1, -1).matMul(v2.as2D(-1, 1)).asScalar();\n  };\n\n  MatmulOps.outerProduct = function (v1, v2) {\n    util.assert(v1.rank === 1 && v2.rank === 1, \"Error in outerProduct: inputs must be rank 1, but got ranks \" + (v1.rank + \" and \" + v2.rank + \".\"));\n    return v1.as2D(-1, 1).matMul(v2.as2D(1, -1));\n  };\n\n  __decorate([doc_1.doc({\n    heading: 'Operations',\n    subheading: 'Matrices'\n  }), operation_1.operation], MatmulOps, \"matMul\", null);\n\n  __decorate([operation_1.operation], MatmulOps, \"vectorTimesMatrix\", null);\n\n  __decorate([operation_1.operation], MatmulOps, \"matrixTimesVector\", null);\n\n  __decorate([operation_1.operation], MatmulOps, \"dotProduct\", null);\n\n  __decorate([doc_1.doc({\n    heading: 'Operations',\n    subheading: 'Matrices'\n  }), operation_1.operation], MatmulOps, \"outerProduct\", null);\n\n  return MatmulOps;\n}();\n\nexports.MatmulOps = MatmulOps;","map":null,"metadata":{},"sourceType":"script"}