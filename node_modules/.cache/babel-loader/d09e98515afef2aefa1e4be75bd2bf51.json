{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar environment_1 = require(\"../../environment\");\n\nvar util = require(\"../../util\");\n\nvar shader_compiler = require(\"./shader_compiler\");\n\nvar NAN_UNIFORM_NAME = 'NaN';\n\nfunction shouldUploadNaNUniform() {\n  return !environment_1.ENV.get('WEBGL_FLOAT_TEXTURE_ENABLED');\n}\n\nfunction compileProgram(gpgpu, program, inputs, output) {\n  var userCode = program.userCode;\n  var inputInfos = inputs.map(function (input, i) {\n    var shapeInfo = {\n      logicalShape: input.tensor.shape,\n      texShape: input.texData.texShape\n    };\n    return {\n      name: program.variableNames[i],\n      shapeInfo: shapeInfo\n    };\n  });\n  var inShapeInfos = inputInfos.map(function (x) {\n    return x.shapeInfo;\n  });\n  var outShapeInfo = {\n    logicalShape: output.tensor.shape,\n    texShape: output.texData.texShape\n  };\n  var source = shader_compiler.makeShader(inputInfos, outShapeInfo, userCode, program.supportsBroadcasting === true);\n  var webGLProgram = gpgpu.createProgram(source);\n  var uniformLocations = {};\n\n  for (var i = 0; i < program.variableNames.length; i++) {\n    var uniformName = program.variableNames[i];\n    uniformLocations[uniformName] = gpgpu.getUniformLocation(webGLProgram, uniformName);\n  }\n\n  if (shouldUploadNaNUniform()) {\n    var throwIfNaNUniformIsNotUsed = false;\n    uniformLocations[NAN_UNIFORM_NAME] = gpgpu.getUniformLocation(webGLProgram, NAN_UNIFORM_NAME, throwIfNaNUniformIsNotUsed);\n  }\n\n  return {\n    program: program,\n    source: source,\n    webGLProgram: webGLProgram,\n    uniformLocations: uniformLocations,\n    gpgpu: gpgpu,\n    inShapeInfos: inShapeInfos,\n    outShapeInfo: outShapeInfo\n  };\n}\n\nexports.compileProgram = compileProgram;\n\nfunction validateBinaryAndProgram(shapeInfos, inputs) {\n  if (shapeInfos.length !== inputs.length) {\n    throw Error(\"Binary was compiled with \" + shapeInfos.length + \" inputs, but \" + (\"was executed with \" + inputs.length + \" inputs\"));\n  }\n\n  shapeInfos.forEach(function (s, i) {\n    var shapeA = s.logicalShape;\n    var texShapeA = s.texShape;\n    var shapeB = inputs[i].tensor.shape;\n    var texShapeB = inputs[i].texData.texShape;\n\n    if (!util.arraysEqual(shapeA, shapeB)) {\n      throw Error(\"Binary was compiled with different shapes than \" + (\"the current args. Shapes \" + shapeA + \" and \" + shapeB + \" must match\"));\n    }\n\n    if (!util.arraysEqual(texShapeA, texShapeB)) {\n      throw Error(\"Binary was compiled with different texture shapes than the\" + (\" current args. Shape \" + texShapeA + \" and \" + texShapeB + \" must match\"));\n    }\n  });\n}\n\nfunction runProgram(binary, inputs, output, customSetup) {\n  validateBinaryAndProgram(binary.inShapeInfos, inputs);\n  validateBinaryAndProgram([binary.outShapeInfo], [output]);\n  var outTex = output.texData.texture;\n  var outTexShape = output.texData.texShape;\n  var gpgpu = binary.gpgpu;\n  gpgpu.setOutputMatrixTexture(outTex, outTexShape[0], outTexShape[1]);\n  gpgpu.setProgram(binary.webGLProgram);\n  inputs.forEach(function (input, i) {\n    var tex = input.texData.texture;\n    var variableName = binary.program.variableNames[i];\n    var variableUniformLocation = binary.uniformLocations[variableName];\n    gpgpu.setInputMatrixTexture(tex, variableUniformLocation, i);\n  });\n\n  if (shouldUploadNaNUniform()) {\n    gpgpu.gl.uniform1f(binary.uniformLocations[NAN_UNIFORM_NAME], NaN);\n  }\n\n  if (customSetup != null) {\n    customSetup(gpgpu, binary.webGLProgram);\n  }\n\n  gpgpu.executeProgram();\n}\n\nexports.runProgram = runProgram;\n\nfunction makeShaderKey(program, inputs, output) {\n  var keyInputs = '';\n  inputs.concat(output).forEach(function (x) {\n    keyInputs += x.tensor.shape + \"_\" + x.texData.texShape;\n  });\n  var keyUserCode = program.userCode;\n  var keyBroadcast = (program.supportsBroadcasting === true).toString();\n  var key = program.constructor.name;\n  key += '_' + keyBroadcast + '_' + keyInputs + '_' + keyUserCode;\n  return key;\n}\n\nexports.makeShaderKey = makeShaderKey;","map":null,"metadata":{},"sourceType":"script"}