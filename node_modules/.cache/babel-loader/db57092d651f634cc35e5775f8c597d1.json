{"ast":null,"code":"\"use strict\";\n/**\n * @license\n * Copyright 2018 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar tfc = require(\"@tensorflow/tfjs-core\");\n\nvar util_1 = require(\"util\");\n\nvar gBackend = null;\n/** Returns an instance of the Node.js backend. */\n\nfunction nodeBackend() {\n  if (gBackend === null) {\n    gBackend = tfc.findBackend('tensorflow');\n  }\n\n  return gBackend;\n}\n\nexports.nodeBackend = nodeBackend;\n/** Returns the TF dtype for a given DataType. */\n\nfunction getTFDType(dataType) {\n  var binding = nodeBackend().binding;\n\n  switch (dataType) {\n    case 'float32':\n      return binding.TF_FLOAT;\n\n    case 'int32':\n      return binding.TF_INT32;\n\n    case 'bool':\n      return binding.TF_BOOL;\n\n    case 'complex64':\n      return binding.TF_COMPLEX64;\n\n    case 'string':\n      return binding.TF_STRING;\n    // tslint:disable-next-line:no-any\n\n    case 'int64':\n      // int64 is not a generally supported dtype in TensorFlow.js\n      // (tfjs-core). However, it needs to be included here for the purpose of\n      // writing the `step` value to TensorBoard via WriteScalarSummary and\n      // other op kernels.\n      return binding.TF_INT64;\n\n    default:\n      var errorMessage = \"Unknown dtype: \" + dataType;\n      throw new Error(errorMessage);\n  }\n}\n\nexports.getTFDType = getTFDType;\n/**\n * Creates a TFEOpAttr for a 'type' OpDef attribute.\n * @deprecated Please use createTensorsTypeOpAttr() going forward.\n */\n\nfunction createTypeOpAttr(attrName, dtype) {\n  return {\n    name: attrName,\n    type: nodeBackend().binding.TF_ATTR_TYPE,\n    value: getTFDType(dtype)\n  };\n}\n\nexports.createTypeOpAttr = createTypeOpAttr;\n/**\n * Creates a TFEOpAttr for a 'type' OpDef attribute from a Tensor or list of\n * Tensors.\n */\n\nfunction createTensorsTypeOpAttr(attrName, tensors) {\n  if (util_1.isNullOrUndefined(tensors)) {\n    throw new Error('Invalid input tensors value.');\n  }\n\n  return {\n    name: attrName,\n    type: nodeBackend().binding.TF_ATTR_TYPE,\n    value: getTFDTypeForInputs(tensors)\n  };\n}\n\nexports.createTensorsTypeOpAttr = createTensorsTypeOpAttr;\n/** Returns the dtype number for a single or list of input Tensors. */\n\nfunction getTFDTypeForInputs(tensors) {\n  if (util_1.isNullOrUndefined(tensors)) {\n    throw new Error('Invalid input tensors value.');\n  }\n\n  if (util_1.isArray(tensors)) {\n    for (var i = 0; i < tensors.length; i++) {\n      return getTFDType(tensors[i].dtype);\n    }\n\n    return -1;\n  } else {\n    return getTFDType(tensors.dtype);\n  }\n}","map":null,"metadata":{},"sourceType":"script"}