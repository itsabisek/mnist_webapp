{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar errors_1 = require(\"../errors\");\n\nvar topology_1 = require(\"./topology\");\n\nfunction assertFeedCompatibility(key, val) {\n  if (key.dtype != null && key.dtype !== val.dtype) {\n    throw new errors_1.ValueError(\"The dtype of the feed (\" + val.dtype + \") is incompatible with that of \" + (\"the key '\" + key.name + \"' (\" + key.dtype + \").\"));\n  }\n\n  if (key.shape != null) {\n    if (key.shape.length !== val.shape.length) {\n      throw new errors_1.ValueError(\"The rank of feed (\" + val.shape.length + \") does not match the rank of \" + (\"the key (\" + key.shape.length + \").\"));\n    }\n\n    for (var i = 0; i < key.shape.length; ++i) {\n      if (key.shape[i] != null && key.shape[i] !== val.shape[i]) {\n        throw new errors_1.ValueError(\"The \" + i + \"-th dimension of the feed (\" + val.shape[i] + \") is \" + (\"incompatible with that of the key (\" + key.shape[i] + \").\"));\n      }\n    }\n  }\n}\n\nvar FeedDict = function () {\n  function FeedDict(feeds) {\n    this.id2Value = {};\n\n    if (feeds instanceof FeedDict) {\n      for (var id in feeds.id2Value) {\n        this.id2Value[id] = feeds.id2Value[id];\n      }\n    } else {\n      if (feeds == null) {\n        return;\n      }\n\n      for (var _i = 0, feeds_1 = feeds; _i < feeds_1.length; _i++) {\n        var feed = feeds_1[_i];\n        this.add(feed.key, feed.value);\n      }\n    }\n  }\n\n  FeedDict.prototype.add = function (key, value) {\n    assertFeedCompatibility(key, value);\n\n    if (this.id2Value[key.id] == null) {\n      this.id2Value[key.id] = value;\n    } else {\n      throw new errors_1.ValueError(\"Duplicate key: name=\" + key.name + \", id=\" + key.id);\n    }\n\n    return this;\n  };\n\n  FeedDict.prototype.addFeed = function (feed) {\n    this.add(feed.key, feed.value);\n  };\n\n  FeedDict.prototype.hasKey = function (key) {\n    return this.id2Value[key.id] != null;\n  };\n\n  FeedDict.prototype.getValue = function (key) {\n    if (this.id2Value[key.id] == null) {\n      throw new errors_1.ValueError(\"Nonexistent key: \" + JSON.stringify(key));\n    } else {\n      return this.id2Value[key.id];\n    }\n  };\n\n  return FeedDict;\n}();\n\nexports.FeedDict = FeedDict;\n\nfunction execute(fetches, feedDict, kwargs) {\n  var arrayFetches = Array.isArray(fetches);\n  var fetchArray = arrayFetches ? fetches : [fetches];\n  var outputs = [];\n  var internalFeedDict = new FeedDict(feedDict);\n\n  for (var _i = 0, fetchArray_1 = fetchArray; _i < fetchArray_1.length; _i++) {\n    var fetch_1 = fetchArray_1[_i];\n    outputs.push(executeInternal(fetch_1, internalFeedDict, kwargs));\n  }\n\n  return arrayFetches ? outputs : outputs[0];\n}\n\nexports.execute = execute;\n\nfunction executeInternal(fetch, internalFeedDict, kwargs) {\n  if (internalFeedDict.hasKey(fetch)) {\n    return internalFeedDict.getValue(fetch);\n  }\n\n  if (fetch.sourceLayer instanceof topology_1.InputLayer) {\n    throw new errors_1.ValueError(\"Missing a feed value for SymbolicTensor from InputLayer \" + (\"'\" + topology_1.InputLayer.name + \"'\"));\n  }\n\n  var inputs = fetch.inputs;\n  var inputValues = [];\n\n  for (var _i = 0, inputs_1 = inputs; _i < inputs_1.length; _i++) {\n    var input = inputs_1[_i];\n    var inputVal = executeInternal(input, internalFeedDict, kwargs);\n    inputValues.push(inputVal);\n  }\n\n  var output = fetch.sourceLayer.apply(inputValues, kwargs);\n\n  if (!Array.isArray(output)) {\n    output = [output];\n  }\n\n  var layerOutputs = getNodeOutputs(fetch);\n  var outputSymbolicTensors = Array.isArray(layerOutputs) ? layerOutputs : [layerOutputs];\n\n  for (var i = 0; i < outputSymbolicTensors.length; ++i) {\n    internalFeedDict.add(outputSymbolicTensors[i], output[i]);\n  }\n\n  return output.length === 1 ? output[0] : output[fetch.outputTensorIndex];\n}\n\nfunction getNodeOutputs(fetch) {\n  var layerOutputs;\n\n  if (fetch.sourceLayer.inboundNodes.length === 1) {\n    layerOutputs = fetch.sourceLayer.output;\n  } else {\n    var nodeIndex = null;\n\n    for (var i = 0; i < fetch.sourceLayer.inboundNodes.length; ++i) {\n      for (var _i = 0, _a = fetch.sourceLayer.inboundNodes[i].outputTensors; _i < _a.length; _i++) {\n        var outputTensor = _a[_i];\n\n        if (outputTensor.id === fetch.id) {\n          nodeIndex = i;\n          break;\n        }\n      }\n    }\n\n    layerOutputs = fetch.sourceLayer.getOutputAt(nodeIndex);\n  }\n\n  return layerOutputs;\n}","map":null,"metadata":{},"sourceType":"script"}