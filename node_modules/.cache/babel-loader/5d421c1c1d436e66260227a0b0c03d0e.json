{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar tensor_1 = require(\"./tensor\");\n\nfunction assertArgumentIsTensor(x, argName, functionName) {\n  assert(x instanceof tensor_1.Tensor, \"Argument '\" + argName + \"' passed to '\" + functionName + \"' must be a Tensor, \" + (\"but got \" + typeof x + \".\"));\n}\n\nfunction assertArgumentsAreTensors(args, functionName) {\n  var _loop_1 = function _loop_1(argName) {\n    var arg = args[argName];\n\n    if (Array.isArray(arg)) {\n      arg.forEach(function (t, i) {\n        assertArgumentIsTensor(t, argName + \"[\" + i + \"]\", functionName);\n      });\n    } else {\n      assertArgumentIsTensor(arg, argName, functionName);\n    }\n  };\n\n  for (var argName in args) {\n    _loop_1(argName);\n  }\n}\n\nexports.assertArgumentsAreTensors = assertArgumentsAreTensors;\n\nfunction shuffle(array) {\n  var counter = array.length;\n  var temp = 0;\n  var index = 0;\n\n  while (counter > 0) {\n    index = Math.random() * counter | 0;\n    counter--;\n    temp = array[counter];\n    array[counter] = array[index];\n    array[index] = temp;\n  }\n}\n\nexports.shuffle = shuffle;\n\nfunction clamp(min, x, max) {\n  return Math.max(min, Math.min(x, max));\n}\n\nexports.clamp = clamp;\n\nfunction randUniform(a, b) {\n  return Math.random() * (b - a) + a;\n}\n\nexports.randUniform = randUniform;\n\nfunction distSquared(a, b) {\n  var result = 0;\n\n  for (var i = 0; i < a.length; i++) {\n    var diff = Number(a[i]) - Number(b[i]);\n    result += diff * diff;\n  }\n\n  return result;\n}\n\nexports.distSquared = distSquared;\n\nfunction assert(expr, msg) {\n  if (!expr) {\n    throw new Error(msg);\n  }\n}\n\nexports.assert = assert;\n\nfunction assertShapesMatch(shapeA, shapeB, errorMessagePrefix) {\n  if (errorMessagePrefix === void 0) {\n    errorMessagePrefix = '';\n  }\n\n  assert(arraysEqual(shapeA, shapeB), errorMessagePrefix + (\" Shapes \" + shapeA + \" and \" + shapeB + \" must match\"));\n}\n\nexports.assertShapesMatch = assertShapesMatch;\n\nfunction assertTypesMatch(a, b) {\n  assert(a.dtype === b.dtype, \" The dtypes of the first(\" + a.dtype + \") and\" + (\" second(\" + b.dtype + \") input must match\"));\n}\n\nexports.assertTypesMatch = assertTypesMatch;\n\nfunction flatten(arr, ret) {\n  if (ret === void 0) {\n    ret = [];\n  }\n\n  if (Array.isArray(arr)) {\n    for (var i = 0; i < arr.length; ++i) {\n      flatten(arr[i], ret);\n    }\n  } else {\n    ret.push(arr);\n  }\n\n  return ret;\n}\n\nexports.flatten = flatten;\n\nfunction inferShape(val) {\n  if (isTypedArray(val)) {\n    return [val.length];\n  }\n\n  if (!Array.isArray(val)) {\n    return [];\n  }\n\n  var shape = [];\n\n  while (val instanceof Array) {\n    shape.push(val.length);\n    val = val[0];\n  }\n\n  return shape;\n}\n\nexports.inferShape = inferShape;\n\nfunction sizeFromShape(shape) {\n  if (shape.length === 0) {\n    return 1;\n  }\n\n  var size = shape[0];\n\n  for (var i = 1; i < shape.length; i++) {\n    size *= shape[i];\n  }\n\n  return size;\n}\n\nexports.sizeFromShape = sizeFromShape;\n\nfunction isScalarShape(shape) {\n  return shape.length === 0;\n}\n\nexports.isScalarShape = isScalarShape;\n\nfunction arraysEqual(n1, n2) {\n  if (n1.length !== n2.length) {\n    return false;\n  }\n\n  for (var i = 0; i < n1.length; i++) {\n    if (n1[i] !== n2[i]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nexports.arraysEqual = arraysEqual;\n\nfunction isInt(a) {\n  return a % 1 === 0;\n}\n\nexports.isInt = isInt;\n\nfunction tanh(x) {\n  if (Math.tanh != null) {\n    return Math.tanh(x);\n  }\n\n  if (x === Infinity) {\n    return 1;\n  } else if (x === -Infinity) {\n    return -1;\n  } else {\n    var e2x = Math.exp(2 * x);\n    return (e2x - 1) / (e2x + 1);\n  }\n}\n\nexports.tanh = tanh;\n\nfunction sizeToSquarishShape(size) {\n  for (var a = Math.floor(Math.sqrt(size)); a > 1; --a) {\n    if (size % a === 0) {\n      return [a, size / a];\n    }\n  }\n\n  return [1, size];\n}\n\nexports.sizeToSquarishShape = sizeToSquarishShape;\n\nfunction createShuffledIndices(n) {\n  var shuffledIndices = new Uint32Array(n);\n\n  for (var i = 0; i < n; ++i) {\n    shuffledIndices[i] = i;\n  }\n\n  shuffle(shuffledIndices);\n  return shuffledIndices;\n}\n\nexports.createShuffledIndices = createShuffledIndices;\n\nfunction rightPad(a, size) {\n  if (size <= a.length) {\n    return a;\n  }\n\n  return a + ' '.repeat(size - a.length);\n}\n\nexports.rightPad = rightPad;\n\nfunction repeatedTry(checkFn, delayFn, maxCounter) {\n  if (delayFn === void 0) {\n    delayFn = function delayFn(counter) {\n      return 0;\n    };\n  }\n\n  return new Promise(function (resolve, reject) {\n    var tryCount = 0;\n\n    var tryFn = function tryFn() {\n      if (checkFn()) {\n        resolve();\n        return;\n      }\n\n      tryCount++;\n      var nextBackoff = delayFn(tryCount);\n\n      if (maxCounter != null && tryCount >= maxCounter) {\n        reject();\n        return;\n      }\n\n      setTimeout(tryFn, nextBackoff);\n    };\n\n    setTimeout(tryFn, 0);\n  });\n}\n\nexports.repeatedTry = repeatedTry;\n\nfunction getQueryParams(queryString) {\n  var params = {};\n  queryString.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g, function (s) {\n    var t = [];\n\n    for (var _i = 1; _i < arguments.length; _i++) {\n      t[_i - 1] = arguments[_i];\n    }\n\n    decodeParam(params, t[0], t[1]);\n    return t.join('=');\n  });\n  return params;\n}\n\nexports.getQueryParams = getQueryParams;\n\nfunction decodeParam(params, name, value) {\n  params[decodeURIComponent(name)] = decodeURIComponent(value || '');\n}\n\nfunction inferFromImplicitShape(shape, size) {\n  var shapeProd = 1;\n  var implicitIdx = -1;\n\n  for (var i = 0; i < shape.length; ++i) {\n    if (shape[i] > 0) {\n      shapeProd *= shape[i];\n    } else if (shape[i] === -1) {\n      if (implicitIdx !== -1) {\n        throw Error(\"Shapes can only have 1 implicit size. \" + (\"Found - 1 at dim \" + implicitIdx + \" and dim \" + i));\n      }\n\n      implicitIdx = i;\n    } else if (shape[i] <= 0) {\n      throw Error(\"Shapes can not be <= 0. Found \" + shape[i] + \" at dim \" + i);\n    }\n  }\n\n  if (implicitIdx === -1) {\n    if (size > 0 && size !== shapeProd) {\n      throw Error(\"Size(\" + size + \") must match the product of shape \" + shape);\n    }\n\n    return shape;\n  }\n\n  if (size % shapeProd !== 0) {\n    throw Error(\"The implicit shape can't be a fractional number. \" + (\"Got \" + size + \" / \" + shapeProd));\n  }\n\n  var newShape = shape.slice();\n  newShape[implicitIdx] = size / shapeProd;\n  return newShape;\n}\n\nexports.inferFromImplicitShape = inferFromImplicitShape;\n\nfunction squeezeShape(shape, axis) {\n  var newShape = [];\n  var keptDims = [];\n  var j = 0;\n\n  for (var i = 0; i < shape.length; ++i) {\n    if (axis != null) {\n      if (axis[j] === i && shape[i] > 1) {\n        throw new Error(\"Can't squeeze axis \" + i + \" since its dim '\" + shape[i] + \"' is not 1\");\n      }\n\n      if ((axis[j] == null || axis[j] > i) && shape[i] === 1) {\n        newShape.push(shape[i]);\n        keptDims.push(i);\n      }\n\n      if (axis[j] <= i) {\n        j++;\n      }\n    }\n\n    if (shape[i] > 1) {\n      newShape.push(shape[i]);\n      keptDims.push(i);\n    }\n  }\n\n  return {\n    newShape: newShape,\n    keptDims: keptDims\n  };\n}\n\nexports.squeezeShape = squeezeShape;\n\nfunction getTypedArrayFromDType(dtype, size) {\n  var values = null;\n\n  if (dtype == null || dtype === 'float32') {\n    values = new Float32Array(size);\n  } else if (dtype === 'int32') {\n    values = new Int32Array(size);\n  } else if (dtype === 'bool') {\n    values = new Uint8Array(size);\n  } else {\n    throw new Error(\"Unknown data type \" + dtype);\n  }\n\n  return values;\n}\n\nexports.getTypedArrayFromDType = getTypedArrayFromDType;\n\nfunction isTensorInList(tensor, tensorList) {\n  for (var i = 0; i < tensorList.length; i++) {\n    if (tensorList[i].id === tensor.id) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nexports.isTensorInList = isTensorInList;\n\nfunction checkForNaN(vals, dtype, name) {\n  if (dtype !== 'float32') {\n    return;\n  }\n\n  for (var i = 0; i < vals.length; i++) {\n    if (isNaN(vals[i])) {\n      throw Error(\"The result of the '\" + name + \"' has NaNs.\");\n    }\n  }\n}\n\nexports.checkForNaN = checkForNaN;\n\nfunction flattenNameArrayMap(nameArrayMap, keys) {\n  var xs = [];\n\n  if (nameArrayMap instanceof tensor_1.Tensor) {\n    xs.push(nameArrayMap);\n  } else {\n    var xMap = nameArrayMap;\n\n    for (var i = 0; i < keys.length; i++) {\n      xs.push(xMap[keys[i]]);\n    }\n  }\n\n  return xs;\n}\n\nexports.flattenNameArrayMap = flattenNameArrayMap;\n\nfunction unflattenToNameArrayMap(keys, flatArrays) {\n  if (keys.length !== flatArrays.length) {\n    throw new Error(\"Cannot unflatten Tensor[], keys and arrays are not of same length.\");\n  }\n\n  var result = {};\n\n  for (var i = 0; i < keys.length; i++) {\n    result[keys[i]] = flatArrays[i];\n  }\n\n  return result;\n}\n\nexports.unflattenToNameArrayMap = unflattenToNameArrayMap;\n\nfunction hasEncodingLoss(oldType, newType) {\n  if (newType === 'float32') {\n    return false;\n  }\n\n  if (newType === 'int32' && oldType !== 'float32') {\n    return false;\n  }\n\n  if (newType === 'bool' && oldType === 'bool') {\n    return false;\n  }\n\n  return true;\n}\n\nexports.hasEncodingLoss = hasEncodingLoss;\n\nfunction copyTypedArray(array, dtype) {\n  if (dtype == null || dtype === 'float32') {\n    return new Float32Array(array);\n  } else if (dtype === 'int32') {\n    return new Int32Array(array);\n  } else if (dtype === 'bool') {\n    var bool = new Uint8Array(array.length);\n\n    for (var i = 0; i < bool.length; ++i) {\n      if (Math.round(array[i]) !== 0) {\n        bool[i] = 1;\n      }\n    }\n\n    return bool;\n  } else {\n    throw new Error(\"Unknown data type \" + dtype);\n  }\n}\n\nexports.copyTypedArray = copyTypedArray;\n\nfunction isTypedArray(a) {\n  return a instanceof Float32Array || a instanceof Int32Array || a instanceof Uint8Array;\n}\n\nexports.isTypedArray = isTypedArray;\n\nfunction bytesPerElement(dtype) {\n  if (dtype === 'float32' || dtype === 'int32') {\n    return 4;\n  } else if (dtype === 'bool') {\n    return 1;\n  } else {\n    throw new Error(\"Unknown dtype \" + dtype);\n  }\n}\n\nexports.bytesPerElement = bytesPerElement;\n\nfunction isFunction(f) {\n  return !!(f && f.constructor && f.call && f.apply);\n}\n\nexports.isFunction = isFunction;\n\nfunction extractTensorsFromContainer(result) {\n  return extractTensorsFromAny(result);\n}\n\nexports.extractTensorsFromContainer = extractTensorsFromContainer;\n\nfunction extractTensorsFromAny(result) {\n  if (result == null) {\n    return [];\n  }\n\n  if (result instanceof tensor_1.Tensor) {\n    return [result];\n  }\n\n  var list = [];\n  var resultObj = result;\n\n  if (!isIterable(resultObj)) {\n    return [];\n  }\n\n  for (var k in resultObj) {\n    var sublist = flatten(resultObj[k]).filter(function (x) {\n      return x instanceof tensor_1.Tensor;\n    });\n    list.push.apply(list, sublist);\n  }\n\n  return list;\n}\n\nexports.extractTensorsFromAny = extractTensorsFromAny;\n\nfunction isIterable(obj) {\n  return Array.isArray(obj) || typeof obj === 'object';\n}","map":null,"metadata":{},"sourceType":"script"}