{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar util = require(\"./util\");\n\nvar FORMAT_LIMIT_NUM_VALS = 20;\nvar FORMAT_NUM_FIRST_LAST_VALS = 3;\nvar FORMAT_NUM_SIG_DIGITS = 7;\n\nfunction tensorToString(t, verbose) {\n  var vals = t.dataSync();\n  var padPerCol = computeMaxSizePerColumn(t);\n  var valsLines = subTensorToString(vals, t.shape, t.strides, padPerCol);\n  var lines = ['Tensor'];\n\n  if (verbose) {\n    lines.push(\"  dtype: \" + t.dtype);\n    lines.push(\"  rank: \" + t.rank);\n    lines.push(\"  shape: [\" + t.shape + \"]\");\n    lines.push(\"  values:\");\n  }\n\n  lines.push(valsLines.map(function (l) {\n    return '    ' + l;\n  }).join('\\n'));\n  return lines.join('\\n');\n}\n\nexports.tensorToString = tensorToString;\n\nfunction computeMaxSizePerColumn(t) {\n  var vals = t.dataSync();\n  var n = t.size;\n  var numCols = t.strides[t.strides.length - 1];\n  var padPerCol = new Array(numCols).fill(0);\n\n  if (t.rank > 1) {\n    for (var row = 0; row < n / numCols; row++) {\n      var offset = row * numCols;\n\n      for (var j = 0; j < numCols; j++) {\n        padPerCol[j] = Math.max(padPerCol[j], valToString(vals[offset + j], 0).length);\n      }\n    }\n  }\n\n  return padPerCol;\n}\n\nfunction valToString(val, pad) {\n  return util.rightPad(parseFloat(val.toFixed(FORMAT_NUM_SIG_DIGITS)).toString(), pad);\n}\n\nfunction subTensorToString(vals, shape, strides, padPerCol, isLast) {\n  if (isLast === void 0) {\n    isLast = true;\n  }\n\n  var size = shape[0];\n  var rank = shape.length;\n\n  if (rank === 0) {\n    return [vals[0].toString()];\n  }\n\n  if (rank === 1) {\n    if (size > FORMAT_LIMIT_NUM_VALS) {\n      var firstVals = Array.from(vals.subarray(0, FORMAT_NUM_FIRST_LAST_VALS));\n      var lastVals = Array.from(vals.subarray(size - FORMAT_NUM_FIRST_LAST_VALS, size));\n      return ['[' + firstVals.map(function (x, i) {\n        return valToString(x, padPerCol[i]);\n      }).join(', ') + ', ..., ' + lastVals.map(function (x, i) {\n        return valToString(x, padPerCol[size - FORMAT_NUM_FIRST_LAST_VALS + i]);\n      }).join(', ') + ']'];\n    }\n\n    return ['[' + Array.from(vals).map(function (x, i) {\n      return valToString(x, padPerCol[i]);\n    }).join(', ') + ']'];\n  }\n\n  var subshape = shape.slice(1);\n  var substrides = strides.slice(1);\n  var stride = strides[0];\n  var lines = [];\n\n  if (size > FORMAT_LIMIT_NUM_VALS) {\n    for (var i = 0; i < FORMAT_NUM_FIRST_LAST_VALS; i++) {\n      var start = i * stride;\n      var end = start + stride;\n      lines.push.apply(lines, subTensorToString(vals.subarray(start, end), subshape, substrides, padPerCol, false));\n    }\n\n    lines.push('...');\n\n    for (var i = size - FORMAT_NUM_FIRST_LAST_VALS; i < size; i++) {\n      var start = i * stride;\n      var end = start + stride;\n      lines.push.apply(lines, subTensorToString(vals.subarray(start, end), subshape, substrides, padPerCol, i === size - 1));\n    }\n  } else {\n    for (var i = 0; i < size; i++) {\n      var start = i * stride;\n      var end = start + stride;\n      lines.push.apply(lines, subTensorToString(vals.subarray(start, end), subshape, substrides, padPerCol, i === size - 1));\n    }\n  }\n\n  var sep = rank === 2 ? ',' : '';\n  lines[0] = '[' + lines[0] + sep;\n\n  for (var i = 1; i < lines.length - 1; i++) {\n    lines[i] = ' ' + lines[i] + sep;\n  }\n\n  var newLineSep = ',\\n';\n\n  for (var i = 2; i < rank; i++) {\n    newLineSep += '\\n';\n  }\n\n  lines[lines.length - 1] = ' ' + lines[lines.length - 1] + ']' + (isLast ? '' : newLineSep);\n  return lines;\n}","map":null,"metadata":{},"sourceType":"script"}