{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function sent() {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) {\n      try {\n        if (f = 1, y && (t = y[op[0] & 2 ? \"return\" : op[0] ? \"throw\" : \"next\"]) && !(t = t.call(y, op[1])).done) return t;\n        if (y = 0, t) op = [0, t.value];\n\n        switch (op[0]) {\n          case 0:\n          case 1:\n            t = op;\n            break;\n\n          case 4:\n            _.label++;\n            return {\n              value: op[1],\n              done: false\n            };\n\n          case 5:\n            _.label++;\n            y = op[1];\n            op = [0];\n            continue;\n\n          case 7:\n            op = _.ops.pop();\n\n            _.trys.pop();\n\n            continue;\n\n          default:\n            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n              _ = 0;\n              continue;\n            }\n\n            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n              _.label = op[1];\n              break;\n            }\n\n            if (op[0] === 6 && _.label < t[1]) {\n              _.label = t[1];\n              t = op;\n              break;\n            }\n\n            if (t && _.label < t[2]) {\n              _.label = t[2];\n\n              _.ops.push(op);\n\n              break;\n            }\n\n            if (t[2]) _.ops.pop();\n\n            _.trys.pop();\n\n            continue;\n        }\n\n        op = body.call(thisArg, _);\n      } catch (e) {\n        op = [6, e];\n        y = 0;\n      } finally {\n        f = t = 0;\n      }\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar environment_1 = require(\"../environment\");\n\nvar axis_util = require(\"../ops/axis_util\");\n\nvar ops = require(\"../ops/ops\");\n\nvar reduce_util = require(\"../ops/reduce_util\");\n\nvar tensor_1 = require(\"../tensor\");\n\nvar types = require(\"../types\");\n\nvar util = require(\"../util\");\n\nvar backend_util = require(\"./backend_util\");\n\nvar argminmax_gpu_1 = require(\"./webgl/argminmax_gpu\");\n\nvar avg_pool_backprop_gpu_1 = require(\"./webgl/avg_pool_backprop_gpu\");\n\nvar batchnorm_gpu_1 = require(\"./webgl/batchnorm_gpu\");\n\nvar binaryop_gpu = require(\"./webgl/binaryop_gpu\");\n\nvar binaryop_gpu_1 = require(\"./webgl/binaryop_gpu\");\n\nvar clip_gpu_1 = require(\"./webgl/clip_gpu\");\n\nvar concat_gpu_1 = require(\"./webgl/concat_gpu\");\n\nvar conv_backprop_gpu_1 = require(\"./webgl/conv_backprop_gpu\");\n\nvar conv_gpu_1 = require(\"./webgl/conv_gpu\");\n\nvar conv_gpu_depthwise_1 = require(\"./webgl/conv_gpu_depthwise\");\n\nvar from_pixels_gpu_1 = require(\"./webgl/from_pixels_gpu\");\n\nvar gather_gpu_1 = require(\"./webgl/gather_gpu\");\n\nvar gpgpu_context_1 = require(\"./webgl/gpgpu_context\");\n\nvar gpgpu_math = require(\"./webgl/gpgpu_math\");\n\nvar logical_gpu_1 = require(\"./webgl/logical_gpu\");\n\nvar lrn_gpu_1 = require(\"./webgl/lrn_gpu\");\n\nvar max_pool_backprop_gpu_1 = require(\"./webgl/max_pool_backprop_gpu\");\n\nvar mulmat_gpu_1 = require(\"./webgl/mulmat_gpu\");\n\nvar multinomial_gpu_1 = require(\"./webgl/multinomial_gpu\");\n\nvar onehot_gpu_1 = require(\"./webgl/onehot_gpu\");\n\nvar pad_gpu_1 = require(\"./webgl/pad_gpu\");\n\nvar pool_gpu_1 = require(\"./webgl/pool_gpu\");\n\nvar reduce_gpu_1 = require(\"./webgl/reduce_gpu\");\n\nvar resize_bilinear_gpu_1 = require(\"./webgl/resize_bilinear_gpu\");\n\nvar resize_nearest_neighbor_gpu_1 = require(\"./webgl/resize_nearest_neighbor_gpu\");\n\nvar reverse_gpu_1 = require(\"./webgl/reverse_gpu\");\n\nvar slice_gpu_1 = require(\"./webgl/slice_gpu\");\n\nvar tex_util_1 = require(\"./webgl/tex_util\");\n\nvar texture_manager_1 = require(\"./webgl/texture_manager\");\n\nvar tile_gpu_1 = require(\"./webgl/tile_gpu\");\n\nvar transpose_gpu_1 = require(\"./webgl/transpose_gpu\");\n\nvar unary_op = require(\"./webgl/unaryop_gpu\");\n\nvar unaryop_gpu_1 = require(\"./webgl/unaryop_gpu\");\n\nvar webgl_util = require(\"./webgl/webgl_util\");\n\nvar MathBackendWebGL = function () {\n  function MathBackendWebGL(gpgpu, delayedStorage) {\n    if (delayedStorage === void 0) {\n      delayedStorage = true;\n    }\n\n    this.gpgpu = gpgpu;\n    this.delayedStorage = delayedStorage;\n    this.texData = new WeakMap();\n    this.uploadWaitMs = 0;\n    this.downloadWaitMs = 0;\n    this.binaryCache = {};\n    this.disposed = false;\n\n    if (environment_1.ENV.get('WEBGL_VERSION') < 1) {\n      throw new Error('WebGL is not supported on this device');\n    }\n\n    if (gpgpu == null) {\n      this.gpgpu = new gpgpu_context_1.GPGPUContext();\n      this.gpgpuCreatedLocally = true;\n    } else {\n      this.gpgpuCreatedLocally = false;\n    }\n\n    if (typeof document !== 'undefined') {\n      this.canvas = document.createElement('canvas');\n    }\n\n    this.textureManager = new texture_manager_1.TextureManager(this.gpgpu);\n  }\n\n  MathBackendWebGL.prototype.register = function (dataId, shape, dtype) {\n    if (this.texData.has(dataId)) {\n      throw new Error('Data buffer is already registered');\n    }\n\n    this.texData.set(dataId, {\n      shape: shape,\n      dtype: dtype,\n      values: null,\n      texture: null,\n      texShape: null,\n      texType: tex_util_1.TextureType.FLOAT\n    });\n  };\n\n  MathBackendWebGL.prototype.fromPixels = function (pixels, numChannels) {\n    if (pixels == null) {\n      throw new Error('MathBackendWebGL.writePixels(): pixels can not be null');\n    }\n\n    var texShape = [pixels.height, pixels.width];\n    var outShape = [pixels.height, pixels.width, numChannels];\n\n    if (pixels instanceof HTMLVideoElement) {\n      if (this.canvas == null) {\n        throw new Error('Can\\'t read pixels from HTMLImageElement outside ' + 'the browser.');\n      }\n\n      this.canvas.width = pixels.width;\n      this.canvas.height = pixels.height;\n      this.canvas.getContext('2d').drawImage(pixels, 0, 0, pixels.width, pixels.height);\n      pixels = this.canvas;\n    }\n\n    var tempPixelArray = tensor_1.Tensor.make(texShape, {}, 'int32');\n    this.texData.get(tempPixelArray.dataId).texType = tex_util_1.TextureType.UNSIGNED_BYTE;\n    this.gpgpu.uploadPixelDataToTexture(this.getTexture(tempPixelArray.dataId), pixels);\n    var program = new from_pixels_gpu_1.FromPixelsProgram(outShape);\n    var res = this.compileAndRun(program, [tempPixelArray]);\n    tempPixelArray.dispose();\n    return res;\n  };\n\n  MathBackendWebGL.prototype.write = function (dataId, values) {\n    if (values == null) {\n      throw new Error('MathBackendWebGL.write(): values can not be null');\n    }\n\n    this.throwIfNoData(dataId);\n    var texData = this.texData.get(dataId);\n    var texture = texData.texture,\n        texShape = texData.texShape,\n        texType = texData.texType;\n\n    if (texture != null) {\n      this.textureManager.releaseTexture(texture, texShape, texType);\n      texData.texture = null;\n      texData.texShape = null;\n    }\n\n    texData.values = values;\n\n    if (!this.delayedStorage) {\n      this.uploadToGPU(dataId);\n    }\n  };\n\n  MathBackendWebGL.prototype.readSync = function (dataId) {\n    this.throwIfNoData(dataId);\n    var texData = this.texData.get(dataId);\n    var texture = texData.texture,\n        values = texData.values,\n        texShape = texData.texShape;\n\n    if (values != null) {\n      this.cacheOnCPU(dataId);\n      return values;\n    }\n\n    var shouldTimeProgram = this.activeTimers != null;\n    var start;\n\n    if (shouldTimeProgram) {\n      start = performance.now();\n    }\n\n    var float32Values = this.gpgpu.downloadMatrixFromTexture(texture, texShape[0], texShape[1]);\n\n    if (shouldTimeProgram) {\n      this.downloadWaitMs += performance.now() - start;\n    }\n\n    this.cacheOnCPU(dataId, float32Values);\n    return texData.values;\n  };\n\n  MathBackendWebGL.prototype.read = function (dataId) {\n    return __awaiter(this, void 0, void 0, function () {\n      var texData, texture, values, texShape, float32Values;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            this.throwIfNoData(dataId);\n            texData = this.texData.get(dataId);\n            texture = texData.texture, values = texData.values, texShape = texData.texShape;\n\n            if (values != null) {\n              this.cacheOnCPU(dataId);\n              return [2, values];\n            }\n\n            if (!environment_1.ENV.get('WEBGL_GET_BUFFER_SUB_DATA_ASYNC_EXTENSION_ENABLED')) return [3, 2];\n            return [4, this.gpgpu.downloadMatrixFromTextureAsync(texture, texShape[0], texShape[1])];\n\n          case 1:\n            float32Values = _a.sent();\n            this.cacheOnCPU(dataId, float32Values);\n            return [2, texData.values];\n\n          case 2:\n            if (environment_1.ENV.get('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION') === 0) {\n              return [2, this.readSync(dataId)];\n            }\n\n            return [4, this.gpgpu.runQuery(function () {})];\n\n          case 3:\n            _a.sent();\n\n            return [2, this.readSync(dataId)];\n        }\n      });\n    });\n  };\n\n  MathBackendWebGL.prototype.time = function (f) {\n    return __awaiter(this, void 0, void 0, function () {\n      var oldActiveTimers, newActiveTimers, outerMostTime, flattenedActiveTimers, kernelMs, res;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            oldActiveTimers = this.activeTimers;\n            newActiveTimers = [];\n            outerMostTime = false;\n\n            if (this.programTimersStack == null) {\n              this.programTimersStack = newActiveTimers;\n              outerMostTime = true;\n            } else {\n              this.activeTimers.push(newActiveTimers);\n            }\n\n            this.activeTimers = newActiveTimers;\n            f();\n            flattenedActiveTimers = util.flatten(this.activeTimers);\n            this.activeTimers = oldActiveTimers;\n\n            if (outerMostTime) {\n              this.programTimersStack = null;\n            }\n\n            return [4, Promise.all(flattenedActiveTimers).then(function (results) {\n              var sum = 0;\n              results.forEach(function (result) {\n                return sum += result;\n              });\n              return sum;\n            })];\n\n          case 1:\n            kernelMs = _a.sent();\n            res = {\n              uploadWaitMs: this.uploadWaitMs,\n              downloadWaitMs: this.downloadWaitMs,\n              kernelMs: kernelMs,\n              wallMs: null\n            };\n            this.uploadWaitMs = 0;\n            this.downloadWaitMs = 0;\n            return [2, res];\n        }\n      });\n    });\n  };\n\n  MathBackendWebGL.prototype.memory = function () {\n    return {\n      unreliable: false\n    };\n  };\n\n  MathBackendWebGL.prototype.startTimer = function () {\n    if (environment_1.ENV.get('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION') > 0) {\n      return this.gpgpu.beginQuery();\n    }\n\n    return {\n      startMs: performance.now(),\n      endMs: null\n    };\n  };\n\n  MathBackendWebGL.prototype.endTimer = function (query) {\n    if (environment_1.ENV.get('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION') > 0) {\n      this.gpgpu.endQuery();\n      return query;\n    }\n\n    query.endMs = performance.now();\n    return query;\n  };\n\n  MathBackendWebGL.prototype.getQueryTime = function (query) {\n    return __awaiter(this, void 0, void 0, function () {\n      var timerQuery;\n      return __generator(this, function (_a) {\n        if (environment_1.ENV.get('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION') > 0) {\n          return [2, this.gpgpu.pollQueryTime(query)];\n        }\n\n        timerQuery = query;\n        return [2, timerQuery.endMs - timerQuery.startMs];\n      });\n    });\n  };\n\n  MathBackendWebGL.prototype.disposeData = function (dataId) {\n    if (this.texData.has(dataId)) {\n      var _a = this.texData.get(dataId),\n          texture = _a.texture,\n          texShape = _a.texShape,\n          texType = _a.texType;\n\n      if (texture != null) {\n        this.textureManager.releaseTexture(texture, texShape, texType);\n      }\n\n      this.texData.delete(dataId);\n    }\n  };\n\n  MathBackendWebGL.prototype.getTexture = function (dataId) {\n    this.uploadToGPU(dataId);\n    return this.texData.get(dataId).texture;\n  };\n\n  MathBackendWebGL.prototype.getTextureData = function (dataId) {\n    this.uploadToGPU(dataId);\n    return this.texData.get(dataId);\n  };\n\n  MathBackendWebGL.prototype.getGPGPUContext = function () {\n    return this.gpgpu;\n  };\n\n  MathBackendWebGL.prototype.slice = function (x, begin, size) {\n    var program = new slice_gpu_1.SliceProgram(size);\n    var customSetup = program.getCustomSetupFunc(begin);\n    return this.compileAndRun(program, [x], null, customSetup);\n  };\n\n  MathBackendWebGL.prototype.reverse = function (x, axis) {\n    var program = new reverse_gpu_1.ReverseProgram(x.shape, axis);\n    return this.compileAndRun(program, [x]);\n  };\n\n  MathBackendWebGL.prototype.concat = function (a, b) {\n    var program = new concat_gpu_1.ConcatProgram(a.shape, b.shape);\n    return this.compileAndRun(program, [a, b]);\n  };\n\n  MathBackendWebGL.prototype.neg = function (x) {\n    var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.NEG);\n    return this.compileAndRun(program, [x]);\n  };\n\n  MathBackendWebGL.prototype.matMul = function (a, b, transposeA, transposeB) {\n    var program = new mulmat_gpu_1.MatMulProgram(a.shape, b.shape, transposeA, transposeB);\n    return this.compileAndRun(program, [a, b]);\n  };\n\n  MathBackendWebGL.prototype.multiply = function (a, b) {\n    var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.MUL, a.shape, b.shape);\n    var output = this.makeOutputArray(program.outputShape, types.upcastType(a.dtype, b.dtype));\n    return this.compileAndRun(program, [a, b], output);\n  };\n\n  MathBackendWebGL.prototype.batchNormalization = function (x, mean, variance, varianceEpsilon, scale, offset) {\n    var inputs = [x, mean, variance];\n    var offsetShape = null;\n\n    if (offset != null) {\n      offsetShape = offset.shape;\n      inputs.push(offset);\n    }\n\n    var scaleShape = null;\n\n    if (scale != null) {\n      scaleShape = scale.shape;\n      inputs.push(scale);\n    }\n\n    var program = new batchnorm_gpu_1.BatchNormProgram(x.shape, mean.shape, variance.shape, offsetShape, scaleShape, varianceEpsilon);\n    return this.compileAndRun(program, inputs);\n  };\n\n  MathBackendWebGL.prototype.localResponseNormalization4D = function (x, radius, bias, alpha, beta) {\n    var program = new lrn_gpu_1.LRNProgram(x.shape, radius, bias, alpha, beta);\n    return this.compileAndRun(program, [x]);\n  };\n\n  MathBackendWebGL.prototype.tile = function (x, reps) {\n    var program = new tile_gpu_1.TileProgram(x.shape, reps);\n    return this.compileAndRun(program, [x]);\n  };\n\n  MathBackendWebGL.prototype.pad = function (x, paddings, constantValue) {\n    var program = new pad_gpu_1.PadProgram(x.shape, paddings, constantValue);\n    return this.compileAndRun(program, [x]);\n  };\n\n  MathBackendWebGL.prototype.transpose = function (x, perm) {\n    var program = new transpose_gpu_1.TransposeProgram(x.shape, perm);\n    return this.compileAndRun(program, [x]);\n  };\n\n  MathBackendWebGL.prototype.gather = function (x, indices, axis) {\n    var program = new gather_gpu_1.GatherProgram(x.shape, indices.size, axis);\n    return this.compileAndRun(program, [x, indices]);\n  };\n\n  MathBackendWebGL.prototype.reduce = function (x, reduceType, dtype) {\n    var batchSize = x.shape[0];\n    var inSize = x.shape[1];\n    var windowSize = reduce_util.computeOptimalWindowSize(inSize);\n    var reduceInfo = {\n      windowSize: windowSize,\n      inSize: inSize,\n      batchSize: batchSize\n    };\n    var program = new reduce_gpu_1.ReduceProgram(reduceInfo, reduceType);\n    var _a = program.outputShape,\n        rows = _a[0],\n        cols = _a[1];\n    var output = this.makeOutputArray([rows, cols], dtype);\n    this.compileAndRun(program, [x], output);\n\n    if (output.shape[1] === 1) {\n      return output;\n    }\n\n    return this.reduce(output, reduceType, dtype);\n  };\n\n  MathBackendWebGL.prototype.argReduce = function (x, reduceType, bestIndicesA) {\n    if (bestIndicesA === void 0) {\n      bestIndicesA = null;\n    }\n\n    var batchSize = x.shape[0];\n    var inSize = x.shape[1];\n\n    if (bestIndicesA != null) {\n      batchSize = bestIndicesA.shape[0];\n      inSize = bestIndicesA.shape[1];\n    }\n\n    var windowSize = reduce_util.computeOptimalWindowSize(inSize);\n    var reduceInfo = {\n      windowSize: windowSize,\n      inSize: inSize,\n      batchSize: batchSize\n    };\n    var program = new argminmax_gpu_1.ArgMinMaxProgram(reduceInfo, reduceType, bestIndicesA == null);\n    var _a = program.outputShape,\n        rows = _a[0],\n        cols = _a[1];\n    var output = this.makeOutputArray([rows, cols], 'int32');\n    var inputs = [x];\n\n    if (bestIndicesA != null) {\n      inputs.push(bestIndicesA);\n    }\n\n    this.compileAndRun(program, inputs, output);\n\n    if (output.shape[1] === 1) {\n      return output;\n    }\n\n    return this.argReduce(x, reduceType, output);\n  };\n\n  MathBackendWebGL.prototype.sum = function (x, axes) {\n    axis_util.assertAxesAreInnerMostDims('sum', axes, x.rank);\n\n    var _a = axis_util.computeOutAndReduceShapes(x.shape, axes),\n        outShape = _a[0],\n        reduceShape = _a[1];\n\n    var inSize = util.sizeFromShape(reduceShape);\n    var a2D = x.as2D(-1, inSize);\n    var outputDType = types.sumOutType(x.dtype);\n    return this.reduce(a2D, 'sum', outputDType).reshape(outShape);\n  };\n\n  MathBackendWebGL.prototype.argMin = function (x, axis) {\n    var axes = [axis];\n    axis_util.assertAxesAreInnerMostDims('argMin', axes, x.rank);\n\n    var _a = axis_util.computeOutAndReduceShapes(x.shape, axes),\n        outShape = _a[0],\n        reduceShape = _a[1];\n\n    var inSize = util.sizeFromShape(reduceShape);\n    var a2D = x.as2D(-1, inSize);\n    return this.argReduce(a2D, 'min').reshape(outShape);\n  };\n\n  MathBackendWebGL.prototype.argMax = function (x, axis) {\n    var axes = [axis];\n    axis_util.assertAxesAreInnerMostDims('argMax', axes, x.rank);\n\n    var _a = axis_util.computeOutAndReduceShapes(x.shape, axes),\n        outShape = _a[0],\n        reduceShape = _a[1];\n\n    var inSize = util.sizeFromShape(reduceShape);\n    var a2D = x.as2D(-1, inSize);\n    return this.argReduce(a2D, 'max').reshape(outShape);\n  };\n\n  MathBackendWebGL.prototype.equal = function (a, b) {\n    var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.EQUAL, a.shape, b.shape);\n    var output = this.makeOutputArray(program.outputShape, 'bool');\n    return this.compileAndRun(program, [a, b], output);\n  };\n\n  MathBackendWebGL.prototype.notEqual = function (a, b) {\n    var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.NOT_EQUAL, a.shape, b.shape);\n    var output = this.makeOutputArray(program.outputShape, 'bool');\n    return this.compileAndRun(program, [a, b], output);\n  };\n\n  MathBackendWebGL.prototype.less = function (a, b) {\n    var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.LESS, a.shape, b.shape);\n    var output = this.makeOutputArray(program.outputShape, 'bool');\n    return this.compileAndRun(program, [a, b], output);\n  };\n\n  MathBackendWebGL.prototype.lessEqual = function (a, b) {\n    var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.LESS_EQUAL, a.shape, b.shape);\n    var output = this.makeOutputArray(program.outputShape, 'bool');\n    return this.compileAndRun(program, [a, b], output);\n  };\n\n  MathBackendWebGL.prototype.greater = function (a, b) {\n    var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.GREATER, a.shape, b.shape);\n    var output = this.makeOutputArray(program.outputShape, 'bool');\n    return this.compileAndRun(program, [a, b], output);\n  };\n\n  MathBackendWebGL.prototype.greaterEqual = function (a, b) {\n    var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.GREATER_EQUAL, a.shape, b.shape);\n    var output = this.makeOutputArray(program.outputShape, 'bool');\n    return this.compileAndRun(program, [a, b], output);\n  };\n\n  MathBackendWebGL.prototype.logicalNot = function (x) {\n    var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.LOGICAL_NOT);\n    return this.compileAndRun(program, [x]);\n  };\n\n  MathBackendWebGL.prototype.logicalAnd = function (a, b) {\n    var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.LOGICAL_AND, a.shape, b.shape);\n    var output = this.makeOutputArray(program.outputShape, 'bool');\n    return this.compileAndRun(program, [a, b], output);\n  };\n\n  MathBackendWebGL.prototype.logicalOr = function (a, b) {\n    var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.LOGICAL_OR, a.shape, b.shape);\n    var output = this.makeOutputArray(program.outputShape, 'bool');\n    return this.compileAndRun(program, [a, b], output);\n  };\n\n  MathBackendWebGL.prototype.where = function (condition, a, b, dtype) {\n    var program = new logical_gpu_1.WhereProgram(condition.rank, a.shape, a.rank);\n    var output = this.makeOutputArray(program.outputShape, dtype);\n    return this.compileAndRun(program, [condition, a, b], output);\n  };\n\n  MathBackendWebGL.prototype.topKValues = function (x, k) {\n    throw new Error('topKValues GPU not yet implemented!');\n  };\n\n  MathBackendWebGL.prototype.topKIndices = function (x, k) {\n    throw new Error('topKIndices GPU not yet implemented!');\n  };\n\n  MathBackendWebGL.prototype.min = function (x, axes) {\n    axis_util.assertAxesAreInnerMostDims('min', axes, x.rank);\n\n    var _a = axis_util.computeOutAndReduceShapes(x.shape, axes),\n        outShape = _a[0],\n        reduceShape = _a[1];\n\n    var inSize = util.sizeFromShape(reduceShape);\n    var a2D = x.as2D(-1, inSize);\n    return this.reduce(a2D, 'min', a2D.dtype).reshape(outShape);\n  };\n\n  MathBackendWebGL.prototype.minimum = function (a, b) {\n    var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.MIN, a.shape, b.shape);\n    return this.compileAndRun(program, [a, b]);\n  };\n\n  MathBackendWebGL.prototype.mod = function (a, b) {\n    var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.MOD, a.shape, b.shape);\n    return this.compileAndRun(program, [a, b]);\n  };\n\n  MathBackendWebGL.prototype.max = function (x, axes) {\n    axis_util.assertAxesAreInnerMostDims('max', axes, x.rank);\n\n    var _a = axis_util.computeOutAndReduceShapes(x.shape, axes),\n        outShape = _a[0],\n        reduceShape = _a[1];\n\n    var inSize = util.sizeFromShape(reduceShape);\n    var a2D = x.as2D(-1, inSize);\n    return this.reduce(a2D, 'max', a2D.dtype).reshape(outShape);\n  };\n\n  MathBackendWebGL.prototype.maximum = function (a, b) {\n    var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.MAX, a.shape, b.shape);\n    return this.compileAndRun(program, [a, b]);\n  };\n\n  MathBackendWebGL.prototype.squaredDifference = function (a, b) {\n    var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.SQUARED_DIFFERENCE, a.shape, b.shape);\n    return this.compileAndRun(program, [a, b]);\n  };\n\n  MathBackendWebGL.prototype.divide = function (a, b) {\n    var op;\n    var outputDtype;\n\n    if (a.dtype === 'int32' && b.dtype === 'int32') {\n      op = binaryop_gpu.INT_DIV;\n      outputDtype = 'int32';\n    } else {\n      op = binaryop_gpu.DIV;\n      outputDtype = 'float32';\n    }\n\n    var program = new binaryop_gpu_1.BinaryOpProgram(op, a.shape, b.shape);\n    var output = this.makeOutputArray(program.outputShape, outputDtype);\n    return this.compileAndRun(program, [a, b], output);\n  };\n\n  MathBackendWebGL.prototype.add = function (a, b) {\n    var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.ADD, a.shape, b.shape);\n    var output = this.makeOutputArray(program.outputShape, types.upcastType(a.dtype, b.dtype));\n    return this.compileAndRun(program, [a, b], output);\n  };\n\n  MathBackendWebGL.prototype.subtract = function (a, b) {\n    var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.SUB, a.shape, b.shape);\n    var output = this.makeOutputArray(program.outputShape, types.upcastType(a.dtype, b.dtype));\n    return this.compileAndRun(program, [a, b], output);\n  };\n\n  MathBackendWebGL.prototype.pow = function (a, b) {\n    var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.POW, a.shape, b.shape);\n    var output = this.makeOutputArray(program.outputShape, types.upcastType(a.dtype, b.dtype));\n    return this.compileAndRun(program, [a, b], output);\n  };\n\n  MathBackendWebGL.prototype.ceil = function (x) {\n    var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.CEIL);\n    return this.compileAndRun(program, [x]);\n  };\n\n  MathBackendWebGL.prototype.floor = function (x) {\n    var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.FLOOR);\n    return this.compileAndRun(program, [x]);\n  };\n\n  MathBackendWebGL.prototype.sign = function (x) {\n    var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.SIGN);\n    return this.compileAndRun(program, [x]);\n  };\n\n  MathBackendWebGL.prototype.round = function (x) {\n    var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.ROUND);\n    return this.compileAndRun(program, [x]);\n  };\n\n  MathBackendWebGL.prototype.exp = function (x) {\n    var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.EXP);\n    return this.compileAndRun(program, [x]);\n  };\n\n  MathBackendWebGL.prototype.expm1 = function (x) {\n    var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.EXPM1);\n    return this.compileAndRun(program, [x]);\n  };\n\n  MathBackendWebGL.prototype.log = function (x) {\n    var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.LOG);\n    return this.compileAndRun(program, [x]);\n  };\n\n  MathBackendWebGL.prototype.log1p = function (x) {\n    var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.LOG1P);\n    return this.compileAndRun(program, [x]);\n  };\n\n  MathBackendWebGL.prototype.sqrt = function (x) {\n    var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.SQRT);\n    return this.compileAndRun(program, [x]);\n  };\n\n  MathBackendWebGL.prototype.rsqrt = function (x) {\n    var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.RSQRT);\n    return this.compileAndRun(program, [x]);\n  };\n\n  MathBackendWebGL.prototype.square = function (x) {\n    var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.SQUARE);\n    return this.compileAndRun(program, [x]);\n  };\n\n  MathBackendWebGL.prototype.reciprocal = function (x) {\n    var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.RECIPROCAL);\n    return this.compileAndRun(program, [x]);\n  };\n\n  MathBackendWebGL.prototype.relu = function (x) {\n    var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.RELU);\n    return this.compileAndRun(program, [x]);\n  };\n\n  MathBackendWebGL.prototype.elu = function (x) {\n    var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.ELU);\n    return this.compileAndRun(program, [x]);\n  };\n\n  MathBackendWebGL.prototype.eluDer = function (dy, y) {\n    var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.ELU_DER, dy.shape, y.shape);\n    return this.compileAndRun(program, [dy, y]);\n  };\n\n  MathBackendWebGL.prototype.selu = function (x) {\n    var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.SELU);\n    return this.compileAndRun(program, [x]);\n  };\n\n  MathBackendWebGL.prototype.int = function (x) {\n    var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.TO_INT);\n    var output = this.makeOutputArray(program.outputShape, 'int32');\n    return this.compileAndRun(program, [x], output);\n  };\n\n  MathBackendWebGL.prototype.clip = function (x, min, max) {\n    var program = new clip_gpu_1.ClipProgram(x.shape, min, max);\n    return this.compileAndRun(program, [x]);\n  };\n\n  MathBackendWebGL.prototype.abs = function (x) {\n    var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.ABS);\n    return this.compileAndRun(program, [x]);\n  };\n\n  MathBackendWebGL.prototype.sigmoid = function (x) {\n    var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.SIGMOID);\n    return this.compileAndRun(program, [x]);\n  };\n\n  MathBackendWebGL.prototype.softplus = function (x) {\n    var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.SOFTPLUS);\n    return this.compileAndRun(program, [x]);\n  };\n\n  MathBackendWebGL.prototype.sin = function (x) {\n    var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.SIN);\n    return this.compileAndRun(program, [x]);\n  };\n\n  MathBackendWebGL.prototype.cos = function (x) {\n    var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.COS);\n    return this.compileAndRun(program, [x]);\n  };\n\n  MathBackendWebGL.prototype.tan = function (x) {\n    var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.TAN);\n    return this.compileAndRun(program, [x]);\n  };\n\n  MathBackendWebGL.prototype.asin = function (x) {\n    var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.ASIN);\n    return this.compileAndRun(program, [x]);\n  };\n\n  MathBackendWebGL.prototype.acos = function (x) {\n    var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.ACOS);\n    return this.compileAndRun(program, [x]);\n  };\n\n  MathBackendWebGL.prototype.atan = function (x) {\n    var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.ATAN);\n    return this.compileAndRun(program, [x]);\n  };\n\n  MathBackendWebGL.prototype.atan2 = function (a, b) {\n    var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.ATAN2, a.shape, b.shape);\n    return this.compileAndRun(program, [a, b]);\n  };\n\n  MathBackendWebGL.prototype.sinh = function (x) {\n    var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.SINH);\n    return this.compileAndRun(program, [x]);\n  };\n\n  MathBackendWebGL.prototype.cosh = function (x) {\n    var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.COSH);\n    return this.compileAndRun(program, [x]);\n  };\n\n  MathBackendWebGL.prototype.tanh = function (x) {\n    var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.TANH);\n    return this.compileAndRun(program, [x]);\n  };\n\n  MathBackendWebGL.prototype.asinh = function (x) {\n    var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.ASINH);\n    return this.compileAndRun(program, [x]);\n  };\n\n  MathBackendWebGL.prototype.acosh = function (x) {\n    var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.ACOSH);\n    return this.compileAndRun(program, [x]);\n  };\n\n  MathBackendWebGL.prototype.atanh = function (x) {\n    var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.ATANH);\n    return this.compileAndRun(program, [x]);\n  };\n\n  MathBackendWebGL.prototype.erf = function (x) {\n    var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.ERF);\n    return this.compileAndRun(program, [x]);\n  };\n\n  MathBackendWebGL.prototype.step = function (x, alpha) {\n    var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.STEP(alpha));\n    return this.compileAndRun(program, [x]);\n  };\n\n  MathBackendWebGL.prototype.conv2d = function (x, filter, convInfo) {\n    var program = new conv_gpu_1.Conv2DProgram(convInfo);\n    return this.compileAndRun(program, [x, filter]);\n  };\n\n  MathBackendWebGL.prototype.conv2dDerInput = function (dy, filter, convInfo) {\n    var program = new conv_backprop_gpu_1.Conv2DDerInputProgram(convInfo);\n    return this.compileAndRun(program, [dy, filter]);\n  };\n\n  MathBackendWebGL.prototype.conv2dDerFilter = function (x, dy, convInfo) {\n    var program = new conv_backprop_gpu_1.Conv2DDerFilterProgram(convInfo);\n    return this.compileAndRun(program, [x, dy]);\n  };\n\n  MathBackendWebGL.prototype.depthwiseConv2D = function (x, filter, convInfo) {\n    var program = new conv_gpu_depthwise_1.DepthwiseConv2DProgram(convInfo);\n    return this.compileAndRun(program, [x, filter]);\n  };\n\n  MathBackendWebGL.prototype.maxPool = function (x, convInfo) {\n    var program = new pool_gpu_1.Pool2DProgram(convInfo, 'max', false);\n    var output = this.makeOutputArray(program.outputShape, x.dtype);\n    return this.compileAndRun(program, [x], output);\n  };\n\n  MathBackendWebGL.prototype.avgPool = function (x, convInfo) {\n    var program = new pool_gpu_1.Pool2DProgram(convInfo, 'avg', false);\n    var output = this.makeOutputArray(program.outputShape, 'float32');\n    return this.compileAndRun(program, [x], output);\n  };\n\n  MathBackendWebGL.prototype.maxPoolBackprop = function (dy, x, y, convInfo) {\n    var getPositions = true;\n    var maxPoolPositionsProgram = new pool_gpu_1.Pool2DProgram(convInfo, 'max', getPositions);\n    var maxPoolPositions = this.compileAndRun(maxPoolPositionsProgram, [x]);\n    var maxPoolBackPropProgram = new max_pool_backprop_gpu_1.MaxPool2DBackpropProgram(convInfo);\n    var output = this.makeOutputArray(maxPoolBackPropProgram.outputShape, x.dtype);\n    var result = this.compileAndRun(maxPoolBackPropProgram, [dy, maxPoolPositions], output);\n    maxPoolPositions.dispose();\n    return result;\n  };\n\n  MathBackendWebGL.prototype.avgPoolBackprop = function (dy, x, convInfo) {\n    var avgPoolBackpropProgram = new avg_pool_backprop_gpu_1.AvgPool2DBackpropProgram(convInfo);\n    var output = this.makeOutputArray(avgPoolBackpropProgram.outputShape, x.dtype);\n    return this.compileAndRun(avgPoolBackpropProgram, [dy], output);\n  };\n\n  MathBackendWebGL.prototype.cast = function (x, dtype) {\n    return backend_util.castTensor(x, dtype, this);\n  };\n\n  MathBackendWebGL.prototype.reshape = function (x, shape) {\n    return backend_util.reshapeTensor(x, shape);\n  };\n\n  MathBackendWebGL.prototype.resizeBilinear = function (x, newHeight, newWidth, alignCorners) {\n    var program = new resize_bilinear_gpu_1.ResizeBilinearProgram(x.shape, newHeight, newWidth, alignCorners);\n    return this.compileAndRun(program, [x]);\n  };\n\n  MathBackendWebGL.prototype.resizeNearestNeighbor = function (x, newHeight, newWidth, alignCorners) {\n    var program = new resize_nearest_neighbor_gpu_1.ResizeNearestNeighborProgram(x.shape, newHeight, newWidth, alignCorners);\n    return this.compileAndRun(program, [x]);\n  };\n\n  MathBackendWebGL.prototype.multinomial = function (logits, normalized, numSamples, seed) {\n    var probs = normalized ? logits : ops.softmax(logits);\n    var batchSize = probs.shape[0];\n    var numOutcomes = probs.shape[1];\n    var program = new multinomial_gpu_1.MultinomialProgram(batchSize, numOutcomes, numSamples);\n    var output = this.makeOutputArray(program.outputShape, 'int32');\n    var customSetup = program.getCustomSetupFunc(seed);\n    return this.compileAndRun(program, [probs], output, customSetup);\n  };\n\n  MathBackendWebGL.prototype.oneHot = function (indices, depth, onValue, offValue) {\n    var program = new onehot_gpu_1.OneHotProgram(indices.size, depth, onValue, offValue);\n    return this.compileAndRun(program, [indices]);\n  };\n\n  MathBackendWebGL.prototype.makeOutputArray = function (shape, dtype) {\n    return tensor_1.Tensor.make(shape, {}, dtype);\n  };\n\n  MathBackendWebGL.prototype.compileAndRun = function (program, inputs, output, customSetup) {\n    var _this = this;\n\n    if (output == null) {\n      output = this.makeOutputArray(program.outputShape, inputs[0].dtype);\n    }\n\n    var inputsData = inputs.map(function (input) {\n      _this.uploadToGPU(input.dataId);\n\n      return {\n        tensor: input,\n        texData: _this.texData.get(input.dataId)\n      };\n    });\n    this.uploadToGPU(output.dataId);\n    var outputData = {\n      tensor: output,\n      texData: this.texData.get(output.dataId)\n    };\n    var key = gpgpu_math.makeShaderKey(program, inputsData, outputData);\n    var binary = this.getAndSaveBinary(key, function () {\n      return gpgpu_math.compileProgram(_this.gpgpu, program, inputsData, outputData);\n    });\n    var shouldTimeProgram = this.activeTimers != null;\n    var query;\n\n    if (shouldTimeProgram) {\n      query = this.startTimer();\n    }\n\n    gpgpu_math.runProgram(binary, inputsData, outputData, customSetup);\n\n    if (shouldTimeProgram) {\n      query = this.endTimer(query);\n      this.activeTimers.push(this.getQueryTime(query));\n    }\n\n    return output;\n  };\n\n  MathBackendWebGL.prototype.getAndSaveBinary = function (key, getBinary) {\n    if (!(key in this.binaryCache)) {\n      this.binaryCache[key] = getBinary();\n    }\n\n    return this.binaryCache[key];\n  };\n\n  MathBackendWebGL.prototype.getTextureManager = function () {\n    return this.textureManager;\n  };\n\n  MathBackendWebGL.prototype.dispose = function () {\n    if (this.disposed) {\n      return;\n    }\n\n    for (var key in this.binaryCache) {\n      this.gpgpu.deleteProgram(this.binaryCache[key].webGLProgram);\n    }\n\n    this.textureManager.dispose();\n    this.canvas.remove();\n\n    if (this.gpgpuCreatedLocally) {\n      this.gpgpu.dispose();\n    }\n\n    this.disposed = true;\n  };\n\n  MathBackendWebGL.prototype.throwIfNoData = function (dataId) {\n    if (!this.texData.has(dataId)) {\n      throw new Error(\"WebGL backend: No data found for this tensor. \" + \"Did you change your backend in the middle of the program? \" + \"New backends can't use Tensors created with previous backends\");\n    }\n  };\n\n  MathBackendWebGL.prototype.uploadToGPU = function (dataId) {\n    this.throwIfNoData(dataId);\n    var texData = this.texData.get(dataId);\n    var shape = texData.shape,\n        values = texData.values,\n        texture = texData.texture,\n        dtype = texData.dtype,\n        texType = texData.texType;\n\n    if (texture != null) {\n      return;\n    }\n\n    var shouldTimeProgram = this.activeTimers != null;\n    var start;\n\n    if (shouldTimeProgram) {\n      start = performance.now();\n    }\n\n    var texShape = webgl_util.getTextureShapeFromLogicalShape(this.gpgpu.gl, shape);\n    texData.texShape = texShape;\n    var newTexture = this.textureManager.acquireTexture(texShape, texType);\n    texData.texture = newTexture;\n\n    if (values != null) {\n      this.gpgpu.uploadMatrixToTexture(newTexture, texShape[0], texShape[1], typedArrayToFloat32(values, dtype));\n      texData.values = null;\n\n      if (shouldTimeProgram) {\n        this.uploadWaitMs += performance.now() - start;\n      }\n    }\n  };\n\n  MathBackendWebGL.prototype.cacheOnCPU = function (dataId, float32Values) {\n    var dontKeepCopyOnGPU = this.delayedStorage;\n    var texData = this.texData.get(dataId);\n    var texture = texData.texture,\n        texShape = texData.texShape,\n        dtype = texData.dtype,\n        texType = texData.texType;\n\n    if (dontKeepCopyOnGPU && texture != null) {\n      this.textureManager.releaseTexture(texture, texShape, texType);\n      texData.texture = null;\n      texData.texShape = null;\n    }\n\n    if (float32Values != null) {\n      texData.values = float32ToTypedArray(float32Values, dtype);\n    }\n  };\n\n  return MathBackendWebGL;\n}();\n\nexports.MathBackendWebGL = MathBackendWebGL;\nenvironment_1.ENV.registerBackend('webgl', function () {\n  return new MathBackendWebGL();\n}, 2);\n\nfunction float32ToTypedArray(a, dtype) {\n  if (dtype === 'float32') {\n    return a;\n  } else if (dtype === 'int32' || dtype === 'bool') {\n    var result = dtype === 'int32' ? new Int32Array(a.length) : new Uint8Array(a.length);\n\n    for (var i = 0; i < result.length; ++i) {\n      result[i] = Math.round(a[i]);\n    }\n\n    return result;\n  } else {\n    throw new Error(\"Unknown dtype \" + dtype);\n  }\n}\n\nfunction typedArrayToFloat32(a, dtype) {\n  return a instanceof Float32Array ? a : new Float32Array(a);\n}","map":null,"metadata":{},"sourceType":"script"}