{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) {\n      if (b.hasOwnProperty(p)) d[p] = b[p];\n    }\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar K = require(\"../backend/tfjs_backend\");\n\nvar topology_1 = require(\"../engine/topology\");\n\nvar errors_1 = require(\"../errors\");\n\nvar generic_utils = require(\"../utils/generic_utils\");\n\nvar serialization_1 = require(\"./serialization\");\n\nvar Wrapper = function (_super) {\n  __extends(Wrapper, _super);\n\n  function Wrapper(config) {\n    var _this = _super.call(this, config) || this;\n\n    _this.layer = config.layer;\n    return _this;\n  }\n\n  Wrapper.prototype.build = function (inputShape) {\n    this.built = true;\n  };\n\n  Object.defineProperty(Wrapper.prototype, \"trainable\", {\n    get: function get() {\n      if (this.layer != null) {\n        return this.layer.trainable;\n      } else {\n        return false;\n      }\n    },\n    set: function set(value) {\n      if (this.layer != null) {\n        this.layer.trainable = value;\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Wrapper.prototype, \"trainableWeights\", {\n    get: function get() {\n      return this.layer.trainableWeights;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Wrapper.prototype, \"nonTrainableWeights\", {\n    get: function get() {\n      return this.layer.nonTrainableWeights;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Wrapper.prototype, \"updates\", {\n    get: function get() {\n      return this.layer._updates;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Wrapper.prototype, \"losses\", {\n    get: function get() {\n      return this.layer.losses;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  Wrapper.prototype.getWeights = function () {\n    return this.layer.getWeights();\n  };\n\n  Wrapper.prototype.setWeights = function (weights) {\n    this.layer.setWeights(weights);\n  };\n\n  Wrapper.prototype.getConfig = function () {\n    var config = {\n      'layer': {\n        'className': this.layer.getClassName(),\n        'config': this.layer.getConfig()\n      }\n    };\n\n    var baseConfig = _super.prototype.getConfig.call(this);\n\n    Object.assign(config, baseConfig);\n    return config;\n  };\n\n  Wrapper.fromConfig = function (cls, config, customObjects) {\n    if (customObjects === void 0) {\n      customObjects = {};\n    }\n\n    var layerConfig = config['layer'];\n    var layer = serialization_1.deserialize(layerConfig, customObjects);\n    delete config['layer'];\n    var newConfig = {\n      layer: layer\n    };\n    Object.assign(newConfig, config);\n    return new cls(newConfig);\n  };\n\n  return Wrapper;\n}(topology_1.Layer);\n\nexports.Wrapper = Wrapper;\n\nvar TimeDistributed = function (_super) {\n  __extends(TimeDistributed, _super);\n\n  function TimeDistributed(config) {\n    var _this = _super.call(this, config) || this;\n\n    _this.supportsMasking = true;\n    return _this;\n  }\n\n  TimeDistributed.prototype.build = function (inputShape) {\n    inputShape = generic_utils.getExactlyOneShape(inputShape);\n\n    if (inputShape.length < 3) {\n      throw new errors_1.ValueError(\"TimeDistributed layer expects an input shape >= 3D, but received \" + (\"input shape \" + JSON.stringify(inputShape)));\n    }\n\n    this.inputSpec = [{\n      shape: inputShape\n    }];\n    var childInputShape = [inputShape[0]].concat(inputShape.slice(2));\n\n    if (!this.layer.built) {\n      this.layer.build(childInputShape);\n      this.layer.built = true;\n    }\n\n    _super.prototype.build.call(this, inputShape);\n  };\n\n  TimeDistributed.prototype.computeOutputShape = function (inputShape) {\n    inputShape = generic_utils.getExactlyOneShape(inputShape);\n    var childInputShape = [inputShape[0]].concat(inputShape.slice(2));\n    var childOutputShape = this.layer.computeOutputShape(childInputShape);\n    var timesteps = inputShape[1];\n    return [childOutputShape[0], timesteps].concat(childOutputShape.slice(1));\n  };\n\n  TimeDistributed.prototype.call = function (inputs, kwargs) {\n    var _this = this;\n\n    inputs = generic_utils.getExactlyOneTensor(inputs);\n\n    var step = function step(inputs, states) {\n      var output = _this.layer.call(inputs, kwargs);\n\n      return [output, []];\n    };\n\n    var rnnOutputs = K.rnn(step, inputs, [], false, null, null, false, inputs.shape[1]);\n    var y = rnnOutputs[1];\n    return y;\n  };\n\n  TimeDistributed.prototype.getClassName = function () {\n    return 'TimeDistributed';\n  };\n\n  return TimeDistributed;\n}(Wrapper);\n\nexports.TimeDistributed = TimeDistributed;\ngeneric_utils.ClassNameMap.register('TimeDistributed', TimeDistributed);\nvar BidirectionalMergeMode;\n\n(function (BidirectionalMergeMode) {\n  BidirectionalMergeMode[BidirectionalMergeMode[\"SUM\"] = 0] = \"SUM\";\n  BidirectionalMergeMode[BidirectionalMergeMode[\"MUL\"] = 1] = \"MUL\";\n  BidirectionalMergeMode[BidirectionalMergeMode[\"CONCAT\"] = 2] = \"CONCAT\";\n  BidirectionalMergeMode[BidirectionalMergeMode[\"AVE\"] = 3] = \"AVE\";\n})(BidirectionalMergeMode = exports.BidirectionalMergeMode || (exports.BidirectionalMergeMode = {}));\n\ngeneric_utils.SerializableEnumRegistry.register('merge_mode', {\n  'sum': BidirectionalMergeMode.SUM,\n  'mul': BidirectionalMergeMode.MUL,\n  'concat': BidirectionalMergeMode.CONCAT,\n  'ave': BidirectionalMergeMode.AVE\n});\n\nvar Bidirectional = function (_super) {\n  __extends(Bidirectional, _super);\n\n  function Bidirectional(config) {\n    var _this = _super.call(this, config) || this;\n\n    _this.forwardLayer = config.layer;\n    var layerConfig = config.layer.getConfig();\n    layerConfig['goBackwards'] = layerConfig['goBackwards'] === true ? false : true;\n    _this.backwardLayer = serialization_1.deserialize({\n      className: config.layer.getClassName(),\n      config: layerConfig\n    });\n    _this.forwardLayer.name = 'forward_' + _this.forwardLayer.name;\n    _this.backwardLayer.name = 'backward_' + _this.backwardLayer.name;\n    _this.mergeMode = config.mergeMode;\n\n    if (config.weights) {\n      throw new errors_1.NotImplementedError('weights support is not implemented for Bidirectional layer yet.');\n    }\n\n    _this._stateful = config.layer.stateful;\n    _this.returnSequences = config.layer.returnSequences;\n    _this.returnState = config.layer.returnState;\n    _this.supportsMasking = true;\n    _this._trainable = true;\n    _this.inputSpec = config.layer.inputSpec;\n    return _this;\n  }\n\n  Object.defineProperty(Bidirectional.prototype, \"trainable\", {\n    get: function get() {\n      return this._trainable;\n    },\n    set: function set(value) {\n      this._trainable = value;\n\n      if (this.forwardLayer != null) {\n        this.forwardLayer.trainable = value;\n      }\n\n      if (this.backwardLayer != null) {\n        this.backwardLayer.trainable = value;\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  Bidirectional.prototype.getWeights = function () {\n    return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights());\n  };\n\n  Bidirectional.prototype.setWeights = function (weights) {\n    var numWeights = weights.length;\n    var numeightsOver2 = Math.floor(numWeights / 2);\n    this.forwardLayer.setWeights(weights.slice(0, numeightsOver2));\n    this.backwardLayer.setWeights(weights.slice(numeightsOver2));\n  };\n\n  Bidirectional.prototype.computeOutputShape = function (inputShape) {\n    var layerShapes = this.forwardLayer.computeOutputShape(inputShape);\n\n    if (!(Array.isArray(layerShapes) && Array.isArray(layerShapes[0]))) {\n      layerShapes = [layerShapes];\n    }\n\n    layerShapes = layerShapes;\n    var outputShape;\n    var outputShapes;\n    var stateShape;\n\n    if (this.returnState) {\n      stateShape = layerShapes.slice(1);\n      outputShape = layerShapes[0];\n    } else {\n      outputShape = layerShapes[0];\n    }\n\n    outputShape = outputShape;\n\n    if (this.mergeMode === BidirectionalMergeMode.CONCAT) {\n      outputShape[outputShape.length - 1] *= 2;\n      outputShapes = [outputShape];\n    } else if (this.mergeMode == null) {\n      outputShapes = [outputShape, outputShape.slice()];\n    } else {\n      outputShapes = [outputShape];\n    }\n\n    if (this.returnState) {\n      if (this.mergeMode == null) {\n        return outputShapes.concat(stateShape).concat(stateShape.slice());\n      }\n\n      return [outputShape].concat(stateShape).concat(stateShape.slice());\n    }\n\n    return generic_utils.singletonOrArray(outputShapes);\n  };\n\n  Bidirectional.prototype.apply = function (inputs, kwargs) {\n    var initialState = null;\n\n    if (kwargs != null) {\n      initialState = kwargs['initialState'];\n    }\n\n    if (Array.isArray(inputs)) {\n      initialState = inputs.slice(1);\n      inputs = inputs[0];\n    }\n\n    if (initialState == null || initialState.length === 0) {\n      var applyOutputs = _super.prototype.apply.call(this, inputs, kwargs);\n\n      return applyOutputs;\n    } else {\n      throw new errors_1.NotImplementedError('The support for initial states is not implemented for ' + 'Bidirectional layers yet.');\n    }\n  };\n\n  Bidirectional.prototype.call = function (inputs, kwargs) {\n    if (kwargs['mask'] != null) {\n      throw new errors_1.NotImplementedError('The support for masking is not implemented for ' + 'Bidirectional layers yet.');\n    }\n\n    if (kwargs['initialState'] != null) {\n      throw new errors_1.NotImplementedError('The support for initial states is not implemented for ' + 'Bidirectional layers yet.');\n    }\n\n    var y = this.forwardLayer.call(inputs, kwargs);\n    var yRev = this.backwardLayer.call(inputs, kwargs);\n    var states;\n\n    if (this.returnState) {\n      if (Array.isArray(y)) {\n        states = y.slice(1).concat(yRev.slice(1));\n      } else {}\n\n      y = y[0];\n      yRev = yRev[0];\n    }\n\n    if (this.returnSequences) {\n      yRev = K.reverse(yRev, 1);\n    }\n\n    var output;\n\n    if (this.mergeMode === BidirectionalMergeMode.CONCAT) {\n      output = K.concatenate([y, yRev]);\n    } else if (this.mergeMode === BidirectionalMergeMode.SUM) {\n      output = K.add(y, yRev);\n    } else if (this.mergeMode === BidirectionalMergeMode.AVE) {\n      output = K.scalarTimesArray(K.getScalar(0.5), K.add(y, yRev));\n    } else if (this.mergeMode === BidirectionalMergeMode.MUL) {\n      output = K.multiply(y, yRev);\n    } else if (this.mergeMode == null) {\n      output = [y, yRev];\n    }\n\n    if (this.returnState) {\n      if (this.mergeMode == null) {\n        return output.concat(states);\n      }\n\n      return [output].concat(states);\n    }\n\n    return output;\n  };\n\n  Bidirectional.prototype.resetStates = function (states) {\n    this.forwardLayer.resetStates();\n    this.backwardLayer.resetStates();\n  };\n\n  Bidirectional.prototype.build = function (inputShape) {\n    var _this = this;\n\n    K.nameScope(this.forwardLayer.name, function () {\n      _this.forwardLayer.build(inputShape);\n    });\n    K.nameScope(this.backwardLayer.name, function () {\n      _this.backwardLayer.build(inputShape);\n    });\n    this.built = true;\n  };\n\n  Object.defineProperty(Bidirectional.prototype, \"trainableWeights\", {\n    get: function get() {\n      return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Bidirectional.prototype, \"nonTrainableWeights\", {\n    get: function get() {\n      return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights);\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  Bidirectional.prototype.getClassName = function () {\n    return 'Bidirectional';\n  };\n\n  return Bidirectional;\n}(Wrapper);\n\nexports.Bidirectional = Bidirectional;\ngeneric_utils.ClassNameMap.register('Bidirectional', Bidirectional);","map":null,"metadata":{},"sourceType":"script"}