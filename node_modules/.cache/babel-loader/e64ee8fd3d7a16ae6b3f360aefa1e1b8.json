{"ast":null,"code":"\"use strict\";\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {\n    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  }\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar doc_1 = require(\"../doc\");\n\nvar util = require(\"../util\");\n\nvar operation_1 = require(\"./operation\");\n\nvar LSTMOps = function () {\n  function LSTMOps() {}\n\n  LSTMOps.multiRNNCell = function (lstmCells, data, c, h) {\n    util.assertArgumentsAreTensors({\n      data: data,\n      c: c,\n      h: h\n    }, 'multiRNNCell');\n    var input = data;\n    var newStates = [];\n\n    for (var i = 0; i < lstmCells.length; i++) {\n      var output = lstmCells[i](input, c[i], h[i]);\n      newStates.push(output[0]);\n      newStates.push(output[1]);\n      input = output[1];\n    }\n\n    var newC = [];\n    var newH = [];\n\n    for (var i = 0; i < newStates.length; i += 2) {\n      newC.push(newStates[i]);\n      newH.push(newStates[i + 1]);\n    }\n\n    return [newC, newH];\n  };\n\n  LSTMOps.basicLSTMCell = function (forgetBias, lstmKernel, lstmBias, data, c, h) {\n    util.assertArgumentsAreTensors({\n      forgetBias: forgetBias,\n      lstmKernel: lstmKernel,\n      lstmBias: lstmBias,\n      data: data,\n      c: c,\n      h: h\n    }, 'basicLSTMCell');\n    var combined = data.concat(h, 1);\n    var weighted = combined.matMul(lstmKernel);\n    var res = weighted.add(lstmBias);\n    var batchSize = res.shape[0];\n    var sliceCols = res.shape[1] / 4;\n    var sliceSize = [batchSize, sliceCols];\n    var i = res.slice([0, 0], sliceSize);\n    var j = res.slice([0, sliceCols], sliceSize);\n    var f = res.slice([0, sliceCols * 2], sliceSize);\n    var o = res.slice([0, sliceCols * 3], sliceSize);\n    var newC = i.sigmoid().mulStrict(j.tanh()).addStrict(c.mulStrict(forgetBias.add(f).sigmoid()));\n    var newH = newC.tanh().mulStrict(o.sigmoid());\n    return [newC, newH];\n  };\n\n  __decorate([doc_1.doc({\n    heading: 'Operations',\n    subheading: 'RNN'\n  }), operation_1.operation], LSTMOps, \"multiRNNCell\", null);\n\n  __decorate([doc_1.doc({\n    heading: 'Operations',\n    subheading: 'RNN'\n  }), operation_1.operation], LSTMOps, \"basicLSTMCell\", null);\n\n  return LSTMOps;\n}();\n\nexports.LSTMOps = LSTMOps;","map":null,"metadata":{},"sourceType":"script"}