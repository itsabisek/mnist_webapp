{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) {\n      if (b.hasOwnProperty(p)) d[p] = b[p];\n    }\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar tfjs_core_1 = require(\"@tensorflow/tfjs-core\");\n\nvar K = require(\"../backend/tfjs_backend\");\n\nvar topology_1 = require(\"../engine/topology\");\n\nvar errors_1 = require(\"../errors\");\n\nvar generic_utils = require(\"../utils/generic_utils\");\n\nvar mathUtils = require(\"../utils/math_utils\");\n\nvar Merge = function (_super) {\n  __extends(Merge, _super);\n\n  function Merge(config) {\n    var _this = _super.call(this, config || {}) || this;\n\n    _this.supportsMasking = true;\n    return _this;\n  }\n\n  Merge.prototype.getClassName = function () {\n    return 'Merge';\n  };\n\n  Merge.prototype.mergeFunction = function (inputs) {\n    throw new errors_1.NotImplementedError();\n  };\n\n  Merge.prototype.computeElementwiseOpOutputShape = function (shape1, shape2) {\n    if (shape1 == null || shape2 == null) {\n      return null;\n    } else if (shape1.length < shape2.length) {\n      return this.computeElementwiseOpOutputShape(shape2, shape1);\n    } else if (shape2.length === 0) {\n      return shape1;\n    }\n\n    var outputShape = shape1.slice(0, shape1.length - shape2.length);\n\n    for (var k = 0; k < shape2.length; ++k) {\n      var i = shape1[shape1.length - shape2.length + k];\n      var j = shape2[k];\n\n      if (i == null || j == null || i < 0 || j < 0) {\n        outputShape.push(null);\n      } else if (i === 1) {\n        outputShape.push(j);\n      } else if (j === 1) {\n        outputShape.push(i);\n      } else {\n        if (i !== j) {\n          throw new errors_1.ValueError('Operands could not be broadcast together with shapes ' + JSON.stringify(shape1) + ' ' + JSON.stringify(shape2));\n        }\n\n        outputShape.push(i);\n      }\n    }\n\n    return outputShape;\n  };\n\n  Merge.prototype.build = function (inputShape) {\n    if (Array.isArray(inputShape) && !Array.isArray(inputShape[0])) {\n      inputShape = [generic_utils.getExactlyOneShape(inputShape)];\n    }\n\n    inputShape = inputShape;\n\n    if (inputShape.length < 2) {\n      throw new errors_1.ValueError('A merge layer should be called on an Array of at least 2 inputs.' + (\" Got \" + inputShape.length + \" input(s).\"));\n    }\n\n    var batchSizes = [];\n\n    for (var _i = 0, inputShape_1 = inputShape; _i < inputShape_1.length; _i++) {\n      var shape = inputShape_1[_i];\n\n      if (shape != null && shape[0] !== null) {\n        batchSizes.push(shape[0]);\n      }\n    }\n\n    batchSizes = generic_utils.unique(batchSizes);\n\n    if (batchSizes.length > 1) {\n      throw new errors_1.ValueError(\"Can not merge tensors with different batch sizes. \" + (\"Got tensors with shapes: \" + JSON.stringify(inputShape) + \".\"));\n    }\n\n    var outputShape = inputShape[0] == null ? null : inputShape[0].slice(1);\n\n    for (var i = 1; i < inputShape.length; ++i) {\n      var shape = inputShape[i] == null ? null : inputShape[i].slice(1);\n      outputShape = this.computeElementwiseOpOutputShape(outputShape, shape);\n    }\n\n    var allRanks = inputShape.map(function (shape) {\n      return shape.length;\n    });\n\n    if (inputShape.indexOf(null) === -1 && generic_utils.unique(allRanks).length === 1) {\n      this.reshapeRequired = false;\n    } else {\n      this.reshapeRequired = true;\n    }\n  };\n\n  Merge.prototype.call = function (inputs, kwargs) {\n    inputs = inputs;\n\n    if (this.reshapeRequired) {\n      var reshapedInputs = [];\n      var inputDims = inputs.map(function (input) {\n        return K.ndim(input);\n      });\n\n      if (inputDims.indexOf(null) === -1) {\n        var maxNDim = mathUtils.max(inputDims);\n\n        for (var _i = 0, inputs_1 = inputs; _i < inputs_1.length; _i++) {\n          var x = inputs_1[_i];\n          var xNDim = K.ndim(x);\n\n          for (var k = 0; k < maxNDim - xNDim; ++k) {\n            x = K.expandDims(x, 1);\n          }\n\n          reshapedInputs.push(x);\n        }\n\n        return this.mergeFunction(reshapedInputs);\n      } else {\n        var transposed = false;\n\n        for (var _a = 0, inputs_2 = inputs; _a < inputs_2.length; _a++) {\n          var x = inputs_2[_a];\n          var xNDim = K.ndim(x);\n\n          if (xNDim == null) {\n            var xShape = K.shape(x);\n            var batchSize = xShape[0];\n            var newShape = xShape.slice(1).concat([batchSize]);\n            var xTransposed = K.reshape(x, [batchSize].concat(mathUtils.arrayProd(xShape.slice(1))));\n            xTransposed = K.permuteDimensions(xTransposed, [1, 0]);\n            xTransposed = K.reshape(xTransposed, newShape);\n            reshapedInputs.push(xTransposed);\n            transposed = true;\n          } else if (xNDim > 1) {\n            var dims = mathUtils.range(1, xNDim).concat([0]);\n            reshapedInputs.push(K.permuteDimensions(x, dims));\n            transposed = true;\n          } else {\n            reshapedInputs.push(x);\n          }\n        }\n\n        var y = this.mergeFunction(reshapedInputs);\n        var yNDim = K.ndim(y);\n\n        if (transposed) {\n          if (yNDim == null) {\n            var yShape = K.shape(y);\n            var yNDim_1 = yShape.length;\n            var batchSize = yShape[yNDim_1 - 1];\n            var newShape = [batchSize].concat(yShape.slice(0, yShape.length - 1));\n            y = K.reshape(K.permuteDimensions(K.reshape(y, [-1, batchSize]), [1, 0]), newShape);\n          } else if (yNDim > 1) {\n            var dims = [yNDim - 1].concat(mathUtils.range(0, yNDim - 1));\n            y = K.permuteDimensions(y, dims);\n          }\n        }\n\n        return y;\n      }\n    } else {\n      return this.mergeFunction(inputs);\n    }\n  };\n\n  Merge.prototype.computeOutputShape = function (inputShape) {\n    inputShape = inputShape;\n    var outputShape;\n\n    if (inputShape[0] == null) {\n      outputShape = null;\n    } else {\n      outputShape = inputShape[0].slice(1);\n    }\n\n    for (var i = 1; i < inputShape.length; ++i) {\n      var shape = inputShape[i] == null ? null : inputShape[i].slice(1);\n      outputShape = this.computeElementwiseOpOutputShape(outputShape, shape);\n    }\n\n    var batchSizes = [];\n\n    for (var _i = 0, inputShape_2 = inputShape; _i < inputShape_2.length; _i++) {\n      var shape = inputShape_2[_i];\n\n      if (shape != null && shape[0] !== null) {\n        batchSizes.push(shape[0]);\n      }\n    }\n\n    batchSizes = generic_utils.unique(batchSizes);\n\n    if (batchSizes.length === 1) {\n      outputShape = batchSizes.concat(outputShape);\n    } else {\n      outputShape = [null].concat(outputShape);\n    }\n\n    return outputShape;\n  };\n\n  return Merge;\n}(topology_1.Layer);\n\nexports.Merge = Merge;\n\nvar Add = function (_super) {\n  __extends(Add, _super);\n\n  function Add(config) {\n    return _super.call(this, config) || this;\n  }\n\n  Add.prototype.getClassName = function () {\n    return 'Add';\n  };\n\n  Add.prototype.mergeFunction = function (inputs) {\n    var output = K.zeros(inputs[0].shape);\n\n    for (var _i = 0, inputs_3 = inputs; _i < inputs_3.length; _i++) {\n      var input = inputs_3[_i];\n      output = K.add(output, input);\n    }\n\n    return output;\n  };\n\n  return Add;\n}(Merge);\n\nexports.Add = Add;\ngeneric_utils.ClassNameMap.register('Add', Add);\n\nfunction add(config) {\n  if (Array.isArray(config)) {\n    var layer = new Add({});\n    return layer.apply(config);\n  } else {\n    return new Add(config);\n  }\n}\n\nexports.add = add;\n\nvar Multiply = function (_super) {\n  __extends(Multiply, _super);\n\n  function Multiply(config) {\n    return _super.call(this, config) || this;\n  }\n\n  Multiply.prototype.getClassName = function () {\n    return 'Multiply';\n  };\n\n  Multiply.prototype.mergeFunction = function (inputs) {\n    var output = K.ones(inputs[0].shape);\n\n    for (var _i = 0, inputs_4 = inputs; _i < inputs_4.length; _i++) {\n      var input = inputs_4[_i];\n      output = K.multiply(output, input);\n    }\n\n    return output;\n  };\n\n  return Multiply;\n}(Merge);\n\nexports.Multiply = Multiply;\ngeneric_utils.ClassNameMap.register('Multiply', Multiply);\n\nfunction multiply(config) {\n  if (Array.isArray(config)) {\n    var layer = new Multiply({});\n    return layer.apply(config);\n  } else {\n    return new Multiply(config);\n  }\n}\n\nexports.multiply = multiply;\n\nvar Average = function (_super) {\n  __extends(Average, _super);\n\n  function Average(config) {\n    return _super.call(this, config) || this;\n  }\n\n  Average.prototype.getClassName = function () {\n    return 'Average';\n  };\n\n  Average.prototype.mergeFunction = function (inputs) {\n    var output = K.zeros(inputs[0].shape);\n\n    for (var _i = 0, inputs_5 = inputs; _i < inputs_5.length; _i++) {\n      var input = inputs_5[_i];\n      output = K.add(output, input);\n    }\n\n    return K.scalarTimesArray(K.getScalar(1 / inputs.length), output);\n  };\n\n  return Average;\n}(Merge);\n\nexports.Average = Average;\ngeneric_utils.ClassNameMap.register('Average', Average);\n\nfunction average(config) {\n  if (Array.isArray(config)) {\n    var layer = new Average({});\n    return layer.apply(config);\n  } else {\n    return new Average(config);\n  }\n}\n\nexports.average = average;\n\nvar Maximum = function (_super) {\n  __extends(Maximum, _super);\n\n  function Maximum(config) {\n    return _super.call(this, config) || this;\n  }\n\n  Maximum.prototype.getClassName = function () {\n    return 'Maximum';\n  };\n\n  Maximum.prototype.mergeFunction = function (inputs) {\n    var output = inputs[0];\n\n    for (var i = 1; i < inputs.length; ++i) {\n      output = K.maximum(output, inputs[i]);\n    }\n\n    return output;\n  };\n\n  return Maximum;\n}(Merge);\n\nexports.Maximum = Maximum;\ngeneric_utils.ClassNameMap.register('Maximum', Maximum);\n\nfunction maximum(config) {\n  if (Array.isArray(config)) {\n    var layer = new Maximum({});\n    return layer.apply(config);\n  } else {\n    return new Maximum(config);\n  }\n}\n\nexports.maximum = maximum;\n\nvar Minimum = function (_super) {\n  __extends(Minimum, _super);\n\n  function Minimum(config) {\n    return _super.call(this, config) || this;\n  }\n\n  Minimum.prototype.getClassName = function () {\n    return 'Minimum';\n  };\n\n  Minimum.prototype.mergeFunction = function (inputs) {\n    var output = inputs[0];\n\n    for (var i = 1; i < inputs.length; ++i) {\n      output = K.minimum(output, inputs[i]);\n    }\n\n    return output;\n  };\n\n  return Minimum;\n}(Merge);\n\nexports.Minimum = Minimum;\ngeneric_utils.ClassNameMap.register('Minimum', Minimum);\n\nfunction minimum(config) {\n  if (Array.isArray(config)) {\n    var layer = new Minimum({});\n    return layer.apply(config);\n  } else {\n    return new Minimum(config);\n  }\n}\n\nexports.minimum = minimum;\n\nvar Concatenate = function (_super) {\n  __extends(Concatenate, _super);\n\n  function Concatenate(config) {\n    var _this = _super.call(this, config) || this;\n\n    _this.DEFAULT_AXIS = -1;\n\n    if (config == null) {\n      config = {};\n    }\n\n    _this.axis = config.axis == null ? _this.DEFAULT_AXIS : config.axis;\n    _this.supportsMasking = true;\n    _this.reshapeRequired = false;\n    return _this;\n  }\n\n  Concatenate.prototype.getClassName = function () {\n    return 'Concatenate';\n  };\n\n  Concatenate.prototype.build = function (inputShape) {\n    if (!(Array.isArray(inputShape) && Array.isArray(inputShape[0])) || inputShape.length === 1) {\n      throw new errors_1.ValueError('A `Concatenate` layer should be called on a list of at least 2 ' + 'inputs');\n    }\n\n    inputShape = inputShape;\n    var allNoneShape = true;\n\n    for (var _i = 0, inputShape_3 = inputShape; _i < inputShape_3.length; _i++) {\n      var shape = inputShape_3[_i];\n\n      if (shape != null) {\n        allNoneShape = false;\n        break;\n      }\n    }\n\n    if (allNoneShape) {\n      return;\n    }\n\n    var shapeSet = [];\n\n    for (var i = 0; i < inputShape.length; ++i) {\n      var shapeWithoutConcatAxis = inputShape[i].slice();\n      shapeWithoutConcatAxis.splice(this.axis, 1);\n      var exists = false;\n\n      for (var _a = 0, shapeSet_1 = shapeSet; _a < shapeSet_1.length; _a++) {\n        var shape = shapeSet_1[_a];\n\n        if (tfjs_core_1.util.arraysEqual(shape, shapeWithoutConcatAxis)) {\n          exists = true;\n          break;\n        }\n      }\n\n      if (!exists) {\n        shapeSet.push(shapeWithoutConcatAxis);\n      }\n    }\n\n    if (shapeSet.length > 1) {\n      throw new errors_1.ValueError('A `Concatenate` layer requires inputs with matching shapes ' + 'except for the concat axis. Got input shapes: ' + JSON.stringify(inputShape));\n    }\n  };\n\n  Concatenate.prototype.mergeFunction = function (inputs) {\n    return K.concatenate(inputs, this.axis);\n  };\n\n  Concatenate.prototype.computeOutputShape = function (inputShape) {\n    if (!(Array.isArray(inputShape) && Array.isArray(inputShape[0]))) {\n      throw new errors_1.ValueError('A `Concatenate` layer should be called on a list of inputs.');\n    }\n\n    var inputShapes = inputShape;\n    var outputShape = inputShapes[0].slice();\n    var axis = this.axis < 0 ? outputShape.length + this.axis : this.axis;\n\n    for (var _i = 0, _a = inputShapes.slice(1); _i < _a.length; _i++) {\n      var shape = _a[_i];\n\n      if (outputShape[axis] == null || shape[axis] == null) {\n        outputShape[axis] = null;\n        break;\n      }\n\n      outputShape[axis] += shape[axis];\n    }\n\n    return outputShape;\n  };\n\n  return Concatenate;\n}(Merge);\n\nexports.Concatenate = Concatenate;\ngeneric_utils.ClassNameMap.register('Concatenate', Concatenate);\n\nfunction concatenate(config) {\n  if (Array.isArray(config)) {\n    var layer = new Concatenate({});\n    return layer.apply(config);\n  } else {\n    return new Concatenate(config);\n  }\n}\n\nexports.concatenate = concatenate;","map":null,"metadata":{},"sourceType":"script"}