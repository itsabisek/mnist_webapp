{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) {\n      if (b.hasOwnProperty(p)) d[p] = b[p];\n    }\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function sent() {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) {\n      try {\n        if (f = 1, y && (t = y[op[0] & 2 ? \"return\" : op[0] ? \"throw\" : \"next\"]) && !(t = t.call(y, op[1])).done) return t;\n        if (y = 0, t) op = [0, t.value];\n\n        switch (op[0]) {\n          case 0:\n          case 1:\n            t = op;\n            break;\n\n          case 4:\n            _.label++;\n            return {\n              value: op[1],\n              done: false\n            };\n\n          case 5:\n            _.label++;\n            y = op[1];\n            op = [0];\n            continue;\n\n          case 7:\n            op = _.ops.pop();\n\n            _.trys.pop();\n\n            continue;\n\n          default:\n            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n              _ = 0;\n              continue;\n            }\n\n            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n              _.label = op[1];\n              break;\n            }\n\n            if (op[0] === 6 && _.label < t[1]) {\n              _.label = t[1];\n              t = op;\n              break;\n            }\n\n            if (t && _.label < t[2]) {\n              _.label = t[2];\n\n              _.ops.push(op);\n\n              break;\n            }\n\n            if (t[2]) _.ops.pop();\n\n            _.trys.pop();\n\n            continue;\n        }\n\n        op = body.call(thisArg, _);\n      } catch (e) {\n        op = [6, e];\n        y = 0;\n      } finally {\n        f = t = 0;\n      }\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar tfjs_core_1 = require(\"@tensorflow/tfjs-core\");\n\nvar K = require(\"./backend/tfjs_backend\");\n\nvar generic_utils = require(\"./utils/generic_utils\");\n\nvar Callback = function () {\n  function Callback() {\n    this.validationData = null;\n    this.model = null;\n  }\n\n  Callback.prototype.setParams = function (params) {\n    this.params = params;\n  };\n\n  Callback.prototype.setModel = function (model) {\n    this.model = model;\n  };\n\n  Callback.prototype.onEpochBegin = function (epoch, logs) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2];\n      });\n    });\n  };\n\n  Callback.prototype.onEpochEnd = function (epoch, logs) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2];\n      });\n    });\n  };\n\n  Callback.prototype.onBatchBegin = function (batch, logs) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2];\n      });\n    });\n  };\n\n  Callback.prototype.onBatchEnd = function (batch, logs) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2];\n      });\n    });\n  };\n\n  Callback.prototype.onTrainBegin = function (logs) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2];\n      });\n    });\n  };\n\n  Callback.prototype.onTrainEnd = function (logs) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2];\n      });\n    });\n  };\n\n  return Callback;\n}();\n\nexports.Callback = Callback;\n\nvar CallbackList = function () {\n  function CallbackList(callbacks, queueLength) {\n    if (queueLength === void 0) {\n      queueLength = 10;\n    }\n\n    if (callbacks == null) {\n      callbacks = [];\n    }\n\n    this.callbacks = callbacks;\n    this.queueLength = queueLength;\n  }\n\n  CallbackList.prototype.append = function (callback) {\n    this.callbacks.push(callback);\n  };\n\n  CallbackList.prototype.setParams = function (params) {\n    for (var _i = 0, _a = this.callbacks; _i < _a.length; _i++) {\n      var callback = _a[_i];\n      callback.setParams(params);\n    }\n  };\n\n  CallbackList.prototype.setModel = function (model) {\n    for (var _i = 0, _a = this.callbacks; _i < _a.length; _i++) {\n      var callback = _a[_i];\n      callback.setModel(model);\n    }\n  };\n\n  CallbackList.prototype.onEpochBegin = function (epoch, logs) {\n    return __awaiter(this, void 0, void 0, function () {\n      var _i, _a, callback;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            if (logs == null) {\n              logs = {};\n            }\n\n            _i = 0, _a = this.callbacks;\n            _b.label = 1;\n\n          case 1:\n            if (!(_i < _a.length)) return [3, 4];\n            callback = _a[_i];\n            return [4, callback.onEpochBegin(epoch, logs)];\n\n          case 2:\n            _b.sent();\n\n            _b.label = 3;\n\n          case 3:\n            _i++;\n            return [3, 1];\n\n          case 4:\n            return [2];\n        }\n      });\n    });\n  };\n\n  CallbackList.prototype.onEpochEnd = function (epoch, logs) {\n    return __awaiter(this, void 0, void 0, function () {\n      var _i, _a, callback;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            if (logs == null) {\n              logs = {};\n            }\n\n            _i = 0, _a = this.callbacks;\n            _b.label = 1;\n\n          case 1:\n            if (!(_i < _a.length)) return [3, 4];\n            callback = _a[_i];\n            return [4, callback.onEpochEnd(epoch, logs)];\n\n          case 2:\n            _b.sent();\n\n            _b.label = 3;\n\n          case 3:\n            _i++;\n            return [3, 1];\n\n          case 4:\n            return [2];\n        }\n      });\n    });\n  };\n\n  CallbackList.prototype.onBatchBegin = function (batch, logs) {\n    return __awaiter(this, void 0, void 0, function () {\n      var _i, _a, callback;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            if (logs == null) {\n              logs = {};\n            }\n\n            _i = 0, _a = this.callbacks;\n            _b.label = 1;\n\n          case 1:\n            if (!(_i < _a.length)) return [3, 4];\n            callback = _a[_i];\n            return [4, callback.onBatchBegin(batch, logs)];\n\n          case 2:\n            _b.sent();\n\n            _b.label = 3;\n\n          case 3:\n            _i++;\n            return [3, 1];\n\n          case 4:\n            return [2];\n        }\n      });\n    });\n  };\n\n  CallbackList.prototype.onBatchEnd = function (batch, logs) {\n    return __awaiter(this, void 0, void 0, function () {\n      var _i, _a, callback;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            if (logs == null) {\n              logs = {};\n            }\n\n            _i = 0, _a = this.callbacks;\n            _b.label = 1;\n\n          case 1:\n            if (!(_i < _a.length)) return [3, 4];\n            callback = _a[_i];\n            return [4, callback.onBatchEnd(batch, logs)];\n\n          case 2:\n            _b.sent();\n\n            _b.label = 3;\n\n          case 3:\n            _i++;\n            return [3, 1];\n\n          case 4:\n            return [2];\n        }\n      });\n    });\n  };\n\n  CallbackList.prototype.onTrainBegin = function (logs) {\n    return __awaiter(this, void 0, void 0, function () {\n      var _i, _a, callback;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            if (logs == null) {\n              logs = {};\n            }\n\n            _i = 0, _a = this.callbacks;\n            _b.label = 1;\n\n          case 1:\n            if (!(_i < _a.length)) return [3, 4];\n            callback = _a[_i];\n            return [4, callback.onTrainBegin(logs)];\n\n          case 2:\n            _b.sent();\n\n            _b.label = 3;\n\n          case 3:\n            _i++;\n            return [3, 1];\n\n          case 4:\n            return [2];\n        }\n      });\n    });\n  };\n\n  CallbackList.prototype.onTrainEnd = function (logs) {\n    return __awaiter(this, void 0, void 0, function () {\n      var _i, _a, callback;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            if (logs == null) {\n              logs = {};\n            }\n\n            _i = 0, _a = this.callbacks;\n            _b.label = 1;\n\n          case 1:\n            if (!(_i < _a.length)) return [3, 4];\n            callback = _a[_i];\n            return [4, callback.onTrainEnd(logs)];\n\n          case 2:\n            _b.sent();\n\n            _b.label = 3;\n\n          case 3:\n            _i++;\n            return [3, 1];\n\n          case 4:\n            return [2];\n        }\n      });\n    });\n  };\n\n  return CallbackList;\n}();\n\nexports.CallbackList = CallbackList;\n\nvar BaseLogger = function (_super) {\n  __extends(BaseLogger, _super);\n\n  function BaseLogger() {\n    return _super.call(this) || this;\n  }\n\n  BaseLogger.prototype.onEpochBegin = function (epoch, logs) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        this.seen = 0;\n        this.totals = {};\n        return [2];\n      });\n    });\n  };\n\n  BaseLogger.prototype.onBatchEnd = function (batch, logs) {\n    return __awaiter(this, void 0, void 0, function () {\n      var _this = this;\n\n      var batchSize, _loop_1, this_1, key;\n\n      return __generator(this, function (_a) {\n        if (logs == null) {\n          logs = {};\n        }\n\n        batchSize = logs['size'] == null ? 0 : logs['size'];\n        this.seen += batchSize;\n\n        _loop_1 = function _loop_1(key) {\n          var value = logs[key];\n\n          if (typeof value === 'number') {\n            if (!this_1.totals.hasOwnProperty(key)) {\n              this_1.totals[key] = 0;\n            }\n\n            this_1.totals[key] = this_1.totals[key] + value * batchSize;\n          } else {\n            if (!this_1.totals.hasOwnProperty(key)) {\n              this_1.totals[key] = K.getScalar(0);\n            }\n\n            tfjs_core_1.tidy(function () {\n              _this.totals[key] = K.scalarPlusArray(_this.totals[key], K.multiply(value, K.getScalar(batchSize)));\n              K.keep(_this.totals[key]);\n            });\n          }\n        };\n\n        this_1 = this;\n\n        for (key in logs) {\n          _loop_1(key);\n        }\n\n        return [2];\n      });\n    });\n  };\n\n  BaseLogger.prototype.onEpochEnd = function (epoch, logs) {\n    return __awaiter(this, void 0, void 0, function () {\n      var _this = this;\n\n      var _loop_2, this_2, _i, _a, key;\n\n      return __generator(this, function (_b) {\n        if (logs != null) {\n          _loop_2 = function _loop_2(key) {\n            if (this_2.totals[key] == null) {\n              return \"continue\";\n            }\n\n            if (typeof this_2.totals[key] === 'number') {\n              logs[key] = this_2.totals[key] / this_2.seen;\n            } else {\n              tfjs_core_1.tidy(function () {\n                logs[key] = K.scalarTimesArray(K.divide(K.getScalar(1), K.getScalar(_this.seen)), _this.totals[key]);\n                K.keep(logs[key]);\n              });\n            }\n          };\n\n          this_2 = this;\n\n          for (_i = 0, _a = this.params['metrics']; _i < _a.length; _i++) {\n            key = _a[_i];\n\n            _loop_2(key);\n          }\n        }\n\n        return [2];\n      });\n    });\n  };\n\n  return BaseLogger;\n}(Callback);\n\nexports.BaseLogger = BaseLogger;\n\nfunction resolveScalarsInLogs(logs) {\n  return __awaiter(this, void 0, void 0, function () {\n    var promises, keys, key, value, valueScalar, values, i;\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          if (logs == null) {\n            return [2];\n          }\n\n          promises = [];\n          keys = [];\n\n          for (key in logs) {\n            value = logs[key];\n\n            if (typeof value !== 'number') {\n              valueScalar = value;\n              promises.push(valueScalar.data());\n              keys.push(key);\n            }\n          }\n\n          return [4, Promise.all(promises)];\n\n        case 1:\n          values = _a.sent();\n\n          for (i = 0; i < values.length; ++i) {\n            logs[keys[i]] = values[i][0];\n          }\n\n          return [2];\n      }\n    });\n  });\n}\n\nexports.resolveScalarsInLogs = resolveScalarsInLogs;\n\nfunction disposeTensorsInLogs(logs) {\n  if (logs == null) {\n    return;\n  }\n\n  for (var key in logs) {\n    var value = logs[key];\n\n    if (typeof value !== 'number') {\n      value.dispose();\n    }\n  }\n}\n\nexports.disposeTensorsInLogs = disposeTensorsInLogs;\n\nvar History = function (_super) {\n  __extends(History, _super);\n\n  function History() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  History.prototype.onTrainBegin = function (logs) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        this.epoch = [];\n        this.history = {};\n        return [2];\n      });\n    });\n  };\n\n  History.prototype.onEpochEnd = function (epoch, logs) {\n    return __awaiter(this, void 0, void 0, function () {\n      var key;\n      return __generator(this, function (_a) {\n        if (logs == null) {\n          logs = {};\n        }\n\n        this.epoch.push(epoch);\n\n        for (key in logs) {\n          if (this.history[key] == null) {\n            this.history[key] = [];\n          }\n\n          this.history[key].push(logs[key]);\n        }\n\n        return [2];\n      });\n    });\n  };\n\n  History.prototype.syncData = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var promises, keys, indices, key, valueArray, i, valueScalar, values, n;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            promises = [];\n            keys = [];\n            indices = [];\n\n            for (key in this.history) {\n              valueArray = this.history[key];\n\n              for (i = 0; i < valueArray.length; ++i) {\n                if (typeof valueArray[i] !== 'number') {\n                  valueScalar = valueArray[i];\n                  promises.push(valueScalar.data());\n                  keys.push(key);\n                  indices.push(i);\n                }\n              }\n            }\n\n            return [4, Promise.all(promises)];\n\n          case 1:\n            values = _a.sent();\n\n            for (n = 0; n < values.length; ++n) {\n              this.history[keys[n]][indices[n]].dispose();\n              this.history[keys[n]][indices[n]] = values[n][0];\n            }\n\n            return [2];\n        }\n      });\n    });\n  };\n\n  return History;\n}(Callback);\n\nexports.History = History;\n\nvar CustomCallback = function (_super) {\n  __extends(CustomCallback, _super);\n\n  function CustomCallback(config) {\n    var _this = _super.call(this) || this;\n\n    _this.trainBegin = config.onTrainBegin;\n    _this.trainEnd = config.onTrainEnd;\n    _this.epochBegin = config.onEpochBegin;\n    _this.epochEnd = config.onEpochEnd;\n    _this.batchBegin = config.onBatchBegin;\n    _this.batchEnd = config.onBatchEnd;\n    return _this;\n  }\n\n  CustomCallback.prototype.onEpochBegin = function (epoch, logs) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (!(this.epochBegin != null)) return [3, 3];\n            return [4, resolveScalarsInLogs(logs)];\n\n          case 1:\n            _a.sent();\n\n            return [4, this.epochBegin(epoch, logs)];\n\n          case 2:\n            _a.sent();\n\n            _a.label = 3;\n\n          case 3:\n            return [2];\n        }\n      });\n    });\n  };\n\n  CustomCallback.prototype.onEpochEnd = function (epoch, logs) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (!(this.epochEnd != null)) return [3, 3];\n            return [4, resolveScalarsInLogs(logs)];\n\n          case 1:\n            _a.sent();\n\n            return [4, this.epochEnd(epoch, logs)];\n\n          case 2:\n            _a.sent();\n\n            _a.label = 3;\n\n          case 3:\n            return [2];\n        }\n      });\n    });\n  };\n\n  CustomCallback.prototype.onBatchBegin = function (batch, logs) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (!(this.batchBegin != null)) return [3, 3];\n            return [4, resolveScalarsInLogs(logs)];\n\n          case 1:\n            _a.sent();\n\n            return [4, this.batchBegin(batch, logs)];\n\n          case 2:\n            _a.sent();\n\n            _a.label = 3;\n\n          case 3:\n            return [2];\n        }\n      });\n    });\n  };\n\n  CustomCallback.prototype.onBatchEnd = function (batch, logs) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (!(this.batchEnd != null)) return [3, 3];\n            return [4, resolveScalarsInLogs(logs)];\n\n          case 1:\n            _a.sent();\n\n            return [4, this.batchEnd(batch, logs)];\n\n          case 2:\n            _a.sent();\n\n            _a.label = 3;\n\n          case 3:\n            return [2];\n        }\n      });\n    });\n  };\n\n  CustomCallback.prototype.onTrainBegin = function (logs) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (!(this.trainBegin != null)) return [3, 3];\n            return [4, resolveScalarsInLogs(logs)];\n\n          case 1:\n            _a.sent();\n\n            return [4, this.trainBegin(logs)];\n\n          case 2:\n            _a.sent();\n\n            _a.label = 3;\n\n          case 3:\n            return [2];\n        }\n      });\n    });\n  };\n\n  CustomCallback.prototype.onTrainEnd = function (logs) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (!(this.trainEnd != null)) return [3, 3];\n            return [4, resolveScalarsInLogs(logs)];\n\n          case 1:\n            _a.sent();\n\n            return [4, this.trainEnd(logs)];\n\n          case 2:\n            _a.sent();\n\n            _a.label = 3;\n\n          case 3:\n            return [2];\n        }\n      });\n    });\n  };\n\n  return CustomCallback;\n}(Callback);\n\nexports.CustomCallback = CustomCallback;\n\nfunction standardizeCallbacks(callbacks) {\n  if (callbacks == null) {\n    return null;\n  }\n\n  if (callbacks instanceof Callback) {\n    return [callbacks];\n  }\n\n  if (Array.isArray(callbacks) && callbacks[0] instanceof Callback) {\n    return callbacks;\n  }\n\n  var callbackConfigs = generic_utils.toList(callbacks);\n  return callbackConfigs.map(function (callbackConfig) {\n    return new CustomCallback(callbackConfig);\n  });\n}\n\nexports.standardizeCallbacks = standardizeCallbacks;","map":null,"metadata":{},"sourceType":"script"}