{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function sent() {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) {\n      try {\n        if (f = 1, y && (t = y[op[0] & 2 ? \"return\" : op[0] ? \"throw\" : \"next\"]) && !(t = t.call(y, op[1])).done) return t;\n        if (y = 0, t) op = [0, t.value];\n\n        switch (op[0]) {\n          case 0:\n          case 1:\n            t = op;\n            break;\n\n          case 4:\n            _.label++;\n            return {\n              value: op[1],\n              done: false\n            };\n\n          case 5:\n            _.label++;\n            y = op[1];\n            op = [0];\n            continue;\n\n          case 7:\n            op = _.ops.pop();\n\n            _.trys.pop();\n\n            continue;\n\n          default:\n            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n              _ = 0;\n              continue;\n            }\n\n            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n              _.label = op[1];\n              break;\n            }\n\n            if (op[0] === 6 && _.label < t[1]) {\n              _.label = t[1];\n              t = op;\n              break;\n            }\n\n            if (t && _.label < t[2]) {\n              _.label = t[2];\n\n              _.ops.push(op);\n\n              break;\n            }\n\n            if (t[2]) _.ops.pop();\n\n            _.trys.pop();\n\n            continue;\n        }\n\n        op = body.call(thisArg, _);\n      } catch (e) {\n        op = [6, e];\n        y = 0;\n      } finally {\n        f = t = 0;\n      }\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar environment_1 = require(\"../../environment\");\n\nvar tex_util = require(\"./tex_util\");\n\nvar webgl_util = require(\"./webgl_util\");\n\nfunction getWebGLContextAttributes() {\n  return {\n    alpha: false,\n    antialias: false,\n    premultipliedAlpha: false,\n    preserveDrawingBuffer: false,\n    depth: false,\n    stencil: false,\n    failIfMajorPerformanceCaveat: true\n  };\n}\n\nexports.getWebGLContextAttributes = getWebGLContextAttributes;\n\nfunction createWebGLContext(canvas) {\n  var attributes = getWebGLContextAttributes();\n  var gl;\n\n  if (canvas != null) {\n    gl = webgl_util.createWebGLRenderingContextFromCanvas(canvas, attributes);\n  } else {\n    gl = webgl_util.createWebGLRenderingContext(attributes);\n  }\n\n  webgl_util.callAndCheck(gl, function () {\n    return gl.disable(gl.DEPTH_TEST);\n  });\n  webgl_util.callAndCheck(gl, function () {\n    return gl.disable(gl.STENCIL_TEST);\n  });\n  webgl_util.callAndCheck(gl, function () {\n    return gl.disable(gl.BLEND);\n  });\n  webgl_util.callAndCheck(gl, function () {\n    return gl.disable(gl.DITHER);\n  });\n  webgl_util.callAndCheck(gl, function () {\n    return gl.disable(gl.POLYGON_OFFSET_FILL);\n  });\n  webgl_util.callAndCheck(gl, function () {\n    return gl.disable(gl.SAMPLE_COVERAGE);\n  });\n  webgl_util.callAndCheck(gl, function () {\n    return gl.enable(gl.SCISSOR_TEST);\n  });\n  webgl_util.callAndCheck(gl, function () {\n    return gl.enable(gl.CULL_FACE);\n  });\n  webgl_util.callAndCheck(gl, function () {\n    return gl.cullFace(gl.BACK);\n  });\n  return gl;\n}\n\nexports.createWebGLContext = createWebGLContext;\n\nfunction createVertexShader(gl) {\n  var vertexShaderSource = \"\\n    precision highp float;\\n    attribute vec3 clipSpacePos;\\n    attribute vec2 uv;\\n    varying vec2 resultUV;\\n\\n    void main() {\\n      gl_Position = vec4(clipSpacePos, 1);\\n      resultUV = uv;\\n    }\";\n  return webgl_util.createVertexShader(gl, vertexShaderSource);\n}\n\nexports.createVertexShader = createVertexShader;\n\nfunction createVertexBuffer(gl) {\n  var vertexArray = new Float32Array([-1, 1, 0, 0, 1, -1, -1, 0, 0, 0, 1, 1, 0, 1, 1, 1, -1, 0, 1, 0]);\n  return webgl_util.createStaticVertexBuffer(gl, vertexArray);\n}\n\nexports.createVertexBuffer = createVertexBuffer;\n\nfunction createIndexBuffer(gl) {\n  var triangleVertexIndices = new Uint16Array([0, 1, 2, 2, 1, 3]);\n  return webgl_util.createStaticIndexBuffer(gl, triangleVertexIndices);\n}\n\nexports.createIndexBuffer = createIndexBuffer;\n\nfunction getTextureInternalFormat(gl, numChannels) {\n  if (!environment_1.ENV.get('WEBGL_FLOAT_TEXTURE_ENABLED')) {\n    return gl.RGBA;\n  }\n\n  if (environment_1.ENV.get('WEBGL_VERSION') === 2) {\n    if (numChannels === 4) {\n      return gl.RGBA32F;\n    }\n\n    return gl.R32F;\n  }\n\n  return gl.RGBA;\n}\n\nfunction getTextureFormat(gl, numChannels) {\n  if (!environment_1.ENV.get('WEBGL_FLOAT_TEXTURE_ENABLED')) {\n    return gl.RGBA;\n  }\n\n  if (environment_1.ENV.get('WEBGL_VERSION') === 2) {\n    if (numChannels === 4) {\n      return gl.RGBA;\n    }\n\n    return gl.RED;\n  }\n\n  return gl.RGBA;\n}\n\nfunction getTextureType(gl) {\n  if (!environment_1.ENV.get('WEBGL_FLOAT_TEXTURE_ENABLED')) {\n    return gl.UNSIGNED_BYTE;\n  }\n\n  return gl.FLOAT;\n}\n\nfunction createAndConfigureTexture(gl, width, height, numChannels) {\n  webgl_util.validateTextureSize(gl, width, height);\n  var texture = webgl_util.createTexture(gl);\n  var tex2d = gl.TEXTURE_2D;\n  var internalFormat = getTextureInternalFormat(gl, numChannels);\n  var format = getTextureFormat(gl, numChannels);\n  webgl_util.callAndCheck(gl, function () {\n    return gl.bindTexture(tex2d, texture);\n  });\n  webgl_util.callAndCheck(gl, function () {\n    return gl.texParameteri(tex2d, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n  });\n  webgl_util.callAndCheck(gl, function () {\n    return gl.texParameteri(tex2d, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n  });\n  webgl_util.callAndCheck(gl, function () {\n    return gl.texParameteri(tex2d, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n  });\n  webgl_util.callAndCheck(gl, function () {\n    return gl.texParameteri(tex2d, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n  });\n  webgl_util.callAndCheck(gl, function () {\n    return gl.texImage2D(tex2d, 0, internalFormat, width, height, 0, format, getTextureType(gl), null);\n  });\n  webgl_util.callAndCheck(gl, function () {\n    return gl.bindTexture(gl.TEXTURE_2D, null);\n  });\n  return texture;\n}\n\nfunction createMatrixTexture(gl, rows, columns) {\n  var _a = tex_util.getUnpackedMatrixTextureShapeWidthHeight(rows, columns),\n      width = _a[0],\n      height = _a[1];\n\n  var numChannels = 1;\n  return createAndConfigureTexture(gl, width, height, numChannels);\n}\n\nexports.createMatrixTexture = createMatrixTexture;\n\nfunction createColorMatrixTexture(gl, rows, columns) {\n  var _a = tex_util.getColorMatrixTextureShapeWidthHeight(rows, columns),\n      width = _a[0],\n      height = _a[1];\n\n  var numChannels = 4;\n  return createAndConfigureTexture(gl, width, height, numChannels);\n}\n\nexports.createColorMatrixTexture = createColorMatrixTexture;\n\nfunction createPackedMatrixTexture(gl, rows, columns) {\n  var _a = tex_util.getPackedMatrixTextureShapeWidthHeight(rows, columns),\n      width = _a[0],\n      height = _a[1];\n\n  var numChannels = 4;\n  return createAndConfigureTexture(gl, width, height, numChannels);\n}\n\nexports.createPackedMatrixTexture = createPackedMatrixTexture;\n\nfunction bindVertexProgramAttributeStreams(gl, program, vertexBuffer) {\n  var posOffset = 0;\n  var uvOffset = 3 * 4;\n  var stride = 3 * 4 + 2 * 4;\n  webgl_util.callAndCheck(gl, function () {\n    return gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);\n  });\n  var success = webgl_util.bindVertexBufferToProgramAttribute(gl, program, 'clipSpacePos', vertexBuffer, 3, stride, posOffset);\n  return success && webgl_util.bindVertexBufferToProgramAttribute(gl, program, 'uv', vertexBuffer, 2, stride, uvOffset);\n}\n\nexports.bindVertexProgramAttributeStreams = bindVertexProgramAttributeStreams;\n\nfunction uploadPixelDataToTexture(gl, texture, pixels) {\n  webgl_util.callAndCheck(gl, function () {\n    return gl.bindTexture(gl.TEXTURE_2D, texture);\n  });\n  webgl_util.callAndCheck(gl, function () {\n    return gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, pixels);\n  });\n  webgl_util.callAndCheck(gl, function () {\n    return gl.bindTexture(gl.TEXTURE_2D, null);\n  });\n}\n\nexports.uploadPixelDataToTexture = uploadPixelDataToTexture;\n\nfunction uploadDataToTexture(gl, texture, width, height, data, numChannels) {\n  var textureFormat = getTextureFormat(gl, numChannels);\n  webgl_util.validateTextureSize(gl, width, height);\n  webgl_util.callAndCheck(gl, function () {\n    return gl.bindTexture(gl.TEXTURE_2D, texture);\n  });\n  webgl_util.callAndCheck(gl, function () {\n    return gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, width, height, textureFormat, getTextureType(gl), data);\n  });\n  webgl_util.callAndCheck(gl, function () {\n    return gl.bindTexture(gl.TEXTURE_2D, null);\n  });\n}\n\nfunction uploadMatrixToTexture(gl, texture, rows, columns, matrix, numChannels) {\n  var _a = tex_util.getUnpackedMatrixTextureShapeWidthHeight(rows, columns),\n      w = _a[0],\n      h = _a[1];\n\n  var unpackedArray;\n\n  if (environment_1.ENV.get('WEBGL_FLOAT_TEXTURE_ENABLED')) {\n    var channelsPerTexture = numChannels === 1 ? webgl_util.getChannelsPerTexture() : numChannels;\n\n    if (channelsPerTexture === 1) {\n      unpackedArray = matrix;\n    } else {\n      unpackedArray = new Float32Array(tex_util.getUnpackedArraySizeFromMatrixSize(matrix.length, channelsPerTexture));\n      tex_util.encodeMatrixToUnpackedArray(matrix, unpackedArray, channelsPerTexture);\n    }\n  } else {\n    unpackedArray = tex_util.encodeFloatArray(matrix);\n  }\n\n  uploadDataToTexture(gl, texture, w, h, unpackedArray, numChannels);\n}\n\nexports.uploadMatrixToTexture = uploadMatrixToTexture;\n\nfunction uploadMatrixToPackedTexture(gl, texture, rows, columns, matrix) {\n  var _a = tex_util.getPackedMatrixTextureShapeWidthHeight(rows, columns),\n      w = _a[0],\n      h = _a[1];\n\n  var packedRGBA = new Float32Array(tex_util.getPackedRGBAArraySizeFromMatrixShape(rows, columns));\n  tex_util.encodeMatrixToPackedRGBA(matrix, rows, columns, packedRGBA);\n  var numChannels = 4;\n  uploadDataToTexture(gl, texture, w, h, packedRGBA, numChannels);\n}\n\nexports.uploadMatrixToPackedTexture = uploadMatrixToPackedTexture;\n\nfunction getDownloadTargetArrayBuffer(rows, columns, channelsPerTexture) {\n  var isFloatTexture = environment_1.ENV.get('WEBGL_FLOAT_TEXTURE_ENABLED');\n  var downloadTarget;\n\n  if (isFloatTexture) {\n    downloadTarget = new Float32Array(tex_util.getUnpackedArraySizeFromMatrixSize(rows * columns, channelsPerTexture));\n  } else {\n    downloadTarget = new Uint8Array(rows * columns * channelsPerTexture);\n  }\n\n  return downloadTarget;\n}\n\nfunction decodeDownloadTargetArrayBuffer(downloadTarget, rows, columns, channelsPerPixel) {\n  var isFloatTexture = environment_1.ENV.get('WEBGL_FLOAT_TEXTURE_ENABLED');\n\n  if (isFloatTexture) {\n    var matrix = new Float32Array(rows * columns);\n    tex_util.decodeMatrixFromUnpackedArray(downloadTarget, matrix, channelsPerPixel);\n    return matrix;\n  } else {\n    return tex_util.decodeToFloatArray(downloadTarget);\n  }\n}\n\nfunction downloadMatrixFromOutputTextureAsync(gl, getBufferSubDataAsyncExtension, rows, columns) {\n  return __awaiter(this, void 0, void 0, function () {\n    var gl2, channelsPerPixel, downloadTarget, bufferSizeBytes, buffer;\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          gl2 = gl;\n          channelsPerPixel = 4;\n          downloadTarget = getDownloadTargetArrayBuffer(rows, columns, channelsPerPixel);\n          bufferSizeBytes = downloadTarget instanceof Float32Array ? downloadTarget.length * 4 : downloadTarget;\n          buffer = gl.createBuffer();\n          webgl_util.callAndCheck(gl, function () {\n            return gl.bindBuffer(gl2.PIXEL_PACK_BUFFER, buffer);\n          });\n          webgl_util.callAndCheck(gl, function () {\n            return gl.bufferData(gl2.PIXEL_PACK_BUFFER, bufferSizeBytes, gl.STATIC_DRAW);\n          });\n          webgl_util.callAndCheck(gl, function () {\n            return gl2.readPixels(0, 0, columns, rows, gl.RGBA, getTextureType(gl), 0);\n          });\n          return [4, getBufferSubDataAsyncExtension.getBufferSubDataAsync(gl2.PIXEL_PACK_BUFFER, 0, downloadTarget)];\n\n        case 1:\n          _a.sent();\n\n          return [2, decodeDownloadTargetArrayBuffer(downloadTarget, rows, columns, channelsPerPixel)];\n      }\n    });\n  });\n}\n\nexports.downloadMatrixFromOutputTextureAsync = downloadMatrixFromOutputTextureAsync;\n\nfunction downloadMatrixFromOutputTexture(gl, rows, columns) {\n  var _a = tex_util.getUnpackedMatrixTextureShapeWidthHeight(rows, columns),\n      w = _a[0],\n      h = _a[1];\n\n  var channelsPerPixel = 4;\n  var downloadTarget = getDownloadTargetArrayBuffer(rows, columns, channelsPerPixel);\n  webgl_util.callAndCheck(gl, function () {\n    return gl.readPixels(0, 0, w, h, gl.RGBA, getTextureType(gl), downloadTarget);\n  });\n  return decodeDownloadTargetArrayBuffer(downloadTarget, rows, columns, channelsPerPixel);\n}\n\nexports.downloadMatrixFromOutputTexture = downloadMatrixFromOutputTexture;\n\nfunction downloadMatrixFromRGBAColorTexture(gl, rows, columns, channels) {\n  var size = rows * columns * 4;\n  var downloadTarget = new Uint8Array(size);\n  webgl_util.callAndCheck(gl, function () {\n    return gl.readPixels(0, 0, columns, rows, gl.RGBA, gl.UNSIGNED_BYTE, downloadTarget);\n  });\n  var packedRGBA = new Float32Array(size);\n\n  for (var i = 0; i < downloadTarget.length; i++) {\n    packedRGBA[i] = downloadTarget[i];\n  }\n\n  var matrix = new Float32Array(rows * columns * channels);\n  tex_util.decodeMatrixFromUnpackedColorRGBAArray(packedRGBA, matrix, channels);\n  return matrix;\n}\n\nexports.downloadMatrixFromRGBAColorTexture = downloadMatrixFromRGBAColorTexture;\n\nfunction downloadMatrixFromPackedOutputTexture(gl, rows, columns) {\n  var _a = tex_util.getPackedMatrixTextureShapeWidthHeight(rows, columns),\n      w = _a[0],\n      h = _a[1];\n\n  var packedRGBA = new Float32Array(tex_util.getPackedRGBAArraySizeFromMatrixShape(rows, columns));\n  webgl_util.callAndCheck(gl, function () {\n    return gl.readPixels(0, 0, w, h, gl.RGBA, getTextureType(gl), packedRGBA);\n  });\n  var matrix = new Float32Array(rows * columns);\n  return tex_util.decodeMatrixFromPackedRGBA(packedRGBA, rows, columns, matrix);\n}\n\nexports.downloadMatrixFromPackedOutputTexture = downloadMatrixFromPackedOutputTexture;","map":null,"metadata":{},"sourceType":"script"}