{"ast":null,"code":"\"use strict\";\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {\n    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  }\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar device_util = require(\"./device_util\");\n\nvar doc_1 = require(\"./doc\");\n\nvar engine_1 = require(\"./engine\");\n\nvar util = require(\"./util\");\n\nvar Type;\n\n(function (Type) {\n  Type[Type[\"NUMBER\"] = 0] = \"NUMBER\";\n  Type[Type[\"BOOLEAN\"] = 1] = \"BOOLEAN\";\n  Type[Type[\"STRING\"] = 2] = \"STRING\";\n})(Type = exports.Type || (exports.Type = {}));\n\nexports.URL_PROPERTIES = [{\n  name: 'DEBUG',\n  type: Type.BOOLEAN\n}, {\n  name: 'WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION',\n  type: Type.NUMBER\n}, {\n  name: 'WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE',\n  type: Type.BOOLEAN\n}, {\n  name: 'WEBGL_VERSION',\n  type: Type.NUMBER\n}, {\n  name: 'WEBGL_FLOAT_TEXTURE_ENABLED',\n  type: Type.BOOLEAN\n}, {\n  name: 'WEBGL_GET_BUFFER_SUB_DATA_ASYNC_EXTENSION_ENABLED',\n  type: Type.BOOLEAN\n}, {\n  name: 'BACKEND',\n  type: Type.STRING\n}];\n\nfunction hasExtension(gl, extensionName) {\n  var ext = gl.getExtension(extensionName);\n  return ext != null;\n}\n\nfunction getWebGLRenderingContext(webGLVersion) {\n  if (webGLVersion === 0) {\n    throw new Error('Cannot get WebGL rendering context, WebGL is disabled.');\n  }\n\n  var tempCanvas = document.createElement('canvas');\n\n  if (webGLVersion === 1) {\n    return tempCanvas.getContext('webgl') || tempCanvas.getContext('experimental-webgl');\n  }\n\n  return tempCanvas.getContext('webgl2');\n}\n\nfunction loseContext(gl) {\n  if (gl != null) {\n    var loseContextExtension = gl.getExtension('WEBGL_lose_context');\n\n    if (loseContextExtension == null) {\n      throw new Error('Extension WEBGL_lose_context not supported on this browser.');\n    }\n\n    loseContextExtension.loseContext();\n  }\n}\n\nfunction isWebGLVersionEnabled(webGLVersion) {\n  var gl = getWebGLRenderingContext(webGLVersion);\n\n  if (gl != null) {\n    loseContext(gl);\n    return true;\n  }\n\n  return false;\n}\n\nfunction getWebGLDisjointQueryTimerVersion(webGLVersion) {\n  if (webGLVersion === 0) {\n    return 0;\n  }\n\n  var queryTimerVersion;\n  var gl = getWebGLRenderingContext(webGLVersion);\n\n  if (hasExtension(gl, 'EXT_disjoint_timer_query_webgl2') && webGLVersion === 2) {\n    queryTimerVersion = 2;\n  } else if (hasExtension(gl, 'EXT_disjoint_timer_query')) {\n    queryTimerVersion = 1;\n  } else {\n    queryTimerVersion = 0;\n  }\n\n  if (gl != null) {\n    loseContext(gl);\n  }\n\n  return queryTimerVersion;\n}\n\nfunction isFloatTextureReadPixelsEnabled(webGLVersion) {\n  if (webGLVersion === 0) {\n    return false;\n  }\n\n  var gl = getWebGLRenderingContext(webGLVersion);\n\n  if (webGLVersion === 1) {\n    if (!hasExtension(gl, 'OES_texture_float')) {\n      return false;\n    }\n  } else {\n    if (!hasExtension(gl, 'EXT_color_buffer_float')) {\n      return false;\n    }\n  }\n\n  var frameBuffer = gl.createFramebuffer();\n  var texture = gl.createTexture();\n  gl.bindTexture(gl.TEXTURE_2D, texture);\n  var internalFormat = webGLVersion === 2 ? gl.RGBA32F : gl.RGBA;\n  gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, 1, 1, 0, gl.RGBA, gl.FLOAT, null);\n  gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);\n  gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\n  var frameBufferComplete = gl.checkFramebufferStatus(gl.FRAMEBUFFER) === gl.FRAMEBUFFER_COMPLETE;\n  gl.readPixels(0, 0, 1, 1, gl.RGBA, gl.FLOAT, new Float32Array(4));\n  var readPixelsNoError = gl.getError() === gl.NO_ERROR;\n  loseContext(gl);\n  return frameBufferComplete && readPixelsNoError;\n}\n\nfunction isWebGLGetBufferSubDataAsyncExtensionEnabled(webGLVersion) {\n  if (webGLVersion > 0) {\n    return false;\n  }\n\n  if (webGLVersion !== 2) {\n    return false;\n  }\n\n  var gl = getWebGLRenderingContext(webGLVersion);\n  var isEnabled = hasExtension(gl, 'WEBGL_get_buffer_sub_data_async');\n  loseContext(gl);\n  return isEnabled;\n}\n\nvar Environment = function () {\n  function Environment(features) {\n    this.features = {};\n    this.registry = {};\n\n    if (features != null) {\n      this.features = features;\n    }\n\n    if (this.get('DEBUG')) {\n      console.warn('Debugging mode is ON. The output of every math call will ' + 'be downloaded to CPU and checked for NaNs. ' + 'This significantly impacts performance.');\n    }\n  }\n\n  Environment.setBackend = function (backendType, safeMode) {\n    if (safeMode === void 0) {\n      safeMode = false;\n    }\n\n    if (!(backendType in exports.ENV.registry)) {\n      throw new Error(\"Backend type '\" + backendType + \"' not found in registry\");\n    }\n\n    exports.ENV.initBackend(backendType, safeMode);\n  };\n\n  Environment.getBackend = function () {\n    exports.ENV.initDefaultBackend();\n    return exports.ENV.currentBackend;\n  };\n\n  Environment.memory = function () {\n    return exports.ENV.engine.memory();\n  };\n\n  Environment.prototype.get = function (feature) {\n    if (feature in this.features) {\n      return this.features[feature];\n    }\n\n    this.features[feature] = this.evaluateFeature(feature);\n    return this.features[feature];\n  };\n\n  Environment.prototype.set = function (feature, value) {\n    this.features[feature] = value;\n  };\n\n  Environment.prototype.getBestBackendType = function () {\n    var _this = this;\n\n    if (Object.keys(this.registry).length === 0) {\n      throw new Error('No backend found in registry.');\n    }\n\n    var sortedBackends = Object.keys(this.registry).map(function (name) {\n      return {\n        name: name,\n        entry: _this.registry[name]\n      };\n    }).sort(function (a, b) {\n      return b.entry.priority - a.entry.priority;\n    });\n    return sortedBackends[0].name;\n  };\n\n  Environment.prototype.evaluateFeature = function (feature) {\n    if (feature === 'DEBUG') {\n      return false;\n    } else if (feature === 'BACKEND') {\n      return this.getBestBackendType();\n    } else if (feature === 'WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION') {\n      var webGLVersion = this.get('WEBGL_VERSION');\n\n      if (webGLVersion === 0) {\n        return 0;\n      }\n\n      return getWebGLDisjointQueryTimerVersion(webGLVersion);\n    } else if (feature === 'WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE') {\n      return this.get('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION') > 0 && !device_util.isMobile();\n    } else if (feature === 'WEBGL_VERSION') {\n      if (isWebGLVersionEnabled(2)) {\n        return 2;\n      } else if (isWebGLVersionEnabled(1)) {\n        return 1;\n      }\n\n      return 0;\n    } else if (feature === 'WEBGL_FLOAT_TEXTURE_ENABLED') {\n      return isFloatTextureReadPixelsEnabled(this.get('WEBGL_VERSION'));\n    } else if (feature === 'WEBGL_GET_BUFFER_SUB_DATA_ASYNC_EXTENSION_ENABLED') {\n      return isWebGLGetBufferSubDataAsyncExtensionEnabled(this.get('WEBGL_VERSION'));\n    }\n\n    throw new Error(\"Unknown feature \" + feature + \".\");\n  };\n\n  Environment.prototype.setFeatures = function (features) {\n    this.features = features;\n  };\n\n  Environment.prototype.reset = function () {\n    this.features = getFeaturesFromURL();\n\n    if (this.globalEngine != null) {\n      this.globalEngine.dispose();\n      this.globalEngine = null;\n    }\n  };\n\n  Environment.prototype.initBackend = function (backendType, safeMode) {\n    if (safeMode === void 0) {\n      safeMode = false;\n    }\n\n    this.currentBackend = backendType;\n\n    if (this.globalEngine != null) {\n      this.globalEngine.dispose();\n    }\n\n    var backend = exports.ENV.findBackend(backendType);\n    this.globalEngine = new engine_1.Engine(backend, safeMode);\n  };\n\n  Environment.prototype.findBackend = function (name) {\n    if (!(name in this.registry)) {\n      return null;\n    }\n\n    return this.registry[name].backend;\n  };\n\n  Environment.prototype.registerBackend = function (name, factory, priority) {\n    if (priority === void 0) {\n      priority = 1;\n    }\n\n    if (name in this.registry) {\n      console.warn(name + \" backend was already registered\");\n    }\n\n    try {\n      var backend = factory();\n      this.registry[name] = {\n        backend: backend,\n        priority: priority\n      };\n      return true;\n    } catch (err) {\n      console.warn(err.message);\n      return false;\n    }\n  };\n\n  Environment.prototype.removeBackend = function (name) {\n    if (!(name in this.registry)) {\n      throw new Error(name + \" backend not found in registry\");\n    }\n\n    this.registry[name].backend.dispose();\n    delete this.registry[name];\n  };\n\n  Object.defineProperty(Environment.prototype, \"engine\", {\n    get: function get() {\n      this.initDefaultBackend();\n      return this.globalEngine;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  Environment.prototype.initDefaultBackend = function () {\n    if (this.globalEngine == null) {\n      this.initBackend(exports.ENV.get('BACKEND'), false);\n    }\n  };\n\n  __decorate([doc_1.doc({\n    heading: 'Environment'\n  })], Environment, \"setBackend\", null);\n\n  __decorate([doc_1.doc({\n    heading: 'Environment'\n  })], Environment, \"getBackend\", null);\n\n  __decorate([doc_1.doc({\n    heading: 'Performance',\n    subheading: 'Memory'\n  })], Environment, \"memory\", null);\n\n  return Environment;\n}();\n\nexports.Environment = Environment;\nvar TENSORFLOWJS_FLAGS_PREFIX = 'tfjsflags';\n\nfunction getFeaturesFromURL() {\n  var features = {};\n\n  if (typeof window === 'undefined') {\n    return features;\n  }\n\n  var urlParams = util.getQueryParams(window.location.search);\n\n  if (TENSORFLOWJS_FLAGS_PREFIX in urlParams) {\n    var urlFlags_1 = {};\n    var keyValues = urlParams[TENSORFLOWJS_FLAGS_PREFIX].split(',');\n    keyValues.forEach(function (keyValue) {\n      var _a = keyValue.split(':'),\n          key = _a[0],\n          value = _a[1];\n\n      urlFlags_1[key] = value;\n    });\n    exports.URL_PROPERTIES.forEach(function (urlProperty) {\n      if (urlProperty.name in urlFlags_1) {\n        console.log(\"Setting feature override from URL \" + urlProperty.name + \": \" + (\"\" + urlFlags_1[urlProperty.name]));\n\n        if (urlProperty.type === Type.NUMBER) {\n          features[urlProperty.name] = +urlFlags_1[urlProperty.name];\n        } else if (urlProperty.type === Type.BOOLEAN) {\n          features[urlProperty.name] = urlFlags_1[urlProperty.name] === 'true';\n        } else if (urlProperty.type === Type.STRING) {\n          features[urlProperty.name] = urlFlags_1[urlProperty.name];\n        } else {\n          console.warn(\"Unknown URL param: \" + urlProperty.name + \".\");\n        }\n      }\n    });\n  }\n\n  return features;\n}\n\nfunction getGlobalNamespace() {\n  var ns;\n\n  if (typeof window !== 'undefined') {\n    ns = window;\n  } else if (typeof global !== 'undefined') {\n    ns = global;\n  } else {\n    throw new Error('Could not find a global object');\n  }\n\n  return ns;\n}\n\nfunction getOrMakeEnvironment() {\n  var ns = getGlobalNamespace();\n  ns.ENV = ns.ENV || new Environment(getFeaturesFromURL());\n  return ns.ENV;\n}\n\nexports.ENV = getOrMakeEnvironment();","map":null,"metadata":{},"sourceType":"script"}